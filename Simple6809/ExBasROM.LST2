
a000                    UART      EQU  $A000
a001                    RECEV     EQU  a000(UART)+1
a001                    TRANS     EQU  a000(UART)+1
a000                    USTAT     EQU  a000(UART)
a000                    UCTRL     EQU  a000(UART)

0008                    BS        EQU  8                          BACKSPACE
000d                    CR        EQU  $D                         ENTER KEY
001b                    ESC       EQU  $1B                        ESCAPE CODE
0020                    SPACE     EQU  $20                        SPACE (BLANK)
003a                    STKBUF    EQU  58                         STACK BUFFER ROOM
00fa                    LBUFMX    EQU  250                        MAX NUMBER OF CHARS IN A BASIC LINE
00fa                    MAXLIN    EQU  $FA                        MAXIMUM MS BYTE OF LINE NUMBER
                        * PSEUDO OPS
0021                    SKP1      EQU  $21                        OP CODE OF BRN - SKIP ONE BYTE
008c                    SKP2      EQU  $8C                        OP CODE OF CMPX # - SKIP TWO BYTES
0086                    SKP1LD    EQU  $86                        OP CODE OF LDA # - SKIP THE NEXT BYTE
                        *                             AND LOAD THE VALUE OF THAT BYTE INTO ACCA - THIS
                        *                             IS USUALLY USED TO LOAD ACCA WITH A NON ZERO VALUE
0095                    RTS_LOW   EQU  $95
0000                              ORG  0
0000                    ENDFLG    RMB  1                          STOP/END FLAG: POSITIVE=STOP, NEG=END
0001                    CHARAC    RMB  1                          TERMINATOR FLAG 1
0002                    ENDCHR    RMB  1                          TERMINATOR FLAG 2
0003                    TMPLOC    RMB  1                          SCRATCH VARIABLE
0004                    IFCTR     RMB  1                          IF COUNTER - HOW MANY IF STATEMENTS IN A LINE
0005                    DIMFLG    RMB  1                          *DV* ARRAY FLAG 0=EVALUATE, 1=DIMENSIONING
0006                    VALTYP    RMB  1                          *DV* *PV TYPE FLAG: 0=NUMERIC, $FF=STRING
0007                    GARBFL    RMB  1                          *TV STRING SPACE HOUSEKEEPING FLAG
0008                    ARYDIS    RMB  1                          DISABLE ARRAY SEARCH: 00=ALLOW SEARCH
0009                    INPFLG    RMB  1                          *TV INPUT FLAG: READ=0, INPUT<>0
000a                    RELFLG    RMB  1                          *TV RELATIONAL OPERATOR FLAG
000b                    TEMPPT    RMB  2                          *PV TEMPORARY STRING STACK POINTER
000d                    LASTPT    RMB  2                          *PV ADDR OF LAST USED STRING STACK ADDRESS
000f                    TEMPTR    RMB  2                          TEMPORARY POINTER
0011                    TMPTR1    RMB  2                          TEMPORARY DESCRIPTOR STORAGE (STACK SEARCH)
0013                    FPA2      RMB  4                          FLOATING POINT ACCUMULATOR #2 MANTISSA
0017                    BOTSTK    RMB  2                          BOTTOM OF STACK AT LAST CHECK
0019                    TXTTAB    RMB  2                          *PV BEGINNING OF BASIC PROGRAM
001b                    VARTAB    RMB  2                          *PV START OF VARIABLES
001d                    ARYTAB    RMB  2                          *PV START OF ARRAYS
001f                    ARYEND    RMB  2                          *PV END OF ARRAYS (+1)
0021                    FRETOP    RMB  2                          *PV START OF STRING STORAGE (TOP OF FREE RAM)
0023                    STRTAB    RMB  2                          *PV START OF STRING VARIABLES
0025                    FRESPC    RMB  2                          UTILITY STRING POINTER
0027                    MEMSIZ    RMB  2                          *PV TOP OF STRING SPACE
0029                    OLDTXT    RMB  2                          SAVED LINE NUMBER DURING A "STOP"
002b                    BINVAL    RMB  2                          BINARY VALUE OF A CONVERTED LINE NUMBER
002d                    OLDPTR    RMB  2                          SAVED INPUT PTR DURING A "STOP"
002f                    TINPTR    RMB  2                          TEMPORARY INPUT POINTER STORAGE
0031                    DATTXT    RMB  2                          *PV 'DATA' STATEMENT LINE NUMBER POINTER
0033                    DATPTR    RMB  2                          *PV 'DATA' STATEMENT ADDRESS POINTER
0035                    DATTMP    RMB  2                          DATA POINTER FOR 'INPUT' & 'READ'
0037                    VARNAM    RMB  2                          *TV TEMP STORAGE FOR A VARIABLE NAME
0039                    VARPTR    RMB  2                          *TV POINTER TO A VARIABLE DESCRIPTOR
003b                    VARDES    RMB  2                          TEMP POINTER TO A VARIABLE DESCRIPTOR
003d                    RELPTR    RMB  2                          POINTER TO RELATIONAL OPERATOR PROCESSING ROUTINE
003f                    TRELFL    RMB  1                          TEMPORARY RELATIONAL OPERATOR FLAG BYTE
                        * FLOATING POINT ACCUMULATORS #3,4 & 5 ARE MOSTLY
                        * USED AS SCRATCH PAD VARIABLES.
                        ** FLOATING POINT ACCUMULATOR #3 :PACKED: ($40-$44)
0040                    V40       RMB  1
0041                    V41       RMB  1
0042                    V42       RMB  1
0043                    V43       RMB  1
0044                    V44       RMB  1
                        ** FLOATING POINT ACCUMULATOR #4 :PACKED: ($45-$49)
0045                    V45       RMB  1
0046                    V46       RMB  1
0047                    V47       RMB  1
0048                    V48       RMB  2
                        ** FLOATING POINT ACCUMULATOR #5 :PACKED: ($4A-$4E)
004a                    V4A       RMB  1
004b                    V4B       RMB  2
004d                    V4D       RMB  2
                        ** FLOATING POINT ACCUMULATOR #0
004f                    FP0EXP    RMB  1                          *PV FLOATING POINT ACCUMULATOR #0 EXPONENT
0050                    FPA0      RMB  4                          *PV FLOATING POINT ACCUMULATOR #0 MANTISSA
0054                    FP0SGN    RMB  1                          *PV FLOATING POINT ACCUMULATOR #0 SIGN
0055                    COEFCT    RMB  1                          POLYNOMIAL COEFFICIENT COUNTER
0056                    STRDES    RMB  5                          TEMPORARY STRING DESCRIPTOR
005b                    FPCARY    RMB  1                          FLOATING POINT CARRY BYTE
                        ** FLOATING POINT ACCUMULATOR #1
005c                    FP1EXP    RMB  1                          *PV FLOATING POINT ACCUMULATOR #1 EXPONENT
005d                    FPA1      RMB  4                          *PV FLOATING POINT ACCUMULATOR #1 MANTISSA
0061                    FP1SGN    RMB  1                          *PV FLOATING POINT ACCUMULATOR #1 SIGN
0062                    RESSGN    RMB  1                          SIGN OF RESULT OF FLOATING POINT OPERATION
0063                    FPSBYT    RMB  1                          FLOATING POINT SUB BYTE (FIFTH BYTE)
0064                    COEFPT    RMB  2                          POLYNOMIAL COEFFICIENT POINTER
0066                    LSTTXT    RMB  2                          CURRENT LINE POINTER DURING LIST
0068                    CURLIN    RMB  2                          *PV CURRENT LINE # OF BASIC PROGRAM, $FFFF = DIRECT
006a                    DEVCFW    RMB  1                          *TV TAB FIELD WIDTH
006b                    DEVLCF    RMB  1                          *TV TAB ZONE
006c                    DEVPOS    RMB  1                          *TV PRINT POSITION
006d                    DEVWID    RMB  1                          *TV PRINT WIDTH
006e                    RSTFLG    RMB  1                          *PV WARM START FLAG: $55=WARM, OTHER=COLD
006f                    RSTVEC    RMB  2                          *PV WARM START VECTOR - JUMP ADDRESS FOR WARM START
0071                    TOPRAM    RMB  2                          *PV TOP OF RAM
0073                    IKEYIM    RMB  1                          *TV INKEY$ RAM IMAGE
0074                    ZERO      RMB  2                          *PV DUMMY - THESE TWO BYTES ARE ALWAYS ZERO
                        * THE FOLLOWING BYTES ARE MOVED DOWN FROM ROM
0076                    LPTCFW    RMB  1                          16
0077                    LPTLCF    RMB  1                          112
0078                    LPTWID    RMB  1                          132
0079                    LPTPOS    RMB  1                          0
007a                    EXECJP    RMB  2                          LB4AA

                        * THIS ROUTINE PICKS UP THE NEXT INPUT CHARACTER FROM
                        * BASIC. THE ADDRESS OF THE NEXT BASIC BYTE TO BE
                        * INTERPRETED IS STORED AT CHARAD.
007c 0c 84              GETNCH    INC  <CHARAD+1                  *PV INCREMENT LS BYTE OF INPUT POINTER
007e 26 02                        BNE  GETCCH                     *PV BRANCH IF NOT ZERO (NO CARRY)
0080 0c 83                        INC  <CHARAD                    *PV INCREMENT MS BYTE OF INPUT POINTER
0082 b6                 GETCCH    FCB  $B6                        *PV OP CODE OF LDA EXTENDED
0083                    CHARAD    RMB  2                          *PV THESE 2 BYTES CONTAIN ADDRESS OF THE CURRENT
                        *         *    CHARACTER WHICH THE BASIC INTERPRETER IS
                        *         *    PROCESSING
0085 7e dc bf                     JMP  BROMHK                     JUMP BACK INTO THE BASIC RUM

0088                    VAB       RMB  1                          = LOW ORDER FOUR BYTES OF THE PRODUCT
0089                    VAC       RMB  1                          = OF A FLOATING POINT MULTIPLICATION
008a                    VAD       RMB  1                          = THESE BYTES ARE USE AS RANDOM DATA
008b                    VAE       RMB  1                          = BY THE RND STATEMENT

                        * EXTENDED BASIC VARIABLES
008c                    TRCFLG    RMB  1                          *PV TRACE FLAG 0=OFF ELSE=ON
008d                    USRADR    RMB  2                          *PV ADDRESS OF THE START OF USR VECTORS

                        * EXTENDED BASIC SCRATCH PAD VARIABLES
008f                    VCF       RMB  2
0091                    VD1       RMB  2
0093                    VD3       RMB  2
0095                    VD5       RMB  2
0097                    VD7       RMB  1
0098                    VD8       RMB  1
0099                    VD9       RMB  1
009a                    VDA       RMB  1
009b                    SW3VEC    RMB  3
009e                    SW2VEC    RMB  3
00a1                    SWIVEC    RMB  3
00a4                    NMIVEC    RMB  3
00a7                    IRQVEC    RMB  3
00aa                    FRQVEC    RMB  3
00ad                    USRJMP    RMB  3                          JUMP ADDRESS FOR BASIC'S USR FUNCTION
00b0                    RVSEED    RMB  1                          * FLOATING POINT RANDOM NUMBER SEED EXPONENT
00b1                              RMB  4                          * MANTISSA: INITIALLY SET TO $804FC75259

                        **** USR FUNCTION VECTOR ADDRESSES (EX BASIC ONLY)
00b5                    USR0      RMB  2                          USR 0 VECTOR
00b7                              RMB  2                          USR 1
00b9                              RMB  2                          USR 2
00bb                              RMB  2                          USR 3
00bd                              RMB  2                          USR 4
00bf                              RMB  2                          USR 5
00c1                              RMB  2                          USR 6
00c3                              RMB  2                          USR 7
00c5                              RMB  2                          USR 8
00c7                              RMB  2                          USR 9

00c9                    STRSTK    RMB  8*5                        STRING DESCRIPTOR STACK
00f1                    LINHDR    RMB  2                          LINE INPUT BUFFER HEADER
00f3                    LINBUF    RMB  00fa(LBUFMX)+1             BASIC LINE INPUT BUFFER
01ee                    STRBUF    RMB  41                         STRING BUFFER

0217                    PROGST    RMB  1                          START OF PROGRAM SPACE
                        *         INTERRUPT VECTORS
fff2                              ORG  $FFF2
fff2                    SWI3      RMB  2
fff4                    SWI2      RMB  2
fff6                    FIRQ      RMB  2
fff8                    IRQ       RMB  2
fffa                    SWI       RMB  2
fffc                    NMI       RMB  2
fffe                    RESETV    RMB  2



db00                              ORG  $DB00

                        * CONSOLE IN
db00 8d 03              LA171     BSR  KEYIN                      GET A CHARACTER FROM CONSOLE IN
db02 27 fc                        BEQ  db00(LA171)                LOOP IF NO KEY DOWN
db04 39                           RTS

                        *
                        * THIS ROUTINE GETS A KEYSTROKE FROM THE KEYBOARD IF A KEY
                        * IS DOWN. IT RETURNS ZERO TRUE IF THERE WAS NO KEY DOWN.
                        *
                        *
                        LA1C1
db05 b6 a0 00           KEYIN     LDA  a000(USTAT)
db08 85 01                        BITA #1
db0a 27 06                        BEQ  NOCHAR
db0c b6 a0 01                     LDA  a001(RECEV)
db0f 84 7f                        ANDA #$7F
db11 39                           RTS
db12 4f                 NOCHAR    CLRA
db13 39                           RTS



                        * CONSOLE OUT
db14 8d 24              PUTCHR    BSR  WAITACIA
db16 34 02                        PSHS A
db18 81 0d                        CMPA #000d(CR)                  IS IT CARRIAGE RETURN?
db1a 27 0b                        BEQ  NEWLINE                    YES
db1c b7 a0 01                     STA  a001(TRANS)
db1f 0c 79                        INC  0079(LPTPOS)               INCREMENT CHARACTER COUNTER
db21 96 79                        LDA  0079(LPTPOS)               CHECK FOR END OF LINE PRINTER LINE
db23 91 78                        CMPA 0078(LPTWID)               AT END OF LINE PRINTER LINE?
db25 25 10                        BLO  PUTEND                     NO
db27 0f 79              NEWLINE   CLR  0079(LPTPOS)               RESET CHARACTER COUNTER
db29 8d 0f                        BSR  WAITACIA
db2b 86 0d                        LDA  #13
db2d b7 a0 01                     STA  a001(TRANS)
db30 8d 08                        BSR  WAITACIA
db32 86 0a                        LDA  #10                        DO LINEFEED AFTER CR
db34 b7 a0 01                     STA  a001(TRANS)
db37 35 02              PUTEND    PULS A
db39 39                           RTS

db3a 34 02              WAITACIA  PSHS A
db3c b6 a0 00           WRWAIT    LDA  a000(USTAT)
db3f 85 02                        BITA #2
db41 27 f9                        BEQ  db3c(WRWAIT)
db43 35 02                        PULS A
db45 39                           RTS

                        *
                        RESVEC
db46 10 ce 01 ee        LA00E     LDS  #00f3(LINBUF)+LBUFMX+      1 SET STACK TO TOP OF LINE INPUT BUFFER
db4a 96 6e                        LDA  006e(RSTFLG)               GET WARM START FLAG
db4c 81 55                        CMPA #$55                       IS IT A WARM START?
db4e 26 0a                        BNE  BACDST                     NO - D0 A COLD START
db50 9e 6f                        LDX  006f(RSTVEC)               WARM START VECTOR
db52 a6 84                        LDA  ,X                         GET FIRST BYTE OF WARM START ADDR
db54 81 12                        CMPA #$12                       IS IT NOP?
db56 26 02                        BNE  BACDST                     NO - DO A COLD START
db58 6e 84                        JMP  ,X                         YES, G0 THERE

                        * COLD START ENTRY

db5a 8e 02 18           BACDST    LDX  #0217(PROGST)+1            POINT X TO CLEAR 1ST 1K OF RAM
db5d 6f 83              LA077     CLR  ,--X                       MOVE POINTER DOWN TWO-CLEAR BYTE
db5f 30 01                        LEAX 1,X                        ADVANCE POINTER ONE
db61 26 fa                        BNE  db5d(LA077)                KEEP GOING IF NOT AT BOTTOM OF PAGE 0
db63 8e 02 17                     LDX  #0217(PROGST)              SET TO START OF PROGRAM SPACE
db66 6f 80                        CLR  ,X+                        CLEAR 1ST BYTE OF BASIC PROGRAM
db68 9f 19                        STX  0019(TXTTAB)               BEGINNING OF BASIC PROGRAM
db6a a6 02              LA084     LDA  2,X                        LOOK FOR END OF MEMORY
db6c 43                           COMA                            * COMPLEMENT IT AND PUT IT BACK
db6d a7 02                        STA  2,X                        * INTO SYSTEM MEMORY
db6f a1 02                        CMPA 2,X                        IS IT RAM?
db71 26 06                        BNE  LA093                      BRANCH IF NOT (ROM, BAD RAM OR NO RAM)
db73 30 01                        LEAX 1,X                        MOVE POINTER UP ONE
db75 63 01                        COM  1,X                        RE-COMPLEMENT TO RESTORE BYTE
db77 20 f1                        BRA  db6a(LA084)                KEEP LOOKING FOR END OF RAM
db79 9f 71              LA093     STX  0071(TOPRAM)               SAVE ABSOLUTE TOP OF RAM
db7b 9f 27                        STX  0027(MEMSIZ)               SAVE TOP OF STRING SPACE
db7d 9f 23                        STX  0023(STRTAB)               SAVE START OF STRING VARIABLES
db7f 30 89 ff 38                  LEAX -200,X                     CLEAR 200 - DEFAULT STRING SPACE TO 200 BYTES
db83 9f 21                        STX  0021(FRETOP)               SAVE START OF STRING SPACE
db85 1f 14                        TFR  X,S                        PUT STACK THERE
db87 8e db ce                     LDX  #LA10D                     POINT X TO ROM SOURCE DATA
db8a ce 00 76                     LDU  #0076(LPTCFW)              POINT U TO RAM DESTINATION
db8d c6 12                        LDB  #18                        MOVE 18 BYTES
db8f bd dc ae                     JSR  LA59A                      MOVE 18 BYTES FROM ROM TO RAM
db92 ce 00 a7                     LDU  #00a7(IRQVEC)              POINT U TO NEXT RAM DESTINATION
db95 c6 04                        LDB  #4                         MOVE 4 MORE BYTES
db97 bd dc ae                     JSR  LA59A                      MOVE 4 BYTES FROM ROM TO RAM
db9a 86 39                        LDA  #$39
db9c 97 f0                        STA  00f1(LINHDR)-1             PUT RTS IN LINHDR-1
db9e bd df ba                     JSR  LAD19                      G0 DO A 'NEW'
                        * EXTENDED BASIC INITIALISATION
dba1 8e 00 b5                     LDX  #00b5(USR0)                INITIALIZE ADDRESS OF START OF
dba4 9f 8d                        STX  008d(USRADR)               USR JUMP TABLE
                        * INITIALIZE THE USR CALLS TO 'FC ERROR'
dba6 ce e6 ce                     LDU  #LB44A                     ADDRESS OF 'FC ERROR' ROUTINE
dba9 c6 0a                        LDB  #10                        10 USR CALLS IN EX BASIC
dbab ef 81              L8031     STU  ,X++                       STORE 'FC' ERROR AT USR ADDRESSES
dbad 5a                           DECB                            FINISHED ALL 10?
dbae 26 fb                        BNE  dbab(L8031)                NO

                        * INITIALISE ACIA
dbb0 86 95                        LDA  #0095(RTS_LOW)             DIV16 CLOCK -> 7372800 / 4 / 16 = 115200
dbb2 b7 a0 00                     STA  a000(UCTRL)
dbb5 8e dc 03                     LDX  #LA147-1                   POINT X TO COLOR BASIC COPYRIGHT MESSAGE
dbb8 bd eb e5                     JSR  LB99C                      PRINT 'COLOR BASIC'
dbbb 8e db c6                     LDX  #BAWMST                    WARM START ADDRESS
dbbe 9f 6f                        STX  006f(RSTVEC)               SAVE IT
dbc0 86 55                        LDA  #$55                       WARM START FLAG
dbc2 97 6e                        STA  006e(RSTFLG)               SAVE IT
dbc4 20 04                        BRA  LA0F3                      GO TO BASIC'S MAIN LOOP
dbc6 12                 BAWMST    NOP  NOP REQ'D FOR W            ARM START
dbc7 bd df d4                     JSR  LAD33                      DO PART OF A NEW
dbca 7e df 22           LA0F3     JMP  LAC73                      GO TO MAIN LOOP OF BASIC
                        *
                        * FIRQ SERVICE ROUTINE
                        BFRQSV
dbcd 3b                           RTI
                        *
                        * THESE BYTES ARE MOVED TO ADDRESSES $76 - $85 THE DIRECT PAGE
dbce 10                 LA10D     FCB  16                         TAB FIELD WIDTH
dbcf 40                           FCB  64                         LAST TAB ZONE
dbd0 50                           FCB  80                         PRINTER WIDTH
dbd1 00                           FCB  0                          LINE PRINTER POSITION
dbd2 e6 ce                        FDB  LB44A                      ARGUMENT OF EXEC COMMAND - SET TO 'FC' ERROR
                        * LINE INPUT ROUTINE
dbd4 0c 84                        INC  0083(CHARAD)+1
dbd6 26 02                        BNE  LA123
dbd8 0c 83                        INC  0083(CHARAD)
dbda b6 00 00           LA123     LDA  >0000
dbdd 7e dc bf                     JMP  BROMHK
                        *
                        * THESE BYTES ARE MOVED TO ADDRESSES $A7-$B1
dbe0 7e dc be                     JMP  BIRQSV                     IRQ SERVICE
dbe3 7e db cd                     JMP  BFRQSV                     FIRQ SERVICE
dbe6 7e e6 ce                     JMP  LB44A                      USR ADDRESS FOR 8K BASIC (INITIALIZED TO 'FC' ERROR)
dbe9 80                           FCB  $80                        *RANDOM SEED
dbea 4f c7                        FDB  $4FC7                      *RANDON SEED OF MANTISSA
dbec 52 59                        FDB  $5259                      *.811635157
                        * BASIC COMMAND INTERPRETATION TABLE ROM IMAGE
dbee 32                 COMVEC    FCB  50                         50 BASIC COMMANDS
dbef dd 1d                        FDB  LAA66                      POINTS TO RESERVED WORDS
dbf1 de 2a                        FDB  LAB67                      POINTS TO JUMP TABLE FOR COMMANDS
dbf3 1d                           FCB  29                         29 BASIC SECONDARY COMMANDS
dbf4 dd bd                        FDB  LAB1A                      POINTS TO SECONDARY FUNCTION RESERVED WORDS
dbf6 dc ce                        FDB  LAA29                      POINTS TO SECONDARY FUNCTION JUMP TABLE
dbf8 00 00                        FDB  0                          NO MORE TABLES (RES WORDS=0)
dbfa 00 00                        FDB  0                          NO MORE TABLES
dbfc 00 00                        FDB  0                          NO MORE TABLES
dbfe 00 00                        FDB  0                          NO MORE TABLES
dc00 00 00                        FDB  0                          NO MORE TABLES
dc02 00 00                        FDB  0                          NO MORE TABLES (SECONDARY FNS =0)

                        * COPYRIGHT MESSAGES
dc04 36 38 30 39 20 45  LA147     FCC  "6809 EXTENDED             BASIC"
58 54 45 4e 44 45
44 20 42 41 53 49
43
dc17 0d                           FCB  000d(CR)
dc18 28 43 29 20 31 39            FCC  "(C) 1982 BY MI            CROSOFT"
38 32 20 42 59 20
4d 49 43 52 4f 53
4f 46 54
dc2d 0d 0d              LA156     FCB  CR,CR
dc2f 00                 LA165     FCB  $00


dc30 34 16              LA35F     PSHS X,B,A                      SAVE REGISTERS
dc32 9e 76                        LDX  0076(LPTCFW)               TAB FIELD WIDTH AND TAB ZONE
dc34 dc 78                        LDD  0078(LPTWID)               PRINTER WIDTH AND POSITION
dc36 9f 6a              LA37C     STX  006a(DEVCFW)               SAVE TAB FIELD WIDTH AND ZONE
dc38 d7 6c                        STB  006c(DEVPOS)               SAVE PRINT POSITION
dc3a 97 6d                        STA  006d(DEVWID)               SAVE PRINT WIDTH
dc3c 35 96                        PULS A,B,X,PC                   RESTORE REGISTERS

                        * THIS IS THE ROUTINE THAT GETS AN INPUT LINE FOR BASIC
                        * EXIT WITH BREAK KEY: CARRY = 1
                        * EXIT WITH ENTER KEY: CARRY = 0
                        LA38D
dc3e 0f 73              LA390     CLR  0073(IKEYIM)               RESET BREAK CHECK KEY TEMP KEY STORAGE
dc40 8e 00 f4                     LDX  #00f3(LINBUF)+1            INPUT LINE BUFFER
dc43 c6 01                        LDB  #1                         ACCB CHAR COUNTER: SET TO 1 TO ALLOW A
                        *         BACKSPACE AS FIRST CHARACTER
dc45 bd db 00           LA39A     JSR  db00(LA171)                GO GET A CHARACTER FROM CONSOLE IN
dc48 81 08                        CMPA #0008(BS)                  BACKSPACE
dc4a 26 07                        BNE  LA3B4                      NO
dc4c 5a                           DECB                            YES - DECREMENT CHAR COUNTER
dc4d 27 ef                        BEQ  dc3e(LA390)                BRANCH IF BACK AT START OF LINE AGAIN
dc4f 30 1f                        LEAX -1,X                       DECREMENT BUFFER POINTER
dc51 20 34                        BRA  LA3E8                      ECHO CHAR TO SCREEN
dc53 81 15              LA3B4     CMPA #$15                       SHIFT RIGHT ARROW?
dc55 26 0a                        BNE  LA3C2                      NO
                        * YES, RESET BUFFER TO BEGINNING AND ERASE CURRENT LINE
dc57 5a                 LA3B8     DECB                            DEC CHAR CTR
dc58 27 e4                        BEQ  dc3e(LA390)                GO BACK TO START IF CHAR CTR = 0
dc5a 86 08                        LDA  #0008(BS)                  BACKSPACE?
dc5c bd db 14                     JSR  db14(PUTCHR)               SEND TO CONSOLE OUT (SCREEN)
dc5f 20 f6                        BRA  dc57(LA3B8)                KEEP GOING
dc61 81 03              LA3C2     CMPA #3                         BREAK KEY?
dc63 1a 01                        ORCC #1                         SET CARRY FLAG
dc65 27 05                        BEQ  LA3CD                      BRANCH IF BREAK KEY DOWN
dc67 81 0d              LA3C8     CMPA #000d(CR)                  ENTER KEY?
dc69 26 0d                        BNE  LA3D9                      NO
dc6b 4f                 LA3CC     CLRA                            CLEAR CARRY FLAG IF ENTER KEY - END LINE ENTRY
dc6c 34 01              LA3CD     PSHS CC                         SAVE CARRY FLAG
dc6e bd eb a5                     JSR  LB958                      SEND CR TO SCREEN
dc71 6f 84                        CLR  ,X                         MAKE LAST BYTE IN INPUT BUFFER = 0
dc73 8e 00 f3                     LDX  #00f3(LINBUF)              RESET INPUT BUFFER POINTER
dc76 35 81                        PULS CC,PC                      RESTORE CARRY FLAG

                        * INSERT A CHARACTER INTO THE BASIC LINE INPUT BUFFER
dc78 81 20              LA3D9     CMPA #$20                       IS IT CONTROL CHAR?
dc7a 25 c9                        BLO  dc45(LA39A)                BRANCH IF CONTROL CHARACTER
dc7c 81 7b                        CMPA #'z+1                      *
dc7e 24 c5                        BCC  dc45(LA39A)                * IGNORE IF > LOWER CASE Z
dc80 c1 fa                        CMPB #00fa(LBUFMX)              HAVE 250 OR MORE CHARACTERS BEEN ENTERED?
dc82 24 c1                        BCC  dc45(LA39A)                YES, IGNORE ANY MORE
dc84 a7 80                        STA  ,X+                        PUT IT IN INPUT BUFFER
dc86 5c                           INCB                            INCREMENT CHARACTER COUNTER
dc87 bd db 14           LA3E8     JSR  db14(PUTCHR)               ECHO IT TO SCREEN
dc8a 20 b9                        BRA  dc45(LA39A)                GO SET SOME MORE


                        * EXEC
dc8c 27 05              EXEC      BEQ  LA545                      BRANCH IF NO ARGUMENT
dc8e bd e9 c1                     JSR  LB73D                      EVALUATE ARGUMENT - ARGUMENT RETURNED IN X
dc91 9f 7a                        STX  007a(EXECJP)               STORE X TO EXEC JUMP ADDRESS
dc93 6e 9f 00 7a        LA545     JMP  [EXECJP]                   GO DO IT

                        * BREAK CHECK
dc97 7e e0 a3           LA549     JMP  LADEB                      GO DO BREAK KEY CHECK

                        * INKEY$
dc9a 96 73              INKEY     LDA  0073(IKEYIM)               WAS A KEY DOWN IN THE BREAK CHECK?
dc9c 26 03                        BNE  LA56B                      YES
dc9e bd db 05                     JSR  db05(KEYIN)                GO GET A KEY
dca1 0f 73              LA56B     CLR  0073(IKEYIM)               CLEAR INKEY RAM IMAGE
dca3 97 53                        STA  0050(FPA0)+3               STORE THE KEY IN FPA0
dca5 10 26 0c 6a                  LBNE LB68F                      CONVERT FPA0+3 TO A STRING
dca9 97 56                        STA  0056(STRDES)               SET LENGTH OF STRING = 0 IF NO KEY DOWN
dcab 7e e9 1f                     JMP  LB69B                      PUT A NULL STRING ONTO THE STRING STACK

                        * MOVE ACCB BYTES FROM (X) TO (U)
dcae a6 80              LA59A     LDA  ,X+                        GET BYTE FROM X
dcb0 a7 c0                        STA  ,U+                        STORE IT AT U
dcb2 5a                           DECB                            MOVED ALL BYTES?
dcb3 26 f9                        BNE  dcae(LA59A)                NO
dcb5 39                 LA5A1     RTS

dcb6 39                 LA5C4     RTS

                        ** THIS ROUTINE WILL SCAN OFF THE FILE NAME FROM A BASIC LINE
                        ** AND RETURN A SYNTAX ERROR IF THERE ARE ANY CHARACTERS
                        ** FOLLOWING THE END OF THE NAME
dcb7 9d 82              LA5C7     JSR  0082(GETCCH)               GET CURRENT INPUT CHAR FROM BASIC LINE
dcb9 27 fb              LA5C9     BEQ  dcb6(LA5C4)                RETURN IF END OF LINE
dcbb 7e e5 00                     JMP  LB277                      SYNTAX ERROR IF ANY MORE CHARACTERS
                        * IRQ SERVICE
                        BIRQSV
dcbe 3b                 LA9C5     RTI  RETURN FROM INT            ERRUPT

                        * SET CARRY IF NUMERIC - RETURN WITH
                        * ZERO FLAG SET IF ACCA = 0 OR 3A(:) - END
                        * OF BASIC LINE OR SUB LINE
dcbf 81 3a              BROMHK    CMPA #'9+1                      IS THIS CHARACTER >=(ASCII 9)+1?
dcc1 24 0a                        BHS  LAA28                      BRANCH IF > 9; Z SET IF = COLON
dcc3 81 20                        CMPA #0020(SPACE)               SPACE?
dcc5 26 02                        BNE  LAA24                      NO - SET CARRY IF NUMERIC
dcc7 0e 7c                        JMP  007c(GETNCH)               IF SPACE, GET NECT CHAR (IGNORE SPACES)
dcc9 80 30              LAA24     SUBA #'0                        * SET CARRY IF
dccb 80 d0                        SUBA #-'0                       * CHARACTER > ASCII 0
dccd 39                 LAA28     RTS

                        * DISPATCH TABLE FOR SECONDARY FUNCTIONS
                        * TOKENS ARE PRECEEDED BY $FF
                        * FIRST SET ALWAYS HAS ONE PARAMETER
                        FUNC_TAB
dcce ee c3              LAA29     FDB  SGN                        SGN
dcd0 ef 37                        FDB  INT                        INT
dcd2 ee dc                        FDB  ABS                        ABS
dcd4 00 ad                        FDB  00ad(USRJMP)               USR
0083                    TOK_USR   EQU  *-FUNC_TAB/2+$7            F
ff83                    TOK_FF_USR EQU  *-FUNC_TAB/2+$            FF7F
dcd6 f1 68                        FDB  RND                        RND
dcd8 f1 bd                        FDB  SIN                        SIN
dcda e9 d4                        FDB  PEEK                       PEEK
dcdc e9 05                        FDB  LEN                        LEN
dcde e7 81                        FDB  STR                        STR$
dce0 e9 9a                        FDB  VAL                        VAL
dce2 e9 24                        FDB  ASC                        ASC
dce4 e9 10                        FDB  CHR                        CHR$
dce6 f2 6d                        FDB  ATN                        ATN
dce8 f2 35                        FDB  COS                        COS
dcea f2 3e                        FDB  TAN                        TAN
dcec f3 af                        FDB  EXP                        EXP
dcee f3 e1                        FDB  FIX                        FIX
dcf0 f3 03                        FDB  LOG                        LOG
dcf2 f5 69                        FDB  POS                        POS
dcf4 f3 3d                        FDB  SQR                        SQR
dcf6 fa 3b                        FDB  HEXDOL                     HEX$
                        * LEFT, RIGHT AND MID ARE TREATED SEPARATELY
dcf8 e9 2f                        FDB  LEFT                       LEFT$
0095                    TOK_LEFT  EQU  *-FUNC_TAB/2+$7            F
dcfa e9 4c                        FDB  RIGHT                      RIGHT$
dcfc e9 53                        FDB  MID                        MID$
0097                    TOK_MID   EQU  *-FUNC_TAB/2+$7            F
                        * REMAINING FUNCTIONS
dcfe dc 9a                        FDB  dc9a(INKEY)                INKEY$
0098                    TOK_INKEY EQU  *-FUNC_TAB/2+$7            F
dd00 e7 72                        FDB  MEM                        MEM
dd02 f5 71                        FDB  VARPT                      VARPTR
dd04 f6 31                        FDB  INSTR                      INSTR
dd06 f6 01                        FDB  STRING                     STRING$
001d                    NUM_SEC_FNS EQU  *-FUNC_TAB/2

                        * THIS TABLE CONTAINS PRECEDENCES AND DISPATCH ADDRESSES FOR ARITHMETIC
                        * AND LOGICAL OPERATORS - THE NEGATION OPERATORS DO NOT ACT ON TWO OPERANDS
                        * S0 THEY ARE NOT LISTED IN THIS TABLE. THEY ARE TREATED SEPARATELY IN THE
                        * EXPRESSION EVALUATION ROUTINE. THEY ARE:
                        * UNARY NEGATION (-), PRECEDENCE &7D AND LOGICAL NEGATION (NOT), PRECEDENCE $5A
                        * THE RELATIONAL OPERATORS < > = ARE ALSO NOT LISTED, PRECEDENCE $64.
                        * A PRECEDENCE VALUE OF ZERO INDICATES END OF EXPRESSION OR PARENTHESES
                        *
dd08 79                 LAA51     FCB  $79
dd09 ec 0e                        FDB  LB9C5                      +
dd0b 79                           FCB  $79
dd0c ec 05                        FDB  LB9BC                      -
dd0e 7b                           FCB  $7B
dd0f ed 15                        FDB  LBACC                      *
dd11 7b                           FCB  $7B
dd12 ed da                        FDB  LBB91                      /
dd14 7f                           FCB  $7F
dd15 f3 46                        FDB  L8489                      EXPONENTIATION
dd17 50                           FCB  $50
dd18 e5 59                        FDB  LB2D5                      AND
dd1a 46                           FCB  $46
dd1b e5 58                        FDB  LB2D4                      OR

                        * THIS IS THE RESERVED WORD TABLE
                        * FIRST PART OF THE TABLE CONTAINS EXECUTABLE COMMANDS
dd1d 46 4f              LAA66     FCC  "FO"                       80
dd1f d2                           FCB  $80+'R'
dd20 47                           FCC  "G"                        81
dd21 cf                           FCB  $80+'O'
0081                    TOK_GO    EQU  $81
dd22 52 45                        FCC  "RE"                       82
dd24 cd                           FCB  $80+'M'
dd25 a7                           FCB  ''+$80                     83
dd26 45 4c 53                     FCC  "ELS"                      84
dd29 c5                           FCB  $80+'E'
dd2a 49                           FCC  "I"                        85
dd2b c6                           FCB  $80+'F'
dd2c 44 41 54                     FCC  "DAT"                      86
dd2f c1                           FCB  $80+'A'
dd30 50 52 49 4e                  FCC  "PRIN"                     87
dd34 d4                           FCB  $80+'T'
dd35 4f                           FCC  "O"                        88
dd36 ce                           FCB  $80+'N'
dd37 49 4e 50 55                  FCC  "INPU"                     89
dd3b d4                           FCB  $80+'T'
dd3c 45 4e                        FCC  "EN"                       8A
dd3e c4                           FCB  $80+'D'
dd3f 4e 45 58                     FCC  "NEX"                      8B
dd42 d4                           FCB  $80+'T'
dd43 44 49                        FCC  "DI"                       8C
dd45 cd                           FCB  $80+'M'
dd46 52 45 41                     FCC  "REA"                      8D
dd49 c4                           FCB  $80+'D'
dd4a 52 55                        FCC  "RU"                       8E
dd4c ce                           FCB  $80+'N'
dd4d 52 45 53 54 4f 52            FCC  "RESTOR"                   8F
dd53 c5                           FCB  $80+'E'
dd54 52 45 54 55 52               FCC  "RETUR"                    90
dd59 ce                           FCB  $80+'N'
dd5a 53 54 4f                     FCC  "STO"                      91
dd5d d0                           FCB  $80+'P'
dd5e 50 4f 4b                     FCC  "POK"                      92
dd61 c5                           FCB  $80+'E'
dd62 43 4f 4e                     FCC  "CON"                      93
dd65 d4                           FCB  $80+'T'
dd66 4c 49 53                     FCC  "LIS"                      94
dd69 d4                           FCB  $80+'T'
dd6a 43 4c 45 41                  FCC  "CLEA"                     95
dd6e d2                           FCB  $80+'R'
dd6f 4e 45                        FCC  "NE"                       96
dd71 d7                           FCB  $80+'W'
dd72 45 58 45                     FCC  "EXE"                      97
dd75 c3                           FCB  $80+'C'
dd76 54 52 4f                     FCC  "TRO"                      98
dd79 ce                           FCB  $80+'N'
dd7a 54 52 4f 46                  FCC  "TROF"                     99
dd7e c6                           FCB  $80+'F'
dd7f 44 45                        FCC  "DE"                       9A
dd81 cc                           FCB  $80+'L'
dd82 44 45                        FCC  "DE"                       9B
dd84 c6                           FCB  $80+'F'
dd85 4c 49 4e                     FCC  "LIN"                      9C
dd88 c5                           FCB  $80+'E'
dd89 52 45 4e 55                  FCC  "RENU"                     9D
dd8d cd                           FCB  $80+'M'
dd8e 45 44 49                     FCC  "EDI"                      9E
dd91 d4                           FCB  $80+'T'
                        * END OF EXECUTABLE COMMANDS. THE REMAINDER OF THE TABLE ARE NON-EXECUTABLE TOKENS
dd92 54 41 42                     FCC  "TAB"                      9F
dd95 a8                           FCB  $80+'('
009f                    TOK_TAB   EQU  $9F
dd96 54                           FCC  "T"                        A0
dd97 cf                           FCB  $80+'O'
00a0                    TOK_TO    EQU  $A0
dd98 53 55                        FCC  "SU"                       A1
dd9a c2                           FCB  $80+'B'
00a1                    TOK_SUB   EQU  $A1
dd9b 54 48 45                     FCC  "THE"                      A2
dd9e ce                           FCB  $80+'N'
00a2                    TOK_THEN  EQU  $A2
dd9f 4e 4f                        FCC  "NO"                       A3
dda1 d4                           FCB  $80+'T'
00a3                    TOK_NOT   EQU  $A3
dda2 53 54 45                     FCC  "STE"                      A4
dda5 d0                           FCB  $80+'P'
00a4                    TOK_STEP  EQU  $A4
dda6 4f 46                        FCC  "OF"                       A5
dda8 c6                           FCB  $80+'F'
dda9 ab                           FCB  '++$80                     A6
00a6                    TOK_PLUS  EQU  $A6
ddaa ad                           FCB  '-+$80                     A7
00a7                    TOK_MINUS EQU  $A7
ddab aa                           FCB  '*+$80                     A8
ddac af                           FCB  '/+$80                     A9
ddad de                           FCB  '^+$80                     AA
ddae 41 4e                        FCC  "AN"                       AB
ddb0 c4                           FCB  $80+'D'
ddb1 4f                           FCC  "O"                        AC
ddb2 d2                           FCB  $80+'R'
ddb3 be                           FCB  '>+$80                     AD
00ad                    TOK_GREATER EQU  $AD
ddb4 bd                           FCB  '=+$80                     AE
00ae                    TOK_EQUALS EQU  $AE
ddb5 bc                           FCB  '<+$80                     AF
ddb6 46                           FCC  "F"                        B0
ddb7 ce                           FCB  $80+'N'
00b0                    TOK_FN    EQU  $B0
ddb8 55 53 49 4e                  FCC  "USIN"                     B1
ddbc c7                           FCB  $80+'G'
00b1                    TOK_USING EQU  $B1
                        *

                        * FIRST SET ALWAYS HAS ONE PARAMETER
ddbd 53 47              LAB1A     FCC  "SG"                       80
ddbf ce                           FCB  $80+'N'
ddc0 49 4e                        FCC  "IN"                       81
ddc2 d4                           FCB  $80+'T'
ddc3 41 42                        FCC  "AB"                       82
ddc5 d3                           FCB  $80+'S'
ddc6 55 53                        FCC  "US"                       83
ddc8 d2                           FCB  $80+'R'
ddc9 52 4e                        FCC  "RN"                       84
ddcb c4                           FCB  $80+'D'
ddcc 53 49                        FCC  "SI"                       85
ddce ce                           FCB  $80+'N'
ddcf 50 45 45                     FCC  "PEE"                      86
ddd2 cb                           FCB  $80+'K'
ddd3 4c 45                        FCC  "LE"                       87
ddd5 ce                           FCB  $80+'N'
ddd6 53 54 52                     FCC  "STR"                      88
ddd9 a4                           FCB  $80+'$'
ddda 56 41                        FCC  "VA"                       89
dddc cc                           FCB  $80+'L'
dddd 41 53                        FCC  "AS"                       8A
dddf c3                           FCB  $80+'C'
dde0 43 48 52                     FCC  "CHR"                      8B
dde3 a4                           FCB  $80+'$'
dde4 41 54                        FCC  "AT"                       8C
dde6 ce                           FCB  $80+'N'
dde7 43 4f                        FCC  "CO"                       8D
dde9 d3                           FCB  $80+'S'
ddea 54 41                        FCC  "TA"                       8E
ddec ce                           FCB  $80+'N'
dded 45 58                        FCC  "EX"                       8F
ddef d0                           FCB  $80+'P'
ddf0 46 49                        FCC  "FI"                       90
ddf2 d8                           FCB  $80+'X'
ddf3 4c 4f                        FCC  "LO"                       91
ddf5 c7                           FCB  $80+'G'
ddf6 50 4f                        FCC  "PO"                       92
ddf8 d3                           FCB  $80+'S'
ddf9 53 51                        FCC  "SQ"                       93
ddfb d2                           FCB  $80+'R'
ddfc 48 45 58                     FCC  "HEX"                      94
ddff a4                           FCB  $80+'$'
                        * LEFT, RIGHT AND MID ARE TREATED SEPARATELY
de00 4c 45 46 54                  FCC  "LEFT"                     95
de04 a4                           FCB  $80+'$'
de05 52 49 47 48 54               FCC  "RIGHT"                    96
de0a a4                           FCB  $80+'$'
de0b 4d 49 44                     FCC  "MID"                      97
de0e a4                           FCB  $80+'$'
                        * REMAINING FUNCTIONS
de0f 49 4e 4b 45 59               FCC  "INKEY"                    98
de14 a4                           FCB  $80+'$'
de15 4d 45                        FCC  "ME"                       99
de17 cd                           FCB  $80+'M'
de18 56 41 52 50 54               FCC  "VARPT"                    9A
de1d d2                           FCB  $80+'R'
de1e 49 4e 53 54                  FCC  "INST"                     9B
de22 d2                           FCB  $80+'R'
de23 53 54 52 49 4e 47            FCC  "STRING"                   9C
de29 a4                           FCB  $80+'$'

                        *
                        * DISPATCH TABLE FOR COMMANDS TOKEN #
                        CMD_TAB
de2a df e8              LAB67     FDB  FOR                         80
de2c e1 33                        FDB  GO                          81
de2e e1 90                        FDB  REM                         82
0082                    TOK_REM   EQU  *-CMD_TAB/2+$7F
de30 e1 90                        FDB  REM                         83 (')
0083                    TOK_SNGL_Q EQU  *-CMD_TAB/2+$7            F
de32 e1 90                        FDB  REM                         84 (ELSE)
0084                    TOK_ELSE  EQU  *-CMD_TAB/2+$7F
de34 e1 c1                        FDB  IF                          85
0085                    TOK_IF    EQU  *-CMD_TAB/2+$7F
de36 e1 8d                        FDB  DATA                        86
0086                    TOK_DATA  EQU  *-CMD_TAB/2+$7F
de38 eb 6a                        FDB  PRINT                       87
0087                    TOK_PRINT EQU  *-CMD_TAB/2+$7F
de3a e1 ef                        FDB  ON                          88
de3c e2 9c                        FDB  INPUT                       89
0089                    TOK_INPUT EQU  *-CMD_TAB/2+$7F
de3e e0 ba                        FDB  END                         8A
de40 e3 81                        FDB  NEXT                        8B
de42 e5 d2                        FDB  DIM                         8C
de44 e2 d6                        FDB  READ                        8D
de46 e1 28                        FDB  RUN                         8E
de48 e0 9c                        FDB  RESTOR                     8F
de4a e1 6d                        FDB  RETURN                      90
de4c e0 be                        FDB  STOP                        91
de4e e9 db                        FDB  POKE                        92
de50 e0 e3                        FDB  CONT                       93
de52 e9 e2                        FDB  LIST                        94
de54 e0 f4                        FDB  CLEAR                       95
de56 df b8                        FDB  NEW                         96
de58 dc 8c                        FDB  dc8c(EXEC)                 97
de5a f5 64                        FDB  TRON                       98
de5c f5 65                        FDB  TROFF                      99
de5e f7 e0                        FDB  DEL                        9A
de60 f7 24                        FDB  DEF                        9B
de62 fe ce                        FDB  LINE                       9C
de64 f8 6a                        FDB  RENUM                      9D
de66 f3 f0                        FDB  EDIT                       9E
009e                    TOK_HIGH_EXEC EQU  *-CMD_TAB/2            +$7F

                        * ERROR MESSAGES AND THEIR NUMBERS AS USED INTERNALLY
de68 4e 46              LABAF     FCC  "NF"                       0 NEXT WITHOUT FOR
de6a 53 4e                        FCC  "SN"                       1 SYNTAX ERROR
de6c 52 47                        FCC  "RG"                       2 RETURN WITHOUT GOSUB
de6e 4f 44                        FCC  "OD"                       3 OUT OF DATA
de70 46 43                        FCC  "FC"                       4 ILLEGAL FUNCTION CALL
de72 4f 56                        FCC  "OV"                       5 OVERFLOW
de74 4f 4d                        FCC  "OM"                       6 OUT OF MEMORY
de76 55 4c                        FCC  "UL"                       7 UNDEFINED LINE NUMBER
de78 42 53                        FCC  "BS"                       8 BAD SUBSCRIPT
de7a 44 44                        FCC  "DD"                       9 REDIMENSIONED ARRAY
de7c 2f 30                        FCC  "/0"                       10 DIVISION BY ZERO
de7e 49 44                        FCC  "ID"                       11 ILLEGAL DIRECT STATEMENT
de80 54 4d                        FCC  "TM"                       12 TYPE MISMATCH
de82 4f 53                        FCC  "OS"                       13 OUT OF STRING SPACE
de84 4c 53                        FCC  "LS"                       14 STRING TOO LONG
de86 53 54                        FCC  "ST"                       15 STRING FORMULA TOO COMPLEX
de88 43 4e                        FCC  "CN"                       16 CAN'T CONTINUE
de8a 46 44                        FCC  "FD"                       17 BAD FILE DATA
de8c 41 4f                        FCC  "AO"                       18 FILE ALREADY OPEN
de8e 44 4e                        FCC  "DN"                       19 DEVICE NUMBER ERROR
de90 49 4f                        FCC  "IO"                       20 I/O ERROR
de92 46 4d                        FCC  "FM"                       21 BAD FILE MODE
de94 4e 4f                        FCC  "NO"                       22 FILE NOT OPEN
de96 49 45                        FCC  "IE"                       23 INPUT PAST END OF FILE
de98 44 53                        FCC  "DS"                       24 DIRECT STATEMENT IN FILE
                        * ADDITIONAL ERROR MESSAGES ADDED BY EXTENDED BASIC
de9a 55 46              L890B     FCC  "UF"                       25 UNDEFINED FUNCTION (FN) CALL
de9c 4e 45              L890D     FCC  "NE"                       26 FILE NOT FOUND

de9e 20 45 52 52 4f 52  LABE1     FCC  " ERROR"
dea4 00                           FCB  $00
dea5 20 49 4e 20        LABE8     FCC  " IN "
dea9 00                           FCB  $00
deaa 0d                 LABED     FCB  000d(CR)
deab 4f 4b              LABEE     FCC  "OK"
dead 0d 00                        FCB  CR,$00
deaf 0d                 LABF2     FCB  000d(CR)
deb0 42 52 45 41 4b               FCC  "BREAK"
deb5 00                           FCB  $00

                        * SEARCH THE STACK FOR 'GOSUB/RETURN' OR 'FOR/NEXT' DATA.
                        * THE 'FOR/NEXT' INDEX VARIABLE DESCRIPTOR ADDRESS BEING
                        * SOUGHT IS STORED IN VARDES. EACH BLOCK OF FOR/NEXT DATA IS 18
                        * BYTES WITH A $80 LEADER BYTE AND THE GOSUB/RETURN DATA IS 5 BYTES
                        * WITH AN $A6 LEADER BYTE. THE FIRST NON "FOR/NEXT" DATA
                        * IS CONSIDERED 'GOSUB/RETURN'
deb6 30 64              LABF9     LEAX 4,S                        POINT X TO 3RD ADDRESS ON STACK - IGNORE THE
                        *         FIRST TWO RETURN ADDRESSES ON THE STACK
deb8 c6 12              LABFB     LDB  #18                        18 BYTES SAVED ON STACK FOR EACH 'FOR' LOOP
deba 9f 0f                        STX  000f(TEMPTR)               SAVE POINTER
debc a6 84                        LDA  ,X                         GET 1ST BYTE
debe 80 80                        SUBA #$80                       * CHECK FOR TYPE OF STACK JUMP FOUND
dec0 26 15                        BNE  LAC1A                      * BRANCH IF NOT 'FOR/NEXT'
dec2 ae 01                        LDX  1,X                        = GET INDEX VARIABLE DESCRIPTOR
dec4 9f 11                        STX  0011(TMPTR1)               = POINTER AND SAVE IT IN TMPTR1
dec6 9e 3b                        LDX  003b(VARDES)               GET INDEX VARIABLE BEING SEARCHED FOR
dec8 27 09                        BEQ  LAC16                      BRANCH IF DEFAULT INDEX VARIABLE - USE THE
                        *                             FIRST 'FOR/NEXT' DATA FOUND ON STACK
                        *                             IF NO INDEX VARIABLE AFTER 'NEXT'
deca 9c 11                        CMPX 0011(TMPTR1)               DOES THE STACK INDEX MATCH THE ONE
                        *                             BEING SEARCHED FOR?
decc 27 09                        BEQ  LAC1A                      YES
dece 9e 0f                        LDX  000f(TEMPTR)               * RESTORE INITIAL POINTER, ADD
ded0 3a                           ABX                             * 18 TO IT AND LOOK FOR
ded1 20 e5                        BRA  deb8(LABFB)                * NEXT BLOCK OF DATA
ded3 9e 11              LAC16     LDX  0011(TMPTR1)               = GET 1ST INDEX VARIABLE FOUND AND
ded5 9f 3b                        STX  003b(VARDES)               = SAVE AS 'NEXT' INDEX
ded7 9e 0f              LAC1A     LDX  000f(TEMPTR)               POINT X TO START OF 'FOR/NEXT' DATA
ded9 4d                           TSTA                            SET ZERO FLAG IF 'FOR/NEXT' DATA
deda 39                           RTS
                        * CHECK FOR MEMORY SPACE FOR NEW TOP OF
                        * ARRAYS AND MOVE ARRAYS TO NEW LOCATION
dedb 8d 17              LAC1E     BSR  LAC37                      ACCD = NEW BOTTOM OF FREE RAM - IS THERE
                        *                             ROOM FOR THE STACK?
                        * MOVE BYTES FROM V43(X) TO V41(U) UNTIL (X) = V47 AND
                        * SAVE FINAL VALUE OF U IN V45
dedd de 41              LAC20     LDU  0041(V41)                  POINT U TO DESTINATION ADDRESS (V41)
dedf 33 41                        LEAU 1,U                        ADD ONE TO U - COMPENSATE FOR FIRST PSHU
dee1 9e 43                        LDX  0043(V43)                  POINT X TO SOURCE ADDRESS (V43)
dee3 30 01                        LEAX 1,X                        ADD ONE - COMPENSATE FOR FIRST LDA ,X
dee5 a6 82              LAC28     LDA  ,-X                        GRAB A BYTE FROM SOURCE
dee7 36 02                        PSHU A                          MOVE IT TO DESTINATION
dee9 9c 47                        CMPX 0047(V47)                  DONE?
deeb 26 f8                        BNE  dee5(LAC28)                NO - KEEP MOVING BYTES
deed df 45                        STU  0045(V45)                  SAVE FINAL DESTINATION ADDRESS
deef 39                 LAC32     RTS
                        * CHECK TO SEE IF THERE IS ROOM TO STORE 2*ACCB
                        * BYTES IN FREE RAM - OM ERROR IF NOT
def0 4f                 LAC33     CLRA                            * ACCD CONTAINS NUMBER OF EXTRA
def1 58                           ASLB                            * BYTES TO PUT ON STACK
def2 d3 1f                        ADDD 001f(ARYEND)               END OF PROGRAM AND VARIABLES
def4 c3 00 3a           LAC37     ADDD #003a(STKBUF)              ADD STACK BUFFER - ROOM FOR STACK?
def7 25 08                        BCS  LAC44                      BRANCH IF GREATER THAN $FFFF
def9 10 df 17                     STS  0017(BOTSTK)               CURRENT NEW BOTTOM OF STACK STACK POINTER
defc 10 93 17                     CMPD 0017(BOTSTK)               ARE WE GOING TO BE BELOW STACK?
deff 25 ee                        BCS  deef(LAC32)                YES - NO ERROR
df01 c6 0c              LAC44     LDB  #6*2                       OUT OF MEMORY ERROR

                        * ERROR SERVICING ROUTINE
df03 bd df d4           LAC46     JSR  LAD33                      RESET STACK, STRING STACK, CONTINUE POINTER
df06 bd eb a9                     JSR  LB95C                      SEND A CR TO SCREEN
df09 bd eb f8                     JSR  LB9AF                      SEND A '?' TO SCREEN
df0c 8e de 68                     LDX  #de68(LABAF)               POINT TO ERROR TABLE
df0f 3a                 LAC60     ABX                             ADD MESSAGE NUMBER OFFSET
df10 8d 31                        BSR  LACA0                      * GET TWO CHARACTERS FROM X AND
df12 8d 2f                        BSR  LACA0                      * SEND TO CONSOLE OUT (SCREEN)
df14 8e de 9d                     LDX  #de9e(LABE1)-1             POINT TO "ERROR" MESSAGE
df17 bd eb e5           LAC68     JSR  LB99C                      PRINT MESSAGE POINTED TO BY X
df1a 96 68                        LDA  0068(CURLIN)               GET CURRENT LINE NUMBER (CURL IN)
df1c 4c                           INCA                            TEST FOR DIRECT MODE
df1d 27 03                        BEQ  LAC73                      BRANCH IF DIRECT MODE
df1f bd f0 0e                     JSR  LBDC5                      PRINT 'IN ****'

                        * THIS IS THE MAIN LOOP OF BASIC WHEN IN DIRECT MODE
df22 bd eb a9           LAC73     JSR  LB95C                      MOVE CURSOR TO START OF LINE
df25 8e de aa                     LDX  #deaa(LABED)               POINT X TO 'OK', CR MESSAGE
df28 bd eb e5                     JSR  LB99C                      PRINT 'OK', CR
df2b bd dc 3e           LAC7C     JSR  dc3e(LA390)                GO GET AN INPUT LINE
df2e ce ff ff                     LDU  #$FFFF                     THE LINE NUMBER FOR DIRECT MODE IS $FFFF
df31 df 68                        STU  0068(CURLIN)               SAVE IT IN CURLIN
df33 25 f6                        BCS  df2b(LAC7C)                BRANCH IF LINE INPUT TERMINATED BY BREAK
df35 9f 83                        STX  0083(CHARAD)               SAVE (X) AS CURRENT INPUT POINTER - THIS WILL
                        *         ENABLE THE 'LIVE KEYBOARD' (DIRECT) MODE. THE
                        *         LINE JUST ENTERED WILL BE INTERPRETED
df37 9d 7c                        JSR  007c(GETNCH)               GET NEXT CHARACTER FROM BASIC
df39 27 f0                        BEQ  df2b(LAC7C)                NO LINE INPUT - GET ANOTHER LINE
df3b 25 0b                        BCS  LACA5                      BRANCH IF NUMER1C - THERE WAS A LINE NUMBER BEFORE
                        *         THE  STATEMENT ENTERED, SO THIS STATEMENT
                        *         WILL BE MERGED INTO THE BASIC PROGRAM
df3d bd ea 97                     JSR  LB821                      GO CRUNCH LINE
df40 7e e0 71                     JMP  LADC0                      GO EXECUTE THE STATEMENT (LIVE KEYBOARD)
                        *
df43 a6 80              LACA0     LDA  ,X+                        GET A CHARACTER
df45 7e eb fa                     JMP  LB9B1                      SEND TO CONSOLE OUT
                        * TAKE A LINE FROM THE LINE INPUT BUFFER
                        * AND INSERT IT INTO THE BASIC PROGRAM
df48 bd e2 14           LACA5     JSR  LAF67                      CONVERT LINE NUMBER TO BINARY
df4b 9e 2b              LACA8     LDX  002b(BINVAL)               GET CONVERTED LINE NUMBER
df4d 9f f1                        STX  00f1(LINHDR)               STORE IT IN LINE INPUT HEADER
df4f bd ea 97                     JSR  LB821                      GO CRUNCH THE LINE
df52 d7 03                        STB  0003(TMPLOC)               SAVE LINE LENGTH
df54 8d 4c                        BSR  LAD01                      FIND OUT WHERE TO INSERT LINE
df56 25 12                        BCS  LACC8                      BRANCH IF LINE NUMBER DOES NOT ALREADY EXIST
df58 dc 47                        LDD  0047(V47)                  GET ABSOLUTE ADDRESS OF LINE NUMBER
df5a a3 84                        SUBD ,X                         SUBTRACT ADDRESS OF NEXT LINE NUMBER
df5c d3 1b                        ADDD 001b(VARTAB)               * ADD TO CURRENT END OF PROGRAM - THIS WILL REMOVE
df5e dd 1b                        STD  001b(VARTAB)               * THE LENGTH OF THIS LINE NUMBER FROM THE PROGRAM
df60 ee 84                        LDU  ,X                         POINT U TO ADDRESS OF NEXT LINE NUMBER
                        * DELETE OLD LINE FROM BASIC PROGRAM
df62 37 02              LACC0     PULU A                          GET A BYTE FROM WHAT'S LEFT OF PROGRAM
df64 a7 80                        STA  ,X+                        MOVE IT DOWN
df66 9c 1b                        CMPX 001b(VARTAB)               COMPARE TO END OF BASIC PROGRAM
df68 26 f8                        BNE  df62(LACC0)                BRANCH IF NOT AT END
df6a 96 f3              LACC8     LDA  00f3(LINBUF)               * CHECK TO SEE IF THERE IS A LINE IN
df6c 27 1c                        BEQ  LACE9                      * THE BUFFER AND BRANCH IF NONE
df6e dc 1b                        LDD  001b(VARTAB)               = SAVE CURRENT END OF
df70 dd 43                        STD  0043(V43)                  = PROGRAM IN V43
df72 db 03                        ADDB 0003(TMPLOC)               * ADD LENGTH OF CRUNCHED LINE,
df74 89 00                        ADCA #0                         * PROPOGATE CARRY AND SAVE NEW END
df76 dd 41                        STD  0041(V41)                  * OF PROGRAM IN V41
df78 bd de db                     JSR  dedb(LAC1E)                = MAKE SURE THERE'S ENOUGH RAM FOR THIS
                        *         =    LINE & MAKE A HOLE IN BASIC FOR NEW LINE
df7b ce 00 ef                     LDU  #00f1(LINHDR)-2            POINT U TO LINE TO BE INSERTED
df7e 37 02              LACDD     PULU A                          GET A BYTE FROM NEW LINE
df80 a7 80                        STA  ,X+                        INSERT IT IN PROGRAM
df82 9c 45                        CMPX 0045(V45)                  * COMPARE TO ADDRESS OF END OF INSERTED
df84 26 f8                        BNE  df7e(LACDD)                * LINE AND BRANCH IF NOT DONE
df86 9e 41                        LDX  0041(V41)                  = GET AND SAVE
df88 9f 1b                        STX  001b(VARTAB)               = END OF PROGRAM
df8a 8d 36              LACE9     BSR  LAD21                      RESET INPUT POINTER, CLEAR VARIABLES, INITIALIZE
df8c 8d 02                        BSR  LACEF                      ADJUST START OF NEXT LINE ADDRESSES
df8e 20 9b                        BRA  df2b(LAC7C)                REENTER BASIC'S INPUT LOOP
                        * COMPUTE THE START OF NEXT LINE ADDRESSES FOR THE BASIC PROGRAM
df90 9e 19              LACEF     LDX  0019(TXTTAB)               POINT X TO START OF PROGRAM
df92 ec 84              LACF1     LDD  ,X                         GET ADDRESS OF NEXT LINE
df94 27 21                        BEQ  LAD16                      RETURN IF END OF PROGRAM
df96 33 04                        LEAU 4,X                        POINT U TO START OF BASIC TEXT IN LINE
df98 a6 c0              LACF7     LDA  ,U+                        * SKIP THROUGH THE LINE UNTIL A
df9a 26 fc                        BNE  df98(LACF7)                * ZERO (END OF LINE) IS FOUND
df9c ef 84                        STU  ,X                         SAVE THE NEW START OF NEXT LINE ADDRESS
df9e ae 84                        LDX  ,X                         POINT X TO START OF NEXT LINE
dfa0 20 f0                        BRA  df92(LACF1)                KEEP GOING
                        *
                        * FIND A LINE NUMBER IN THE BASIC PROGRAM
                        * RETURN WITH CARRY SET IF NO MATCH FOUND
dfa2 dc 2b              LAD01     LDD  002b(BINVAL)               GET THE LINE NUMBER TO FIND
dfa4 9e 19                        LDX  0019(TXTTAB)               BEGINNING OF PROGRAM
dfa6 ee 84              LAD05     LDU  ,X                         GET ADDRESS OF NEXT LINE NUMBER
dfa8 27 09                        BEQ  LAD12                      BRANCH IF END OF PROG
dfaa 10 a3 02                     CMPD 2,X                        IS IT A MATCH?
dfad 23 06                        BLS  LAD14                      CARRY SET IF LOWER; CARRY CLEAR IF MATCH
dfaf ae 84                        LDX  ,X                         X = ADDRESS OF NEXT LINE
dfb1 20 f3                        BRA  dfa6(LAD05)                KEEP LOOPING FOR LINE NUMBER
dfb3 1a 01              LAD12     ORCC #1                         SET CARRY FLAG
dfb5 9f 47              LAD14     STX  0047(V47)                  SAVE MATCH LINE NUMBER OR NUMBER OF LINE JUST AFTER
                        *                             WHERE IT SHOULD HAVE BEEN
dfb7 39                 LAD16     RTS

                        * NEW
dfb8 26 fb              NEW       BNE  dfb5(LAD14)                BRANCH IF ARGUMENT GIVEN
dfba 9e 19              LAD19     LDX  0019(TXTTAB)               GET START OF BASIC
dfbc 6f 80                        CLR  ,X+                        * PUT 2 ZERO BYTES THERE - ERASE
dfbe 6f 80                        CLR  ,X+                        * THE BASIC PROGRAM
dfc0 9f 1b                        STX  001b(VARTAB)               AND THE NEXT ADDRESS IS NOW THE END OF PROGRAM
dfc2 9e 19              LAD21     LDX  0019(TXTTAB)               GET START OF BASIC
dfc4 bd e1 68                     JSR  LAEBB                      PUT INPUT POINTER ONE BEFORE START OF BASIC
                        * ERASE ALL VARIABLES
dfc7 9e 27              LAD26     LDX  0027(MEMSIZ)               * RESET START OF STRING VARIABLES
dfc9 9f 23                        STX  0023(STRTAB)               * TO TOP OF STRING SPACE
dfcb bd e0 9c                     JSR  RESTOR                     RESET 'DATA' POINTER TO START OF BASIC
dfce 9e 1b                        LDX  001b(VARTAB)               * GET START OF VARIABLES AND USE IT
dfd0 9f 1d                        STX  001d(ARYTAB)               * TO RESET START OF ARRAYS
dfd2 9f 1f                        STX  001f(ARYEND)               RESET END OF ARRAYS
dfd4 8e 00 c9           LAD33     LDX  #00c9(STRSTK)              * RESET STRING STACK POINTER TO
dfd7 9f 0b                        STX  000b(TEMPPT)               * BOTTOM OF STRING STACK
dfd9 ae e4                        LDX  ,S                         GET RETURN ADDRESS OFF STACK
dfdb 10 de 21                     LDS  0021(FRETOP)               RESTORE STACK POINTER
dfde 6f e2                        CLR  ,-S                        PUT A ZERO BYTE ON STACK - TO CLEAR ANY RETURN OF
                        *                             FOR/NEXT DATA FROM THE STACK
dfe0 0f 2d                        CLR  002d(OLDPTR)               RESET 'CONT' ADDRESS SO YOU
dfe2 0f 2e                        CLR  002d(OLDPTR)+1             'CAN'T CONTINUE'
dfe4 0f 08                        CLR  0008(ARYDIS)               CLEAR THE ARRAY DISABLE FLAG
dfe6 6e 84                        JMP  ,X                         RETURN TO CALLING ROUTINE - THIS IS NECESSARY
                        *                             SINCE THE STACK WAS RESET
                        *
                        * FOR
                        *
                        * THE FOR COMMAND WILL STORE 18 BYTES ON THE STACK FOR
                        * EACH FOR-NEXT LOOP WHICH IS BEING PROCESSED. THESE
                        * BYTES ARE DEFINED AS FOLLOWS: 0- $80 (FOR FLAG);
                        *         1,2=INDEX VARIABLE DESCRIPTOR POINTER; 3-7=FP VALUE OF STEP;
                        *         8=STEP DIRECTION: $FF IF NEGATIVE; 0 IF ZERO; 1 IF POSITIVE;
                        * 9-13=FP VALUE OF 'TO' PARAMETER;
                        * 14,15=CURRENT LINE NUMBER; 16,17=RAM ADDRESS OF THE END
                        *         OF   THE LINE CONTAINING THE 'FOR' STATEMENT
dfe8 86 80              FOR       LDA  #$80                       * SAVE THE DISABLE ARRAY FLAG IN VO8
dfea 97 08                        STA  0008(ARYDIS)               * DO NOT ALLOW THE INDEX VARIABLE TO BE AN ARRAY
dfec bd e2 36                     JSR  LET                        SET INDEX VARIABLE TO INITIAL VALUE
dfef bd de b6                     JSR  deb6(LABF9)                SEARCH THE STACK FOR 'FOR/NEXT' DATA
dff2 32 62                        LEAS 2,S                        PURGE RETURN ADDRESS OFF OF THE STACK
dff4 26 04                        BNE  LAD59                      BRANCH IF INDEX VARIABLE NOT ALREADY BEING USED
dff6 9e 0f                        LDX  000f(TEMPTR)               GET (ADDRESS + 18) OF MATCHED 'FOR/NEXT' DATA
dff8 32 85                        LEAS B,X                        MOVE THE STACK POINTER TO THE BEGINNING OF THE
                        * MATCHED 'FOR/NEXT' DATA SO THE NEW DATA WILL
                        * OVERLAY THE OLD DATA. THIS WILL ALSO DESTROY
                        * ALL OF THE 'RETURN' AND 'FOR/NEXT' DATA BELOW
                        * THIS POINT ON THE STACK
dffa c6 09              LAD59     LDB  #$09                       * CHECK FOR ROOM FOR 18 BYTES
dffc bd de f0                     JSR  def0(LAC33)                * IN FREE RAM
dfff bd e1 95                     JSR  LAEE8                      GET ADDR OF END OF SUBLINE IN X
e002 dc 68                        LDD  0068(CURLIN)               GET CURRENT LINE NUMBER
e004 34 16                        PSHS X,B,A                      SAVE LINE ADDR AND LINE NUMBER ON STACK
e006 c6 a0                        LDB  #00a0(TOK_TO)              TOKEN FOR 'TO'
e008 bd e4 f8                     JSR  LB26F                      SYNTAX CHECK FOR 'TO'
e00b bd e3 cc                     JSR  LB143                      'TM' ERROR IF INDEX VARIABLE SET TO STRING
e00e bd e3 ca                     JSR  LB141                      EVALUATE EXPRESSION
                        *
e011 d6 54                        LDB  0054(FP0SGN)               GET FPA0 MANTISSA SIGN
e013 ca 7f                        ORB  #$7F                       FORM A MASK TO SAVE DATA BITS OF HIGH ORDER MANTISSA
e015 d4 50                        ANDB 0050(FPA0)                 PUT THE MANTISSA SIGN IN BIT 7 OF HIGH ORDER MANTISSA
e017 d7 50                        STB  0050(FPA0)                 SAVE THE PACKED HIGH ORDER MANTISSA
e019 10 8e e0 20                  LDY  #LAD7F                     LOAD FOLLOWING ADDRESS INTO Y AS A RETURN
e01d 7e e4 73                     JMP  LB1EA                      ADDRESS - PUSH FPA0 ONTO THE STACK
e020 8e ed 0e           LAD7F     LDX  #LBAC5                     POINT X TO FLOATING POINT NUMBER 1.0 (DEFAULT STEP VALUE)
e023 bd ee 5d                     JSR  LBC14                      MOVE (X) TO FPA0
e026 9d 82                        JSR  0082(GETCCH)               GET CURRENT INPUT CHARACTER
e028 81 a4                        CMPA #00a4(TOK_STEP)            STEP TOKEN
e02a 26 05                        BNE  LAD90                      BRANCH IF NO 'STEP' VALUE
e02c 9d 7c                        JSR  007c(GETNCH)               GET A CHARACTER FROM BASIC
e02e bd e3 ca                     JSR  LB141                      EVALUATE NUMERIC EXPRESSION
e031 bd ee b6           LAD90     JSR  LBC6D                      CHECK STATUS OF FPA0
e034 bd e4 6f                     JSR  LB1E6                      SAVE STATUS AND FPA0 ON THE STACK
e037 dc 3b                        LDD  003b(VARDES)               * GET DESCRIPTOR POINTER FOR THE 'STEP'
e039 34 06                        PSHS B,A                        * VARIABLE AND SAVE IT ON THE STACK
e03b 86 80                        LDA  #$80                       = GET THE 'FOR' FLAG AND
e03d 34 02                        PSHS A                          = SAVE IT ON THE STACK
                        *
                        * MAIN COMMAND INTERPRETATION LOOP
e03f 1c af              LAD9E     ANDCC #$AF                       ENABLE IRQ,FIRQ
e041 8d 60                        BSR  LADEB                      CHECK FOR KEYBOARD BREAK
e043 9e 83                        LDX  0083(CHARAD)               GET BASIC'S INPUT POINTER
e045 9f 2f                        STX  002f(TINPTR)               SAVE IT
e047 a6 80                        LDA  ,X+                        GET CURRENT INPUT CHAR & MOVE POINTER
e049 27 07                        BEQ  LADB4                      BRANCH IF END OF LINE
e04b 81 3a                        CMPA #':                        CHECK FOR LINE SEPARATOR
e04d 27 22                        BEQ  LADC0                      BRANCH IF COLON
e04f 7e e5 00           LADB1     JMP  LB277                      'SYNTAX ERROR'-IF NOT LINE SEPARATOR
e052 a6 81              LADB4     LDA  ,X++                       GET MS BYTE OF ADDRESS OF NEXT BASIC LINE
e054 97 00                        STA  0000(ENDFLG)               SAVE IN STOP/END FLAG - CAUSE A STOP IF
                        *                             NEXT LINE ADDRESS IS < $8000; CAUSE
                        *                             AN END IF ADDRESS > $8000
e056 27 72                        BEQ  LAE15                      BRANCH TO 'STOP' - END OF PROGRAM
e058 ec 80                        LDD  ,X+                        GET CURRENT LINE NUMBER
e05a dd 68                        STD  0068(CURLIN)               SAVE IN CURLIN
e05c 9f 83                        STX  0083(CHARAD)               SAVE ADDRESS OF FIRST BYTE OF LINE
                        * EXTENDED BASIC TRACE
e05e 96 8c                        LDA  008c(TRCFLG)               TEST THE TRACE FLAG
e060 27 0f                        BEQ  LADC0                      BRANCH IF TRACE OFF
e062 86 5b                        LDA  #$5B                       <LEFT HAND MARKER FOR TRON LINE NUMBER
e064 bd db 14                     JSR  db14(PUTCHR)               OUTPUT A CHARACTER
e067 96 68                        LDA  0068(CURLIN)               GET MS BYTE OF LINE NUMBER
e069 bd f0 15                     JSR  LBDCC                      CONVERT ACCD TO DECIMAL AND PRINT ON SCREEN
e06c 86 5d                        LDA  #$5D                       > RIGHT HAND MARKER FOR TRON LINE NUMBER
e06e bd db 14                     JSR  db14(PUTCHR)               OUTPUT A CHARACTER
                        * END OF EXTENDED BASIC TRACE
e071 9d 7c              LADC0     JSR  007c(GETNCH)               GET A CHARACTER FROM BASIC
e073 8d 02                        BSR  LADC6                      GO PROCESS COMMAND
e075 20 c8                        BRA  e03f(LAD9E)                GO BACK TO MAIN LOOP
e077 27 29              LADC6     BEQ  LADEA                      RETURN IF END OF LINE (RTS - was BEQ LAE40)
e079 4d                           TSTA                            CHECK FOR TOKEN - BIT 7 SET (NEGATIVE)
e07a 10 2a 01 b8                  LBPL LET                        BRANCH IF NOT A TOKEN - GO DO A 'LET' WHICH
                        *                             IS THE 'DEFAULT' TOKEN FOR MICROSOFT BASIC
e07e 81 ff                        CMPA #$FF                       SECONDARY TOKEN
e080 27 0f                        BEQ  SECTOK
e082 81 9e                        CMPA #TOK_HIGH_EXEC             SKIPF TOKEN - HIGHEST EXECUTABLE COMMAND IN BASIC
e084 22 c9                        BHI  e04f(LADB1)                'SYNTAX ERROR' IF NON-EXECUTABLE TOKEN
e086 be db f1                     LDX  dbee(COMVEC)+3             GET ADDRESS OF BASIC'S COMMAND TABLE
e089 48                 LADD4     ASLA                            X2 (2 BYTE/JUMP ADDRESS) & DISCARD BIT 7
e08a 1f 89                        TFR  A,B                        SAVE COMMAND OFFSET IN ACCB
e08c 3a                           ABX                             NON X POINTS TO COMMAND JUMP ADDR
e08d 9d 7c                        JSR  007c(GETNCH)               GET AN INPUT CHAR
                        *
                        * HERE IS WHERE WE BRANCH TO DO A 'COMMAND'
e08f 6e 94                        JMP  [,X]                       GO DO A COMMAND
                        SECTOK
                        * THE ONLY SECONDARY TOKEN THAT CAN ALSO BE AN EXECUTABLE IS
                        * THE MID$ REPLACEMENT STATEMENT. SO SPECIAL-CASE CHECK DONE HERE
e091 9d 7c                        JSR  007c(GETNCH)               GET AN INPUT CHAR
e093 81 97                        CMPA #0097(TOK_MID)             TOKEN FOR "MID$"
e095 10 27 14 f0                  LBEQ L86D6                      PROCESS MID$ REPLACEMENT
e099 7e e5 00                     JMP  LB277                      SYNTAX ERROR

                        *
                        * RESTORE
e09c 9e 19              RESTOR    LDX  0019(TXTTAB)               BEGINNING OF PROGRAM ADDRESS
e09e 30 1f                        LEAX -1,X                       MOVE TO ONE BYTE BEFORE PROGRAM
e0a0 9f 33              LADE8     STX  0033(DATPTR)               SAVE NEW DATA POINTER
e0a2 39                 LADEA     RTS
                        *
                        * BREAK CHECK
e0a3 bd db 05           LADEB     JSR  LA1C1                      GET A KEYSTROKE ENTRY
e0a6 27 0a                        BEQ  LADFA                      RETURN IF NO INPUT
e0a8 81 03              LADF0     CMPA #3                         CONTROL C? (BREAK)
e0aa 27 12                        BEQ  STOP                       YES
e0ac 81 13                        CMPA #$13                       CONTROL S? (PAUSE)
e0ae 27 03                        BEQ  LADFB                      YES
e0b0 97 73                        STA  0073(IKEYIM)               SAVE KEYSTROKE IN INKEY IMAGE
e0b2 39                 LADFA     RTS
e0b3 bd db 05           LADFB     JSR  db05(KEYIN)                GET A KEY
e0b6 27 fb                        BEQ  e0b3(LADFB)                BRANCH IF NO KEY DOWN
e0b8 20 ee                        BRA  e0a8(LADF0)                CONTINUE - DO A BREAK CHECK
                        *
                        * END
e0ba 9d 82              END       JSR  0082(GETCCH)               GET CURRENT INPUT CHAR
e0bc 20 02                        BRA  LAE0B
                        *
                        * STOP
e0be 1a 01              STOP      ORCC #$01                       SET CARRY FLAG
e0c0 26 31              LAE0B     BNE  LAE40                      BRANCH IF ARGUMENT EXISTS
e0c2 9e 83                        LDX  0083(CHARAD)               * SAVE CURRENT POSITION OF
e0c4 9f 2f                        STX  002f(TINPTR)               * BASIC'S INPUT POINTER
e0c6 06 00              LAE11     ROR  0000(ENDFLG)               ROTATE CARRY INTO BIT 7 OF STOP/END FLAG
e0c8 32 62                        LEAS 2,S                        PURGE RETURN ADDRESS OFF STACK
e0ca 9e 68              LAE15     LDX  0068(CURLIN)               GET CURRENT LINE NUMBER
e0cc 8c ff ff                     CMPX #$FFFF                     DIRECT MODE?
e0cf 27 06                        BEQ  LAE22                      YES
e0d1 9f 29                        STX  0029(OLDTXT)               SAVE CURRENT LINE NUMBER
e0d3 9e 2f                        LDX  002f(TINPTR)               * GET AND SAVE CURRENT POSITION
e0d5 9f 2d                        STX  002d(OLDPTR)               * OF BASIC'S INPUT POINTER
                        LAE22
e0d7 8e de ae                     LDX  #deaf(LABF2)-1             POINT TO CR, 'BREAK' MESSAGE
e0da 0d 00                        TST  0000(ENDFLG)               CHECK STOP/END FLAG
e0dc 10 2a fe 42                  LBPL df22(LAC73)                BRANCH TO MAIN LOOP OF BASIC IF END
e0e0 7e df 17                     JMP  df17(LAC68)                PRINT 'BREAK AT ####' AND GO TO
                        *                             BASIC'S MAIN LOOP IF 'STOP'

                        * CONT
e0e3 26 0e              CONT      BNE  LAE40                      RETURN IF ARGUMENT GIVEN
e0e5 c6 20                        LDB  #2*16                      'CAN'T CONTINUE' ERROR
e0e7 9e 2d                        LDX  002d(OLDPTR)               GET CONTINUE ADDRESS (INPUT POINTER)
e0e9 10 27 fe 16                  LBEQ df03(LAC46)                'CN' ERROR IF CONTINUE ADDRESS = 0
e0ed 9f 83                        STX  0083(CHARAD)               RESET BASIC'S INPUT POINTER
e0ef 9e 29                        LDX  0029(OLDTXT)               GET LINE NUMBER
e0f1 9f 68                        STX  0068(CURLIN)               RESET CURRENT LINE NUMBER
e0f3 39                 LAE40     RTS
                        *
                        * CLEAR
e0f4 27 2c              CLEAR     BEQ  LAE6F                      BRANCH IF NO ARGUMENT
e0f6 bd e6 6a                     JSR  LB3E6                      EVALUATE ARGUMENT
e0f9 34 06                        PSHS B,A                        SAVE AMOUNT OF STRING SPACE ON STACK
e0fb 9e 27                        LDX  0027(MEMSIZ)               GET CURRENT TOP OF CLEARED SPACE
e0fd 9d 82                        JSR  0082(GETCCH)               GET CURRENT INPUT CHARACTER
e0ff 27 0c                        BEQ  LAE5A                      BRANCH IF NO NEW TOP OF CLEARED SPACE
e101 bd e4 f6                     JSR  LB26D                      SYNTAX CHECK FOR COMMA
e104 bd e9 c1                     JSR  LB73D                      EVALUATE EXPRESSlON; RETURN VALUE IN X
e107 30 1f                        LEAX -1,X                       X = TOP OF CLEARED SPACE
e109 9c 71                        CMPX 0071(TOPRAM)               COMPARE TO TOP OF RAM
e10b 22 18                        BHI  LAE72                      'OM' ERROR IF > TOP OF RAM
e10d 1f 10              LAE5A     TFR  X,D                        ACCD = TOP OF CLEARED SPACE
e10f a3 e1                        SUBD ,S++                       SUBTRACT OUT AMOUNT OF CLEARED SPACE
e111 25 12                        BCS  LAE72                      'OM' ERROR IF FREE MEM < 0
e113 1f 03                        TFR  D,U                        U = BOTTOM OF CLEARED SPACE
e115 83 00 3a                     SUBD #003a(STKBUF)              SUBTRACT OUT STACK BUFFER
e118 25 0b                        BCS  LAE72                      'OM' ERROR IF FREE MEM < 0
e11a 93 1b                        SUBD 001b(VARTAB)               SUBTRACT OUT START OF VARIABLES
e11c 25 07                        BCS  LAE72                      'OM' ERROR IF FREE MEM < 0
e11e df 21                        STU  0021(FRETOP)               SAVE NEW BOTTOM OF CLEARED SPACE
e120 9f 27                        STX  0027(MEMSIZ)               SAVE NEW TOP OF CLEARED SPACE
e122 7e df c7           LAE6F     JMP  dfc7(LAD26)                ERASE ALL VARIABLES, INITIALIZE POINTERS, ETC
e125 7e df 01           LAE72     JMP  df01(LAC44)                'OM' ERROR
                        *
                        * RUN
e128 9d 82              RUN       JSR  0082(GETCCH)               * GET CURRENT INPUT CHARACTER
e12a 10 27 fe 94                  LBEQ dfc2(LAD21)                * IF NO LINE NUMBER
e12e bd df c7                     JSR  dfc7(LAD26)                ERASE ALL VARIABLES
e131 20 19                        BRA  LAE9F                      'GOTO' THE RUN ADDRESS
                        *
                        * GO
e133 1f 89              GO        TFR  A,B                        SAVE INPUT CHARACTER IN ACCB
e135 9d 7c              LAE88     JSR  007c(GETNCH)               GET A CHARACTER FROM BASIC
e137 c1 a0                        CMPB #00a0(TOK_TO)              'TO' TOKEN
e139 27 16                        BEQ  LAEA4                      BRANCH IF GOTO
e13b c1 a1                        CMPB #00a1(TOK_SUB)             'SUB' TOKEN
e13d 26 45                        BNE  LAED7                      'SYNTAX ERROR' IF NEITHER
e13f c6 03                        LDB  #3                         =ROOM FOR 6
e141 bd de f0                     JSR  def0(LAC33)                =BYTES ON STACK?
e144 de 83                        LDU  0083(CHARAD)               * SAVE CURRENT BASIC INPUT POINTER, LINE
e146 9e 68                        LDX  0068(CURLIN)               * NUMBER AND SUB TOKEN ON STACK
e148 86 a1                        LDA  #00a1(TOK_SUB)             *
e14a 34 52                        PSHS U,X,A                      *
e14c 8d 03              LAE9F     BSR  LAEA4                      GO DO A 'GOTO'
e14e 7e e0 3f                     JMP  e03f(LAD9E)                JUMP BACK TO BASIC'S MAIN LOOP
                        * GOTO
e151 9d 82              LAEA4     JSR  0082(GETCCH)               GET CURRENT INPUT CHAR
e153 bd e2 14                     JSR  LAF67                      GET LINE NUMBER TO BINARY IN BINVAL
e156 8d 40                        BSR  LAEEB                      ADVANCE BASIC'S POINTER TO END OF LINE
e158 30 01                        LEAX $01,X                      POINT TO START OF NEXT LINE
e15a dc 2b                        LDD  002b(BINVAL)               GET THE LINE NUMBER TO RUN
e15c 10 93 68                     CMPD 0068(CURLIN)               COMPARE TO CURRENT LINE NUMBER
e15f 22 02                        BHI  LAEB6                      IF REO'D LINE NUMBER IS > CURRENT LINE NUMBER,
                        *              DON'T START LOOKING FROM
                        *              START OF PROGRAM
e161 9e 19                        LDX  0019(TXTTAB)               BEGINNING OF PROGRAM
e163 bd df a6           LAEB6     JSR  dfa6(LAD05)                GO FIND A LINE NUMBER
e166 25 17                        BCS  LAED2                      'UNDEFINED LINE NUMBER'
e168 30 1f              LAEBB     LEAX -1,X                       MOVE BACK TO JUST BEFORE START OF LINE
e16a 9f 83                        STX  0083(CHARAD)               RESET BASIC'S INPUT POINTER
e16c 39                 LAEBF     RTS
                        *
                        * RETURN
e16d 26 fd              RETURN    BNE  e16c(LAEBF)                EXIT ROUTINE IF ARGUMENT GIVEN
e16f 86 ff                        LDA  #$FF                       * PUT AN ILLEGAL VARIABLE NAME IN FIRST BYTE OF
e171 97 3b                        STA  003b(VARDES)               * VARDES WHICH WILL CAUSE 'FOR/NEXT' DATA ON THE
                        *              STACK TO BE IGNORED
e173 bd de b6                     JSR  deb6(LABF9)                CHECK FOR RETURN DATA ON THE STACK
e176 1f 14                        TFR  X,S                        RESET STACK POINTER - PURGE TWO RETURN ADDRESSES
                        *              FROM THE STACK
e178 81 21                        CMPA #00a1(TOK_SUB)-$80         SUB TOKEN - $80
e17a 27 0b                        BEQ  LAEDA                      BRANCH IF 'RETURN' FROM SUBROUTINE
e17c c6 04                        LDB  #2*2                       ERROR #2 'RETURN WITHOUT GOSUB'
e17e 8c                           FCB  008c(SKP2)                 SKIP TWO BYTES
e17f c6 0e              LAED2     LDB  #7*2                       ERROR #7 'UNDEFINED LINE NUMBER'
e181 7e df 03                     JMP  df03(LAC46)                JUMP TO ERROR HANDLER
e184 7e e5 00           LAED7     JMP  LB277                      'SYNTAX ERROR'
e187 35 52              LAEDA     PULS A,X,U                      * RESTORE VALUES OF CURRENT LINE NUMBER AND
e189 9f 68                        STX  0068(CURLIN)               * BASIC'S INPUT POINTER FOR THIS SUBROUTINE
e18b df 83                        STU  0083(CHARAD)               * AND LOAD ACCA WITH SUB TOKEN ($A6)
                        *
                        * DATA
e18d 8d 06              DATA      BSR  LAEE8                      MOVE INPUT POINTER TO END OF SUBLINE OR LINE
e18f 8c                           FCB  008c(SKP2)                 SKIP 2 BYTES

                        * REM, ELSE
                        ELSE
e190 8d 06              REM       BSR  LAEEB                      MOVE INPUT POINTER TO END OF LINE
e192 9f 83                        STX  0083(CHARAD)               RESET BASIC'S INPUT POINTER
e194 39                 LAEE7     RTS
                        * ADVANCE INPUT POINTER TO END OF SUBLINE OR LINE
e195 c6 3a              LAEE8     LDB  #':                        COLON = SUBLINE TERMINATOR CHARACTER
e197 86                 LAEEA     FCB  0086(SKP1LD)               SKPILD SKIP ONE BYTE; LDA #$5F
                        * ADVANCE BASIC'S INPUT POINTER TO END OF
                        * LINE - RETURN ADDRESS OF END OF LINE+1 IN X
e198 5f                 LAEEB     CLRB                            0 = LINE TERMINATOR CHARACTER
e199 d7 01                        STB  0001(CHARAC)               TEMP STORE PRIMARY TERMINATOR CHARACTER
e19b 5f                           CLRB                            0 (END OF LINE) = ALTERNATE TERM. CHAR.
e19c 9e 83                        LDX  0083(CHARAD)               LOAD X W/BASIC'S INPUT POINTER
e19e 1f 98              LAEF1     TFR  B,A                        * CHANGE TERMINATOR CHARACTER
e1a0 d6 01                        LDB  0001(CHARAC)               * FROM ACCB TO CHARAC - SAVE OLD TERMINATOR
                        *         IN   CHARAC
e1a2 97 01                        STA  0001(CHARAC)               SWAP PRIMARY AND SECONDARY TERMINATORS
e1a4 a6 84              LAEF7     LDA  ,X                         GET NEXT INPUT CHARACTER
e1a6 27 ec                        BEQ  e194(LAEE7)                RETURN IF 0 (END OF LINE)
e1a8 34 04                        PSHS B                          SAVE TERMINATOR ON STACK
e1aa a1 e0                        CMPA ,S+                        COMPARE TO INPUT CHARACTER
e1ac 27 e6                        BEQ  e194(LAEE7)                RETURN IF EQUAL
e1ae 30 01                        LEAX 1,X                        MOVE POINTER UP ONE
e1b0 81 22                        CMPA #'"                        CHECK FOR DOUBLE QUOTES
e1b2 27 ea                        BEQ  e19e(LAEF1)                BRANCH IF " - TOGGLE TERMINATOR CHARACTERS
e1b4 4c                           INCA                            * CHECK FOR $FF AND BRANCH IF
e1b5 26 02                        BNE  LAF0C                      * NOT SECONDARY TOKEN
e1b7 30 01                        LEAX 1,X                        MOVE INPUT POINTER 1 MORE IF SECONDARY
e1b9 81 86              LAF0C     CMPA #0085(TOK_IF)+1            TOKEN FOR IF?
e1bb 26 e7                        BNE  e1a4(LAEF7)                NO - GET ANOTHER INPUT CHARACTER
e1bd 0c 04                        INC  0004(IFCTR)                INCREMENT IF COUNTER - KEEP TRACK OF HOW MANY
                        *                             'IF' STATEMENTS ARE NESTED IN ONE LINE
e1bf 20 e3                        BRA  e1a4(LAEF7)                GET ANOTHER INPUT CHARACTER

                        * IF
e1c1 bd e3 ca           IF        JSR  LB141                      EVALUATE NUMERIC EXPRESSION
e1c4 9d 82                        JSR  0082(GETCCH)               GET CURRENT INPUT CHARACTER
e1c6 81 81                        CMPA #0081(TOK_GO)              TOKEN FOR GO
e1c8 27 05                        BEQ  LAF22                      TREAT 'GO' THE SAME AS 'THEN'
e1ca c6 a2                        LDB  #00a2(TOK_THEN)            TOKEN FOR THEN
e1cc bd e4 f8                     JSR  LB26F                      DO A SYNTAX CHECK ON ACCB
e1cf 96 4f              LAF22     LDA  004f(FP0EXP)               CHECK FOR TRUE/FALSE - FALSE IF FPA0 EXPONENT = ZERO
e1d1 26 13                        BNE  LAF39                      BRANCH IF CONDITION TRUE
e1d3 0f 04                        CLR  0004(IFCTR)                CLEAR FLAG - KEEP TRACK OF WHICH NESTED ELSE STATEMENT
                        *                             TO SEARCH FOR IN NESTED 'IF' LOOPS
e1d5 8d b6              LAF28     BSR  e18d(DATA)                 MOVE BASIC'S POINTER TO END OF SUBLINE
e1d7 4d                           TSTA                            * CHECK TO SEE IF END OF LINE OR SUBLINE
e1d8 27 ba                        BEQ  e194(LAEE7)                * AND RETURN IF END OF LINE
e1da 9d 7c                        JSR  007c(GETNCH)               GET AN INPUT CHARACTER FROM BASIC
e1dc 81 84                        CMPA #0084(TOK_ELSE)            TOKEN FOR ELSE
e1de 26 f5                        BNE  e1d5(LAF28)                IGNORE ALL DATA EXCEPT 'ELSE' UNTIL
                        *                             END OF LINE (ZERO BYTE)
e1e0 0a 04                        DEC  0004(IFCTR)                CHECK TO SEE IF YOU MUST SEARCH ANOTHER SUBLINE
e1e2 2a f1                        BPL  e1d5(LAF28)                BRANCH TO SEARCH ANOTHER SUBLINE FOR 'ELSE'
e1e4 9d 7c                        JSR  007c(GETNCH)               GET AN INPUT CHARACTER FROM BASIC
e1e6 9d 82              LAF39     JSR  0082(GETCCH)               GET CURRENT INPUT CHARACTER
e1e8 10 25 ff 65                  LBCS e151(LAEA4)                BRANCH TO 'GOTO' IF NUMERIC CHARACTER
e1ec 7e e0 77                     JMP  e077(LADC6)                RETURN TO MAIN INTERPRETATION LOOP

                        * ON
e1ef bd e9 8f           ON        JSR  LB70B                      EVALUATE EXPRESSION
e1f2 c6 81                        LDB  #0081(TOK_GO)              TOKEN FOR GO
e1f4 bd e4 f8                     JSR  LB26F                      SYNTAX CHECK FOR GO
e1f7 34 02                        PSHS A                          SAVE NEW TOKEN (TO,SUB)
e1f9 81 a1                        CMPA #00a1(TOK_SUB)             TOKEN FOR SUB?
e1fb 27 04                        BEQ  LAF54                      YES
e1fd 81 a0                        CMPA #00a0(TOK_TO)              TOKEN FOR TO?
e1ff 26 83              LAF52     BNE  e184(LAED7)                'SYNTAX' ERROR IF NOT 'SUB' OR 'TO'
e201 0a 53              LAF54     DEC  0050(FPA0)+3               DECREMENT IS BYTE OF MANTISSA OF FPA0 - THIS
                        *                             IS THE ARGUMENT OF THE 'ON' STATEMENT
e203 26 05                        BNE  LAF5D                      BRANCH IF NOT AT THE PROPER GOTO OR GOSUB LINE NUMBER
e205 35 04                        PULS B                          GET BACK THE TOKEN FOLLOWING 'GO'
e207 7e e1 35                     JMP  e135(LAE88)                GO DO A 'GOTO' OR 'GOSUB'
e20a 9d 7c              LAF5D     JSR  007c(GETNCH)               GET A CHARACTER FROM BASIC
e20c 8d 06                        BSR  LAF67                      CONVERT BASIC LINE NUMBER TO BINARY
e20e 81 2c                        CMPA #',                        IS CHARACTER FOLLOWING LINE NUMBER A COMMA?
e210 27 ef                        BEQ  e201(LAF54)                YES
e212 35 84                        PULS B,PC                       IF NOT, FALL THROUGH TO NEXT COMMAND
e214 9e 74              LAF67     LDX  0074(ZERO)                 DEFAULT LINE NUMBER OF ZERO
e216 9f 2b                        STX  002b(BINVAL)               SAVE IT IN BINVAL
                        *
                        * CONVERT LINE NUMBER TO BINARY - RETURN VALUE IN BINVAL
                        *
e218 24 61              LAF6B     BCC  LAFCE                      RETURN IF NOT NUMERIC CHARACTER
e21a 80 30                        SUBA #'0                        MASK OFF ASCII
e21c 97 01                        STA  0001(CHARAC)               SAVE DIGIT IN VO1
e21e dc 2b                        LDD  002b(BINVAL)               GET ACCUMULATED LINE NUMBER VALUE
e220 81 18                        CMPA #24                        LARGEST LINE NUMBER IS $F9FF (63999) -
                        *         (24*256+255)*10+9
e222 22 db                        BHI  e1ff(LAF52)                'SYNTAX' ERROR IF TOO BIG
                        * MULT ACCD X 10
e224 58                           ASLB                            *
e225 49                           ROLA                            * TIMES 2
e226 58                           ASLB                            =
e227 49                           ROLA                            = TIMES 4
e228 d3 2b                        ADDD 002b(BINVAL)               ADD 1 = TIMES 5
e22a 58                           ASLB                            *
e22b 49                           ROLA                            * TIMES 10
e22c db 01                        ADDB 0001(CHARAC)               ADD NEXT DIGIT
e22e 89 00                        ADCA #0                         PROPAGATE CARRY
e230 dd 2b                        STD  002b(BINVAL)               SAVE NEW ACCUMULATED LINE NUMBER
e232 9d 7c                        JSR  007c(GETNCH)               GET NEXT CHARACTER FROM BASIC
e234 20 e2                        BRA  e218(LAF6B)                LOOP- PROCESS NEXT DIGIT
                        *
                        * LET (EXBAS)
                        * EVALUATE A NON-TOKEN EXPRESSION
                        * TARGET = REPLACEMENT
e236 bd e5 db           LET       JSR  LB357                      FIND TARGET VARIABLE DESCRIPTOR
e239 9f 3b                        STX  003b(VARDES)               SAVE DESCRIPTOR ADDRESS OF 1ST EXPRESSION
e23b c6 ae                        LDB  #00ae(TOK_EQUALS)          TOKEN FOR "="
e23d bd e4 f8                     JSR  LB26F                      DO A SYNTAX CHECK FOR '='
e240 96 06                        LDA  0006(VALTYP)               * GET VARIABLE TYPE AND
e242 34 02                        PSHS A                          * SAVE ON THE STACK
e244 bd e3 df                     JSR  LB156                      EVALUATE EXPRESSION
e247 35 02                        PULS A                          * REGET VARIABLE TYPE OF 1ST EXPRESSION AND
e249 46                           RORA                            * SET CARRY IF STRING
e24a bd e3 d1                     JSR  LB148                      TYPE CHECK-TM ERROR IF VARIABLE TYPES ON
                        *                             BOTH SIDES OF EQUALS SIGN NOT THE SAME
e24d 10 27 0c 2b                  LBEQ LBC33                      GO PUT FPA0 INTO VARIABLE DESCRIPTOR IF NUMERIC
                        * MOVE A STRING WHOSE DESCRIPTOR IS LOCATED AT
                        * FPA0+2 INTO THE STRING SPACE. TRANSFER THE
                        * DESCRIPTOR ADDRESS TO THE ADDRESS IN VARDES
                        * DON'T MOVE THE STRING IF IT IS ALREADY IN THE
                        * STRING SPACE. REMOVE DESCRIPTOR FROM STRING
                        * STACK IF IT IS LAST ONE ON THE STACK
e251 9e 52              LAFA4     LDX  0050(FPA0)+2               POINT X TO DESCRIPTOR OF REPLACEMENT STRING
e253 dc 21                        LDD  0021(FRETOP)               LOAD ACCD WITH START OF STRING SPACE
e255 10 a3 02                     CMPD 2,X                        IS THE STRING IN STRING SPACE?
e258 24 11                        BCC  LAFBE                      BRANCH IF IT'S NOT IN THE STRING SPACE
e25a 9c 1b                        CMPX 001b(VARTAB)               COMPARE DESCRIPTOR ADDRESS TO START OF VARIABLES
e25c 25 0d                        BCS  LAFBE                      BRANCH IF DESCRIPTOR ADDRESS NOT IN VARIABLES
e25e e6 84              LAFB1     LDB  ,X                         GET LENGTH OF REPLACEMENT STRING
e260 bd e7 91                     JSR  LB50D                      RESERVE ACCB BYTES OF STRING SPACE
e263 9e 4d                        LDX  004d(V4D)                  GET DESCRIPTOR ADDRESS BACK
e265 bd e8 c7                     JSR  LB643                      MOVE STRING INTO STRING SPACE
e268 8e 00 56                     LDX  #0056(STRDES)              POINT X TO TEMP STRING DESCRIPTOR ADDRESS
e26b 9f 4d              LAFBE     STX  004d(V4D)                  SAVE STRING DESCRIPTOR ADDRESS IN V4D
e26d bd e8 f9                     JSR  LB675                      REMOVE STRING DESCRIPTOR IF LAST ONE
                        *              ON STRING STACK
e270 de 4d                        LDU  004d(V4D)                  POINT U TO REPLACEMENT DESCRIPTOR ADDRESS
e272 9e 3b                        LDX  003b(VARDES)               GET TARGET DESCRIPTOR ADDRESS
e274 37 26                        PULU A,B,Y                      GET LENGTH AND START OF REPLACEMENT STRING
e276 a7 84                        STA  ,X                         * SAVE STRING LENGTH AND START IN
e278 10 af 02                     STY  2,X                        * TARGET DESCRIPTOR LOCATION
e27b 39                 LAFCE     RTS

e27c 3f 52 45 44 4f     LAFCF     FCC  "?REDO"                    ?REDO MESSAGE
e281 0d 00                        FCB  CR,$00

                        LAFD6
e283 7e df 03           LAFDC     JMP  df03(LAC46)                JMP TO ERROR HANDLER
e286 96 09              LAFDF     LDA  0009(INPFLG)               = GET THE INPUT FLAG AND BRANCH
e288 27 07                        BEQ  LAFEA                      = IF 'INPUT'
e28a 9e 31                        LDX  0031(DATTXT)               * GET LINE NUMBER WHERE THE ERROR OCCURRED
e28c 9f 68                        STX  0068(CURLIN)               * AND USE IT AS THE CURRENT LINE NUMBER
e28e 7e e5 00                     JMP  LB277                      'SYNTAX ERROR'
e291 8e e2 7b           LAFEA     LDX  #e27c(LAFCF)-1             * POINT X TO '?REDO' AND PRINT
e294 bd eb e5                     JSR  LB99C                      * IT ON THE SCREEN
e297 9e 2f                        LDX  002f(TINPTR)               = GET THE SAVED ABSOLUTE ADDRESS OF
e299 9f 83                        STX  0083(CHARAD)               = INPUT POINTER AND RESTORE IT
e29b 39                           RTS
                        *
                        * INPUT
e29c c6 16              INPUT     LDB  #11*2                      'ID' ERROR
e29e 9e 68                        LDX  0068(CURLIN)               GET CURRENT LINE NUMBER
e2a0 30 01                        LEAX 1,X                        ADD ONE
e2a2 27 df                        BEQ  e283(LAFDC)                'ID' ERROR BRANCH IF DIRECT MODE
e2a4 8d 01                        BSR  LB00F                      GET SOME INPUT DATA - WAS LB002
e2a6 39                           RTS
e2a7 81 22              LB00F     CMPA #'"                        CHECK FOR PROMPT STRING DELIMITER
e2a9 26 0b                        BNE  LB01E                      BRANCH IF NO PROMPT STRING
e2ab bd e4 cd                     JSR  LB244                      PUT PROMPT STRING ON STRING STACK
e2ae c6 3b                        LDB  #';                        *
e2b0 bd e4 f8                     JSR  LB26F                      * DO A SYNTAX CHECK FOR SEMICOLON
e2b3 bd eb e8                     JSR  LB99F                      PRINT MESSAGE TO CONSOLE OUT
e2b6 8e 00 f3           LB01E     LDX  #00f3(LINBUF)              POINT TO BASIC'S LINE BUFFER
e2b9 6f 84                        CLR  ,X                         CLEAR 1ST BYTE - FLAG TO INDICATE NO DATA
                        *              IN LINE BUFFER
e2bb 8d 06                        BSR  LB02F                      INPUT A STRING TO LINE BUFFER
e2bd c6 2c                        LDB  #',                        * INSERT A COMMA AT THE END
e2bf e7 84                        STB  ,X                         * OF THE LINE INPUT BUFFER
e2c1 20 16                        BRA  LB049
                        * FILL BASIC'S LINE INPUT BUFFER CONSOLE IN
e2c3 bd eb f8           LB02F     JSR  LB9AF                      SEND A "?" TO CONSOLE OUT
e2c6 bd eb f5                     JSR  LB9AC                      SEND A 'SPACE' TO CONSOLE OUT
e2c9 bd dc 3e           LB035     JSR  dc3e(LA390)                GO READ IN A BASIC LINE
e2cc 24 05                        BCC  LB03F                      BRANCH IF ENTER KEY ENDED ENTRY
e2ce 32 64                        LEAS 4,S                        PURGE TWO RETURN ADDRESSES OFF THE STACK
e2d0 7e e0 c6                     JMP  e0c6(LAE11)                GO DO A 'STOP' IF BREAK KEY ENDED LINE ENTRY
e2d3 c6 2e              LB03F     LDB  #2*23                      'INPUT PAST END OF FILE' ERROR
e2d5 39                           RTS
                        *
                        * READ
e2d6 9e 33              READ      LDX  0033(DATPTR)               GET 'READ' START ADDRESS
e2d8 86                           FCB  0086(SKP1LD)               SKIP ONE BYTE - LDA #*$4F
e2d9 4f                 LB049     CLRA                            'INPUT' ENTRY POINT: INPUT FLAG = 0
e2da 97 09                        STA  0009(INPFLG)               SET INPUT FLAG; 0 = INPUT: <> 0 = READ
e2dc 9f 35                        STX  0035(DATTMP)               SAVE 'READ' START ADDRESS/'INPUT' BUFFER START
e2de bd e5 db           LB04E     JSR  LB357                      EVALUATE A VARIABLE
e2e1 9f 3b                        STX  003b(VARDES)               SAVE DESCRIPTOR ADDRESS
e2e3 9e 83                        LDX  0083(CHARAD)               * GET BASIC'S INPUT POINTER
e2e5 9f 2b                        STX  002b(BINVAL)               * AND SAVE IT
e2e7 9e 35                        LDX  0035(DATTMP)               GET 'READ' ADDRESS START/'INPUT' BUFFER POINTER
e2e9 a6 84                        LDA  ,X                         GET A CHARACTER FROM THE BASIC PROGRAM
e2eb 26 09                        BNE  LB069                      BRANCH IF NOT END OF LINE
e2ed 96 09                        LDA  0009(INPFLG)               * CHECK INPUT FLAG AND BRANCH
e2ef 26 51                        BNE  LB0B9                      * IF LOOKING FOR DATA (READ)
                        * NO DATA IN 'INPUT' LINE BUFFER AND/OR INPUT
                        * NOT COMING FROM SCREEN
e2f1 bd eb f8                     JSR  LB9AF                      SEND A '?' TO CONSOLE OUT
e2f4 8d cd                        BSR  e2c3(LB02F)                FILL INPUT BUFFER FROM CONSOLE IN
e2f6 9f 83              LB069     STX  0083(CHARAD)               RESET BASIC'S INPUT POINTER
e2f8 9d 7c                        JSR  007c(GETNCH)               GET A CHARACTER FROM BASIC
e2fa d6 06                        LDB  0006(VALTYP)               * CHECK VARIABLE TYPE AND
e2fc 27 23                        BEQ  LB098                      * BRANCH IF NUMERIC
                        * READ/INPUT A STRING VARIABLE
e2fe 9e 83                        LDX  0083(CHARAD)               LOAD X WITH CURRENT BASIC INPUT POINTER
e300 97 01                        STA  0001(CHARAC)               SAVE CURRENT INPUT CHARACTER
e302 81 22                        CMPA #'"                        CHECK FOR STRING DELIMITER
e304 27 0e                        BEQ  LB08B                      BRANCH IF STRING DELIMITER
e306 30 1f                        LEAX -1,X                       BACK UP POINTER
e308 4f                           CLRA                            * ZERO = END OF LINE CHARACTER
e309 97 01                        STA  0001(CHARAC)               * SAVE AS TERMINATOR
e30b bd dc 30                     JSR  dc30(LA35F)                SET UP PRINT PARAMETERS
e30e 86 3a                        LDA  #':                        END OF SUBLINE CHARACTER
e310 97 01                        STA  0001(CHARAC)               SAVE AS TERMINATOR I
e312 86 2c                        LDA  #',                        COMMA
e314 97 02              LB08B     STA  0002(ENDCHR)               SAVE AS TERMINATOR 2
e316 bd e7 a2                     JSR  LB51E                      STRIP A STRING FROM THE INPUT BUFFER
e319 bd e4 d2                     JSR  LB249                      MOVE INPUT POINTER TO END OF STRING
e31c bd e2 51                     JSR  e251(LAFA4)                PUT A STRING INTO THE STRING SPACE IF NECESSARY
e31f 20 06                        BRA  LB09E                      CHECK FOR ANOTHER DATA ITEM
                        * SAVE A NUMERIC VALUE IN A READ OR INPUT DATA ITEM
e321 bd ef 5b           LB098     JSR  LBD12                      CONVERT AN ASCII STRING TO FP NUMBER
e324 bd ee 7c                     JSR  LBC33                      PACK FPA0 AND STORE IT IN ADDRESS IN VARDES -
                        *                             INPUT OR READ DATA ITEM
e327 9d 82              LB09E     JSR  0082(GETCCH)               GET CURRENT INPUT CHARACTER
e329 27 06                        BEQ  LB0A8                      BRANCH IF END OF LINE
e32b 81 2c                        CMPA #',                        CHECK FOR A COMMA
e32d 10 26 ff 52                  LBNE LAFD6                      BAD FILE DATA' ERROR OR RETRY
e331 9e 83              LB0A8     LDX  0083(CHARAD)               * GET CURRENT INPUT
e333 9f 35                        STX  0035(DATTMP)               * POINTER (USED AS A DATA POINTER) AND SAVE IT
e335 9e 2b                        LDX  002b(BINVAL)               * RESET INPUT POINTER TO INPUT OR
e337 9f 83                        STX  0083(CHARAD)               * READ STATEMENT
e339 9d 82                        JSR  0082(GETCCH)               GET CURRENT CHARACTER FROM BASIC
e33b 27 21                        BEQ  LB0D5                      BRANCH IF END OF LINE - EXIT COMMAND
e33d bd e4 f6                     JSR  LB26D                      SYNTAX CHECK FOR COMMA
e340 20 9c                        BRA  e2de(LB04E)                GET ANOTHER INPUT OR READ ITEM
                        * SEARCH FROM ADDRESS IN X FOR
                        * 1ST OCCURENCE OF THE TOKEN FOR DATA
e342 9f 83              LB0B9     STX  0083(CHARAD)               RESET BASIC'S INPUT POINTER
e344 bd e1 95                     JSR  e195(LAEE8)                SEARCH FOR END OF CURRENT LINE OR SUBLINE
e347 30 01                        LEAX 1,X                        MOVE X ONE PAST END OF LINE
e349 4d                           TSTA                            CHECK FOR END OF LINE
e34a 26 0a                        BNE  LB0CD                      BRANCH IF END OF SUBLINE
e34c c6 06                        LDB  #2*3                       'OUT OF DATA' ERROR
e34e ee 81                        LDU  ,X++                       GET NEXT 2 CHARACTERS
e350 27 41                        BEQ  LB10A                      'OD' ERROR IF END OF PROGRAM
e352 ec 81                        LDD  ,X++                       GET BASIC LINE NUMBER AND
e354 dd 31                        STD  0031(DATTXT)               SAVE IT IN DATTXT
e356 a6 84              LB0CD     LDA  ,X                         GET AN INPUT CHARACTER
e358 81 86                        CMPA #0086(TOK_DATA)            DATA TOKEN?
e35a 26 e6                        BNE  e342(LB0B9)                NO - KEEP LOOKING
e35c 20 98                        BRA  e2f6(LB069)                YES
                        * EXIT READ AND INPUT COMMANDS
e35e 9e 35              LB0D5     LDX  0035(DATTMP)               GET DATA POINTER
e360 d6 09                        LDB  0009(INPFLG)               * CHECK INPUT FLAG
e362 10 26 fd 3a                  LBNE e0a0(LADE8)                * SAVE NEW DATA POINTER IF READ
e366 a6 84                        LDA  ,X                         = CHECK NEXT CHARACTER IN 'INPUT' BUFFER
e368 27 06                        BEQ  LB0E7                      =
e36a 8e e3 70                     LDX  #LB0E8-1                   POINT X TO '?EXTRA IGNORED'
e36d 7e eb e5                     JMP  LB99C                      PRINT THE MESSAGE
e370 39                 LB0E7     RTS

e371 3f 45 58 54 52 41  LB0E8     FCC  "?EXTRA IGNORED            " ?EXTRA IGNORED MESSAGE
20 49 47 4e 4f 52
45 44


e37f 0d 00                        FCB  CR,$00

                        * NEXT
e381 26 04              NEXT      BNE  LB0FE                      BRANCH IF ARGUMENT GIVEN
e383 9e 74                        LDX  0074(ZERO)                 X = 0: DEFAULT FOR NO ARGUMENT
e385 20 03                        BRA  LB101
e387 bd e5 db           LB0FE     JSR  LB357                      EVALUATE AN ALPHA EXPRESSION
e38a 9f 3b              LB101     STX  003b(VARDES)               SAVE VARIABLE DESCRIPTOR POINTER
e38c bd de b6                     JSR  deb6(LABF9)                GO SCAN FOR 'FOR/NEXT' DATA ON STACK
e38f 27 04                        BEQ  LB10C                      BRANCH IF DATA FOUND
e391 c6 00                        LDB  #0                         'NEXT WITHOUT FOR' ERROR (SHOULD BE CLRB)
e393 20 47              LB10A     BRA  LB153                      PROCESS ERROR
e395 1f 14              LB10C     TFR  X,S                        POINT S TO START OF 'FOR/NEXT' DATA
e397 30 03                        LEAX 3,X                        POINT X TO FP VALUE OF STEP
e399 bd ee 5d                     JSR  LBC14                      COPY A FP NUMBER FROM (X) TO FPA0
e39c a6 68                        LDA  8,S                        GET THE DIRECTION OF STEP
e39e 97 54                        STA  0054(FP0SGN)               SAVE IT AS THE SIGN OF FPA0
e3a0 9e 3b                        LDX  003b(VARDES)               POINT (X) TO INDEX VARIABLE DESCRIPTOR
e3a2 bd ec 0b                     JSR  LB9C2                      ADD (X) TO FPA0 (STEP TO INDEX)
e3a5 bd ee 7c                     JSR  LBC33                      PACK FPA0 AND STORE IT IN ADDRESS
                        *                             CONTAINED IN VARDES
e3a8 30 69                        LEAX 9,S                        POINT (X) TO TERMINAL VALUE OF INDEX
e3aa bd ee df                     JSR  LBC96                      COMPARE CURRENT INDEX VALUE TO TERMINAL VALUE OF INDEX
e3ad e0 68                        SUBB 8,S                        ACCB = 0 IF TERMINAL VALUE=CURRENT VALUE AND STEP=0 OR IF
                        *                             STEP IS POSITIVE AND CURRENT VALUE>TERMINAL VALUE OR
                        *                             STEP IS NEGATIVE AND CURRENT VALUE<TERMINAL VALUE
e3af 27 0c                        BEQ  LB134                      BRANCH IF 'FOR/NEXT' LOOP DONE
e3b1 ae 6e                        LDX  14,S                       * GET LINE NUMBER AND
e3b3 9f 68                        STX  0068(CURLIN)               * BASIC POINTER OF
e3b5 ae e8 10                     LDX  16,S                       * STATEMENT FOLLOWING THE
e3b8 9f 83                        STX  0083(CHARAD)               * PROPER FOR STATEMENT
e3ba 7e e0 3f           LB131     JMP  e03f(LAD9E)                JUMP BACK TO COMMAND INTEPR. LOOP
e3bd 32 e8 12           LB134     LEAS 18,S                       PULL THE 'FOR-NEXT' DATA OFF THE STACK
e3c0 9d 82                        JSR  0082(GETCCH)               GET CURRENT INPUT CHARACTER
e3c2 81 2c                        CMPA #',                        CHECK FOR ANOTHER ARGUMENT
e3c4 26 f4                        BNE  e3ba(LB131)                RETURN IF NONE
e3c6 9d 7c                        JSR  007c(GETNCH)               GET NEXT CHARACTER FROM BASIC
e3c8 8d bd                        BSR  e387(LB0FE)                BSR SIMULATES A CALL TO 'NEXT' FROM COMMAND LOOP


e3ca 8d 13              LB141     BSR  LB156                      EVALUATE EXPRESSION AND DO A TYPE CHECK FOR NUMERIC
e3cc 1c fe              LB143     ANDCC #$FE                       CLEAR CARRY FLAG
e3ce 7d                 LB145     FCB  $7D                        OP CODE OF TST $1A01 - SKIP TWO BYTES (DO
                        *              NOT CHANGE CARRY FLAG)
e3cf 1a 01              LB146     ORCC #1                         SET CARRY

                        * STRING TYPE MODE CHECK - IF ENTERED AT LB146 THEN VALTYP PLUS IS 'TM' ERROR
                        * NUMERIC TYPE MODE CHECK - IF ENTERED AT LB143 THEN VALTYP MINUS IS 'TM' ERROR
                        * IF ENTERED AT LB148, A TYPE CHECK IS DONE ON VALTYP
                        * IF ENTERED WITH CARRY SET, THEN 'TM' ERROR IF NUMERIC
                        * IF ENTERED WITH CARRY CLEAR, THEN 'TM' ERROR IF STRING.
e3d1 0d 06              LB148     TST  0006(VALTYP)               TEST TYPE FLAG; DO NOT CHANGE CARRY
e3d3 25 03                        BCS  LB14F                      BRANCH IF STRING
e3d5 2a 99                        BPL  e370(LB0E7)                RETURN ON PLUS
e3d7 8c                           FCB  008c(SKP2)                 SKIP 2 BYTES - 'TM' ERROR
e3d8 2b 96              LB14F     BMI  e370(LB0E7)                RETURN ON MINUS
e3da c6 18                        LDB  #12*2                      'TYPE M1SMATCH' ERROR
e3dc 7e df 03           LB153     JMP  df03(LAC46)                PROCESS ERROR
                        * EVALUATE EXPRESSION
e3df 8d 6e              LB156     BSR  LB1C6                      BACK UP INPUT POINTER
e3e1 4f                 LB158     CLRA                            END OF OPERATION PRECEDENCE FLAG
e3e2 8c                           FCB  008c(SKP2)                 SKIP TWO BYTES
e3e3 34 04              LB15A     PSHS B                          SAVE FLAG (RELATIONAL OPERATOR FLAG)
e3e5 34 02                        PSHS A                          SAVE FLAG (PRECEDENCE FLAG)
e3e7 c6 01                        LDB  #1                         *
e3e9 bd de f0                     JSR  def0(LAC33)                * SEE IF ROOM IN FREE RAM FOR (B) WORDS
e3ec bd e4 ac                     JSR  LB223                      GO EVALUATE AN EXPRESSION
e3ef 0f 3f                        CLR  003f(TRELFL)               RESET RELATIONAL OPERATOR FLAG
e3f1 9d 82              LB168     JSR  0082(GETCCH)               GET CURRENT INPUT CHARACTER
                        * CHECK FOR RELATIONAL OPERATORS
e3f3 80 ad              LB16A     SUBA #TOK_GREATER               TOKEN FOR >
e3f5 25 13                        BCS  LB181                      BRANCH IF LESS THAN RELATIONAL OPERATORS
e3f7 81 03                        CMPA #3                         *
e3f9 24 0f                        BCC  LB181                      * BRANCH IF GREATER THAN RELATIONAL OPERATORS
e3fb 81 01                        CMPA #1                         SET CARRY IF '>'
e3fd 49                           ROLA                            CARRY TO BIT 0
e3fe 98 3f                        EORA 003f(TRELFL)               * CARRY SET IF
e400 91 3f                        CMPA 003f(TRELFL)               * TRELFL = ACCA
e402 25 64                        BCS  LB1DF                      BRANCH IF SYNTAX ERROR : == << OR >>
e404 97 3f                        STA  003f(TRELFL)               BIT 0: >, BIT 1 =, BIT 2: <
e406 9d 7c                        JSR  007c(GETNCH)               GET AN INPUT CHARACTER
e408 20 e9                        BRA  e3f3(LB16A)                CHECK FOR ANOTHER RELATIONAL OPERATOR
                        *
e40a d6 3f              LB181     LDB  003f(TRELFL)               GET RELATIONAL OPERATOR FLAG
e40c 26 33                        BNE  LB1B8                      BRANCH IF RELATIONAL COMPARISON
e40e 10 24 00 6b                  LBCC LB1F4                      BRANCH IF > RELATIONAL OPERATOR
e412 8b 07                        ADDA #7                         SEVEN ARITHMETIC/LOGICAL OPERATORS
e414 24 67                        BCC  LB1F4                      BRANCH IF NOT ARITHMETIC/LOGICAL OPERATOR
e416 99 06                        ADCA 0006(VALTYP)               ADD CARRY, NUMERIC FLAG AND MODIFIED TOKEN NUMBER
e418 10 27 04 77                  LBEQ LB60F                      BRANCH IF VALTYP = FF, AND ACCA = '+' TOKEN -
                        *                             CONCATENATE TWO STRINGS
e41c 89 ff                        ADCA #-1                        RESTORE ARITHMETIC/LOGICAL OPERATOR NUMBER
e41e 34 02                        PSHS A                          * STORE OPERATOR NUMBER ON STACK; MULTIPLY IT BY 2
e420 48                           ASLA                            * THEN ADD THE STORED STACK DATA = MULTIPLY
e421 ab e0                        ADDA ,S+                        * X 3; 3 BYTE/TABLE ENTRY
e423 8e dd 08                     LDX  #dd08(LAA51)               JUMP TABLE FOR ARITHMETIC & LOGICAL OPERATORS
e426 30 86                        LEAX A,X                        POINT X TO PROPER TABLE
e428 35 02              LB19F     PULS A                          GET PRECEDENCE FLAG FROM STACK
e42a a1 84                        CMPA ,X                         COMPARE TO CURRENT OPERATOR
e42c 24 55                        BCC  LB1FA                      BRANCH IF STACK OPERATOR > CURRENT OPERATOR
e42e 8d 9c                        BSR  e3cc(LB143)                'TM' ERROR IF VARIABLE TYPE = STRING

                        * OPERATION BEING PROCESSED IS OF HIGHER PRECEDENCE THAN THE PREVIOUS OPERATION.
e430 34 02              LB1A7     PSHS A                          SAVE PRECEDENCE FLAG
e432 8d 29                        BSR  LB1D4                      PUSH OPERATOR ROUTINE ADDRESS AND FPA0 ONTO STACK
e434 9e 3d                        LDX  003d(RELPTR)               GET POINTER TO ARITHMETIC/LOGICAL TABLE ENTRY FOR
                        *                             LAST CALCULATED OPERATION
e436 35 02                        PULS A                          GET PRECEDENCE FLAG OF PREVIOUS OPERATION
e438 26 1d                        BNE  LB1CE                      BRANCH IF NOT END OF OPERATION
e43a 4d                           TSTA                            CHECK TYPE OF PRECEDENCE FLAG
e43b 10 27 00 6a                  LBEQ LB220                      BRANCH IF END OF EXPRESSION OR SUB-EXPRESSION
e43f 20 4b                        BRA  LB203                      EVALUATE AN OPERATION

e441 08 06              LB1B8     ASL  0006(VALTYP)               BIT 7 OF TYPE FLAG TO CARRY
e443 59                           ROLB                            SHIFT RELATIONAL FLAG LEFT - VALTYP TO BIT 0
e444 8d 09                        BSR  LB1C6                      MOVE THE INPUT POINTER BACK ONE
e446 8e e4 54                     LDX  #LB1CB                     POINT X TO RELATIONAL COMPARISON JUMP TABLE
e449 d7 3f                        STB  003f(TRELFL)               SAVE RELATIONAL COMPARISON DATA
e44b 0f 06                        CLR  0006(VALTYP)               SET VARIABLE TYPE TO NUMERIC
e44d 20 d9                        BRA  e428(LB19F)                PERFORM OPERATION OR SAVE ON STACK

e44f 9e 83              LB1C6     LDX  0083(CHARAD)               * GET BASIC'S INPUT POINTER AND
e451 7e e1 68                     JMP  e168(LAEBB)                * MOVE IT BACK ONE
                        * RELATIONAL COMPARISON JUMP TABLE
e454 64                 LB1CB     FCB  $64                        RELATIONAL COMPARISON FLAG
e455 e5 78              LB1CC     FDB  LB2F4                      JUMP ADDRESS

e457 a1 84              LB1CE     CMPA ,X                         COMPARE PRECEDENCE OF LAST DONE OPERATION TO
                        *         NEXT TO BE DONE OPERATION
e459 24 31                        BCC  LB203                      EVALUATE OPERATION IF LOWER PRECEDENCE
e45b 20 d3                        BRA  e430(LB1A7)                PUSH OPERATION DATA ON STACK IF HIGHER PRECEDENCE

                        * PUSH OPERATOR EVALUATION ADDRESS AND FPA0 ONTO STACK AND EVALUATE ANOTHER EXPR
e45d ec 01              LB1D4     LDD  1,X                        GET ADDRESS OF OPERATOR ROUTINE
e45f 34 06                        PSHS B,A                        SAVE IT ON THE STACK
e461 8d 08                        BSR  LB1E2                      PUSH FPA0 ONTO STACK
e463 d6 3f                        LDB  003f(TRELFL)               GET BACK RELATIONAL OPERATOR FLAG
e465 16 ff 7b                     LBRA e3e3(LB15A)                EVALUATE ANOTHER EXPRESSION
e468 7e e5 00           LB1DF     JMP  LB277                      'SYNTAX ERROR'
                        * PUSH FPA0 ONTO THE STACK. ,S   = EXPONENT
                        * 1-2,S =HIGH ORDER MANTISSA 3-4,S = LOW ORDER MANTISSA
                        * 5,S = SIGN RETURN WITH PRECEDENCE CODE IN ACCA
e46b d6 54              LB1E2     LDB  0054(FP0SGN)               GET SIGN OF FPA0 MANTISSA
e46d a6 84                        LDA  ,X                         GET PRECEDENCE CODE TO ACCA
e46f 35 20              LB1E6     PULS Y                          GET RETURN ADDRESS FROM STACK & PUT IT IN Y
e471 34 04                        PSHS B                          SAVE ACCB ON STACK
e473 d6 4f              LB1EA     LDB  004f(FP0EXP)               * PUSH FPA0 ONTO THE STACK
e475 9e 50                        LDX  0050(FPA0)                 *
e477 de 52                        LDU  0050(FPA0)+2               *
e479 34 54                        PSHS U,X,B                      *
e47b 6e a4                        JMP  ,Y                         JUMP TO ADDRESS IN Y

                        * BRANCH HERE IF NON-OPERATOR CHARACTER FOUND - USUALLY ')' OR END OF LINE
e47d 9e 74              LB1F4     LDX  0074(ZERO)                 POINT X TO DUMMY VALUE (ZERO)
e47f a6 e0                        LDA  ,S+                        GET PRECEDENCE FLAG FROM STACK
e481 27 26                        BEQ  LB220                      BRANCH IF END OF EXPRESSION
e483 81 64              LB1FA     CMPA #$64                       * CHECK FOR RELATIONAL COMPARISON FLAG
e485 27 03                        BEQ  LB201                      * AND BRANCH IF RELATIONAL COMPARISON
e487 bd e3 cc                     JSR  e3cc(LB143)                'TM' ERROR IF VARIABLE TYPE = STRING
e48a 9f 3d              LB201     STX  003d(RELPTR)               SAVE POINTER TO OPERATOR ROUTINE
e48c 35 04              LB203     PULS B                          GET RELATIONAL OPERATOR FLAG FROM STACK
e48e 81 5a                        CMPA #$5A                       CHECK FOR 'NOT' OPERATOR
e490 27 19                        BEQ  LB222                      RETURN IF 'NOT' - NO RELATIONAL COMPARISON
e492 81 7d                        CMPA #$7D                       CHECK FOR NEGATION (UNARY) FLAG
e494 27 15                        BEQ  LB222                      RETURN IF NEGATION - NO RELATIONAL COMPARISON

                        * EVALUATE AN OPERATION. EIGHT BYTES WILL BE STORED ON STACK, FIRST SIX BYTES
                        * ARE A TEMPORARY FLOATING POINT RESULT THEN THE ADDRESS OF ROUTINE WHICH
                        * WILL EVALUATE THE OPERATION. THE RTS AT END OF ROUTINE WILL VECTOR
                        * TO EVALUATING ROUTINE.
e496 54                           LSRB                            = ROTATE VALTYP BIT INTO CARRY
e497 d7 0a                        STB  000a(RELFLG)               = FLAG AND SAVE NEW RELFLG
e499 35 52                        PULS A,X,U                      * PULL A FP VALUE OFF OF THE STACK
e49b 97 5c                        STA  005c(FP1EXP)               * AND SAVE IT IN FPA1
e49d 9f 5d                        STX  005d(FPA1)                 *
e49f df 5f                        STU  005d(FPA1)+2               *
e4a1 35 04                        PULS B                          = GET MANTISSA SIGN AND
e4a3 d7 61                        STB  0061(FP1SGN)               = SAVE IT IN FPA1
e4a5 d8 54                        EORB 0054(FP0SGN)               EOR IT WITH FPA1 MANTISSA SIGN
e4a7 d7 62                        STB  0062(RESSGN)               SAVE IT IN RESULT SIGN BYTE
e4a9 d6 4f              LB220     LDB  004f(FP0EXP)               GET EXPONENT OF FPA0
e4ab 39                 LB222     RTS

e4ac bd f6 f9           LB223     JSR  XVEC15                     CALL EXTENDED BASIC ADD-IN
e4af 0f 06                        CLR  0006(VALTYP)               INITIALIZE TYPE FLAG TO NUMERIC
e4b1 9d 7c                        JSR  007c(GETNCH)               GET AN INPUT CHAR
e4b3 24 03                        BCC  LB22F                      BRANCH IF NOT NUMERIC
e4b5 7e ef 5b           LB22C     JMP  LBD12                      CONVERT ASCII STRING TO FLOATING POINT -
                        *         RETURN RESULT IN FPA0
                        * PROCESS A NON NUMERIC FIRST CHARACTER
e4b8 bd e6 26           LB22F     JSR  LB3A2                      SET CARRY IF NOT ALPHA
e4bb 24 50                        BCC  LB284                      BRANCH IF ALPHA CHARACTER
e4bd 81 2e                        CMPA #'.                        IS IT '.' (DECIMAL POINT)?
e4bf 27 f4                        BEQ  e4b5(LB22C)                CONVERT ASCII STRING TO FLOATING POINT
e4c1 81 a7                        CMPA #00a7(TOK_MINUS)           MINUS TOKEN
e4c3 27 40                        BEQ  LB27C                      YES - GO PROCESS THE MINUS OPERATOR
e4c5 81 a6                        CMPA #00a6(TOK_PLUS)            PLUS TOKEN
e4c7 27 e3                        BEQ  e4ac(LB223)                YES - GET ANOTHER CHARACTER
e4c9 81 22                        CMPA #'"                        STRING DELIMITER?
e4cb 26 0a                        BNE  LB24E                      NO
e4cd 9e 83              LB244     LDX  0083(CHARAD)               CURRENT BASIC POINTER TO X
e4cf bd e7 9c                     JSR  LB518                      SAVE STRING ON STRING STACK
e4d2 9e 64              LB249     LDX  0064(COEFPT)               * GET ADDRESS OF END OF STRING AND
e4d4 9f 83                        STX  0083(CHARAD)               * PUT BASIC'S INPUT POINTER THERE
e4d6 39                           RTS
e4d7 81 a3              LB24E     CMPA #00a3(TOK_NOT)             NOT TOKEN?
e4d9 26 0d                        BNE  LB25F                      NO
                        * PROCESS THE NOT OPERATOR
e4db 86 5a                        LDA  #$5A                       'NOT' PRECEDENCE FLAG
e4dd bd e3 e3                     JSR  e3e3(LB15A)                PROCESS OPERATION FOLLOWING 'NOT'
e4e0 bd e6 71                     JSR  INTCNV                     CONVERT FPA0 TO INTEGER IN ACCD
e4e3 43                           COMA                            * 'NOT' THE INTEGER
e4e4 53                           COMB                            *
e4e5 7e e7 78                     JMP  GIVABF                     CONVERT ACCD TO FLOATING POINT (FPA0)
e4e8 4c                 LB25F     INCA                            CHECK FOR TOKENS PRECEEDED BY $FF
e4e9 27 2e                        BEQ  LB290                      IT WAS PRECEEDED BY $FF
e4eb 8d 06              LB262     BSR  LB26A                      SYNTAX CHECK FOR A '('
e4ed bd e3 df                     JSR  e3df(LB156)                EVALUATE EXPRESSIONS WITHIN PARENTHESES AT
                        *         HIGHEST PRECEDENCE
e4f0 c6 29              LB267     LDB  #')                        SYNTAX CHECK FOR ')'
e4f2 8c                           FCB  008c(SKP2)                 SKIP 2 BYTES
e4f3 c6 28              LB26A     LDB  #'(                        SYNTAX CHECK FOR '('
e4f5 8c                           FCB  008c(SKP2)                 SKIP 2 BYTES
e4f6 c6 2c              LB26D     LDB  #',                        SYNTAX CHECK FOR COMMA
e4f8 e1 9f 00 83        LB26F     CMPB [CHARAD]                   * COMPARE ACCB TO CURRENT INPUT
e4fc 26 02                        BNE  LB277                      * CHARACTER - SYNTAX ERROR IF NO MATCH
e4fe 0e 7c                        JMP  007c(GETNCH)               GET A CHARACTER FROM BASIC
e500 c6 02              LB277     LDB  #2*1                       SYNTAX ERROR
e502 7e df 03                     JMP  df03(LAC46)                JUMP TO ERROR HANDLER

                        * PROCESS THE MINUS (UNARY) OPERATOR
e505 86 7d              LB27C     LDA  #$7D                       MINUS (UNARY) PRECEDENCE FLAG
e507 bd e3 e3                     JSR  e3e3(LB15A)                PROCESS OPERATION FOLLOWING 'UNARY' NEGATION
e50a 7e f1 32                     JMP  LBEE9                      CHANGE SIGN OF FPA0 MANTISSA

                        * EVALUATE ALPHA EXPRESSION
e50d bd e5 db           LB284     JSR  LB357                      FIND THE DESCRIPTOR ADDRESS OF A VARIABLE
e510 9f 52              LB287     STX  0050(FPA0)+2               SAVE DESCRIPTOR ADDRESS IN FPA0
e512 96 06                        LDA  0006(VALTYP)               TEST VARIABLE TYPE
e514 26 95                        BNE  e4ab(LB222)                RETURN IF STRING
e516 7e ee 5d                     JMP  LBC14                      COPY A FP NUMBER FROM (X) TO FPA0

                        * EVALUATING A SECONDARY TOKEN
e519 9d 7c              LB290     JSR  007c(GETNCH)               GET AN INPUT CHARACTER (SECONDARY TOKEN)
e51b 1f 89                        TFR  A,B                        SAVE IT IN ACCB
e51d 58                           ASLB                            X2 & BET RID OF BIT 7
e51e 9d 7c                        JSR  007c(GETNCH)               GET ANOTHER INPUT CHARACTER
e520 c1 38                        CMPB #NUM_SEC_FNS-1*            2 29 SECONDARY FUNCTIONS - 1
e522 23 03                        BLS  LB29F                      BRANCH IF COLOR BASIC TOKEN
e524 7e e5 00                     JMP  e500(LB277)                SYNTAX ERROR
e527 34 04              LB29F     PSHS B                          SAVE TOKEN OFFSET ON STACK
e529 c1 2a                        CMPB #0095(TOK_LEFT)-$80*2       CHECK FOR TOKEN WITH AN ARGUMENT
e52b 25 1e                        BCS  LB2C7                      DO SECONDARIES STRING$ OR LESS
e52d c1 30                        CMPB #0098(TOK_INKEY)-$80*      2 *
e52f 24 1c                        BCC  LB2C9                      * DO SECONDARIES $92 (INKEY$) OR >
e531 8d c0                        BSR  e4f3(LB26A)                SYNTAX CHECK FOR A '('
e533 a6 e4                        LDA  ,S                         GET TOKEN NUMBER
                        * DO SECONDARIES (LEFT$, RIGHT$, MID$)
e535 bd e3 df                     JSR  e3df(LB156)                EVALUATE FIRST STRING IN ARGUMENT
e538 8d bc                        BSR  e4f6(LB26D)                SYNTAX CHECK FOR A COMMA
e53a bd e3 cf                     JSR  e3cf(LB146)                'TM' ERROR IF NUMERIC VARiABLE
e53d 35 02                        PULS A                          GET TOKEN OFFSET FROM STACK
e53f de 52                        LDU  0050(FPA0)+2               POINT U TO STRING DESCRIPTOR
e541 34 42                        PSHS U,A                        SAVE TOKEN OFFSET AND DESCRIPTOR ADDRESS
e543 bd e9 8f                     JSR  LB70B                      EVALUATE FIRST NUMERIC ARGUMENT
e546 35 02                        PULS A                          GET TOKEN OFFSET FROM STACK
e548 34 06                        PSHS B,A                        SAVE TOKEN OFFSET AND NUMERIC ARGUMENT
e54a 8e                           FCB  $8E                        OP CODE OF LDX# - SKlP 2 BYTES
e54b 8d 9e              LB2C7     BSR  e4eb(LB262)                SYNTAX CHECK FOR A '('
e54d 35 04              LB2C9     PULS B                          GET TOKEN OFFSET
e54f be db f6                     LDX  dbee(COMVEC)+8             GET SECONDARY FUNCTION JUMP TABLE ADDRESS
e552 3a                 LB2CE     ABX                             ADD IN COMMAND OFFSET
                        *
                        * HERE IS WHERE WE BRANCH TO A SECONDARY FUNCTION
e553 ad 94                        JSR  [,X]                       GO DO AN SECONDARY FUNCTION
e555 7e e3 cc                     JMP  e3cc(LB143)                'TM' ERROR IF VARIABLE TYPE = STRING

                        * LOGICAL OPERATOR 'OR' JUMPS HERE
e558 86                 LB2D4     FCB  0086(SKP1LD)               SKIP ONE BYTE - 'OR' FLAG = $4F

                        * LOGICAL OPERATOR 'AND' JUMPS HERE
e559 4f                 LB2D5     CLRA                            AND FLAG = 0
e55a 97 03                        STA  0003(TMPLOC)               AND/OR FLAG
e55c bd e6 71                     JSR  INTCNV                     CONVERT FPA0 INTO AN INTEGER IN ACCD
e55f dd 01                        STD  0001(CHARAC)               TEMP SAVE ACCD
e561 bd ee 93                     JSR  LBC4A                      MOVE FPA1 TO FPA0
e564 bd e6 71                     JSR  INTCNV                     CONVERT FPA0 INTO AN INTEGER IN ACCD
e567 0d 03                        TST  0003(TMPLOC)               CHECK AND/OR FLAG
e569 26 06                        BNE  LB2ED                      BRANCH IF OR
e56b 94 01                        ANDA 0001(CHARAC)               * 'AND' ACCD WITH FPA0 INTEGER
e56d d4 02                        ANDB 0002(ENDCHR)               * STORED IN ENDCHR
e56f 20 04                        BRA  LB2F1                      CONVERT TO FP
e571 9a 01              LB2ED     ORA  0001(CHARAC)               * 'OR' ACCD WITH FPA0 INTEGER
e573 da 02                        ORB  0002(ENDCHR)               * STORED IN CHARAC
e575 7e e7 78           LB2F1     JMP  GIVABF                     CONVERT THE VALUE IN ACCD INTO A FP NUMBER

                        * RELATIONAL COMPARISON PROCESS HANDLER
e578 bd e3 d1           LB2F4     JSR  e3d1(LB148)                'TM' ERROR IF TYPE MISMATCH
e57b 26 10                        BNE  LB309                      BRANCH IF STRING VARIABLE
e57d 96 61                        LDA  0061(FP1SGN)               * 'PACK' THE MANTISSA
e57f 8a 7f                        ORA  #$7F                       * SIGN OF FPA1 INTO
e581 94 5d                        ANDA 005d(FPA1)                 * BIT 7 OF THE
e583 97 5d                        STA  005d(FPA1)                 * MANTISSA MS BYTE
e585 8e 00 5c                     LDX  #005c(FP1EXP)              POINT X TO FPA1
e588 bd ee df                     JSR  LBC96                      COMPARE FPA0 TO FPA1
e58b 20 36                        BRA  LB33F                      CHECK TRUTH OF RELATIONAL COMPARISON

                        * RELATIONAL COMPARISON OF STRINGS
e58d 0f 06              LB309     CLR  0006(VALTYP)               SET VARIABLE TYPE TO NUMERIC
e58f 0a 3f                        DEC  003f(TRELFL)               REMOVE STRING TYPE FLAG (BIT0=1 FOR STRINGS) FROM THE
                        *                             DESIRED RELATIONAL COMPARISON DATA
e591 bd e8 db                     JSR  LB657                      GET LENGTH AND ADDRESS OF STRING WHOSE
                        *                             DESCRIPTOR ADDRESS IS IN THE BOTTOM OF FPA0
e594 d7 56                        STB  0056(STRDES)               * SAVE LENGTH AND ADDRESS IN TEMPORARY
e596 9f 58                        STX  0056(STRDES)+2             * DESCRIPTOR (STRING B)
e598 9e 5f                        LDX  005d(FPA1)+2               = RETURN LENGTH AND ADDRESS OF STRING
e59a bd e8 dd                     JSR  LB659                      = WHOSE DESCRIPTOR ADDRESS IS STORED IN FPA1+2
e59d 96 56                        LDA  0056(STRDES)               LOAD ACCA WITH LENGTH OF STRING B
e59f 34 04                        PSHS B                          SAVE LENGTH A ON STACK
e5a1 a0 e0                        SUBA ,S+                        SUBTRACT LENGTH A FROM LENGTH B
e5a3 27 07                        BEQ  LB328                      BRANCH IF STRINGS OF EQUAL LENGTH
e5a5 86 01                        LDA  #1                         TRUE FLAG
e5a7 24 03                        BCC  LB328                      TRUE IF LENGTH B > LENGTH A
e5a9 d6 56                        LDB  0056(STRDES)               LOAD ACCB WITH LENGTH B
e5ab 40                           NEGA                            SET FLAG = FALSE (1FF)
e5ac 97 54              LB328     STA  0054(FP0SGN)               SAVE TRUE/FALSE FLAG
e5ae de 58                        LDU  0056(STRDES)+2             POINT U TO START OF STRING
e5b0 5c                           INCB                            COMPENSATE FOR THE DECB BELOW
                        * ENTER WITH ACCB CONTAINING LENGTH OF SHORTER STRING
e5b1 5a                 LB32D     DECB                            DECREMENT SHORTER STRING LENGTH
e5b2 26 04                        BNE  LB334                      BRANCH IF ALL OF STRING NOT COMPARED
e5b4 d6 54                        LDB  0054(FP0SGN)               GET TRUE/FALSE FLAB
e5b6 20 0b                        BRA  LB33F                      CHECK TRUTH OF RELATIONAL COMPARISON
e5b8 a6 80              LB334     LDA  ,X+                        GET A BYTE FROM STRING A
e5ba a1 c0                        CMPA ,U+                        COMPARE TO STRING B
e5bc 27 f3                        BEQ  e5b1(LB32D)                CHECK ANOTHER CHARACTER IF =
e5be c6 ff                        LDB  #$FF                       FALSE FLAG IF STRING A > B
e5c0 24 01                        BCC  LB33F                      BRANCH IF STRING A > STRING B
e5c2 50                           NEGB                            SET FLAG = TRUE

                        * DETERMINE TRUTH OF COMPARISON - RETURN RESULT IN FPA0
e5c3 cb 01              LB33F     ADDB #1                         CONVERT $FF,0,1 TO 0,1,2
e5c5 59                           ROLB                            NOW IT'S 1,2,4 FOR > = <
e5c6 d4 0a                        ANDB 000a(RELFLG)               'AND' THE ACTUAL COMPARISON WITH THE DESIRED -
                        COMPARISON
e5c8 27 02                        BEQ  LB348                      BRANCH IF FALSE (NO MATCHING BITS)
e5ca c6 ff                        LDB  #$FF                       TRUE FLAG
e5cc 7e ee c5           LB348     JMP  LBC7C                      CONVERT ACCB INTO FP NUMBER IN FPA0

                        * DIM
e5cf bd e4 f6           LB34B     JSR  e4f6(LB26D)                SYNTAX CHECK FOR COMMA
e5d2 c6 01              DIM       LDB  #1                         DIMENSION FLAG
e5d4 8d 08                        BSR  LB35A                      SAVE ARRAY SPACE FOR THIS VARIABLE
e5d6 9d 82                        JSR  0082(GETCCH)               GET CURRENT INPUT CHARACTER
e5d8 26 f5                        BNE  e5cf(LB34B)                KEEP DIMENSIONING IF NOT END OF LINE
e5da 39                           RTS
                        * EVALUATE A VARIABLE - RETURN X AND
                        * VARPTR POINTING TO VARIABLE DESCRIPTOR
                        * EACH VARIABLE REQUIRES 7 BYTES - THE FIRST TWO
                        * BYTES ARE THE VARIABLE NAME AND THE NEXT 5
                        * BYTES ARE THE DESCRIPTOR. IF BIT 7 OF THE
                        * FIRST BYTE OF VARlABLE NAME IS SET, THE
                        * VARIABLE IS A DEF FN VARIABLE. IF BIT 7 OF
                        * THE SECOND BYTE OF VARIABLE NAME IS SET, THE
                        * VARIABLE IS A STRING, OTHERWISE THE VARIABLE
                        * IS NUMERIC.
                        * IF THE VARIABLE IS NOT FOUND, A ZERO VARIABLE IS
                        * INSERTED INTO THE VARIABLE SPACE
e5db 5f                 LB357     CLRB                            DIMENSION FLAG = 0; DO NOT SET UP AN ARRAY
e5dc 9d 82                        JSR  0082(GETCCH)               GET CURRENT INPUT CHARACTER
e5de d7 05              LB35A     STB  0005(DIMFLG)               SAVE ARRAY FLAG
                        * ENTRY POINT FOR DEF FN VARIABLE SEARCH
e5e0 97 37              LB35C     STA  0037(VARNAM)               SAVE INPUT CHARACTER
e5e2 9d 82                        JSR  0082(GETCCH)               GET CURRENT INPUT CHARACTER
e5e4 8d 40                        BSR  LB3A2                      SET CARRY IF NOT ALPHA
e5e6 10 25 ff 16                  LBCS e500(LB277)                SYNTAX ERROR IF NOT ALPHA
e5ea 5f                           CLRB                            DEFAULT 2ND VARIABLE CHARACTER TO ZERO
e5eb d7 06                        STB  0006(VALTYP)               SET VARIABLE TYPE TO NUMERIC
e5ed 9d 7c                        JSR  007c(GETNCH)               GET ANOTHER CHARACTER FROM BASIC
e5ef 25 04                        BCS  LB371                      BRANCH IF NUMERIC (2ND CHARACTER IN
                        *                             VARIABLE MAY BE NUMERIC)
e5f1 8d 33                        BSR  LB3A2                      SET CARRY IF NOT ALPHA
e5f3 25 0a                        BCS  LB37B                      BRANCH IF NOT ALPHA
e5f5 1f 89              LB371     TFR  A,B                        SAVE 2ND CHARACTER IN ACCB
                        * READ INPUT CHARACTERS UNTIL A NON ALPHA OR
                        * NON NUMERIC IS FOUND - IGNORE ALL CHARACTERS
                        * IN VARIABLE NAME AFTER THE 1ST TWO
e5f7 9d 7c              LB373     JSR  007c(GETNCH)               GET AN INPUT CHARACTER
e5f9 25 fc                        BCS  e5f7(LB373)                BRANCH IF NUMERIC
e5fb 8d 29                        BSR  LB3A2                      SET CARRY IF NOT ALPHA
e5fd 24 f8                        BCC  e5f7(LB373)                BRANCH IF ALPHA
e5ff 81 24              LB37B     CMPA #'$                        CHECK FOR A STRING VARIABLE
e601 26 06                        BNE  LB385                      BRANCH IF IT IS NOT A STRING
e603 03 06                        COM  0006(VALTYP)               SET VARIABLE TYPE TO STRING
e605 cb 80                        ADDB #$80                       SET BIT 7 OF 2ND CHARACTER (STRING)
e607 9d 7c                        JSR  007c(GETNCH)               GET AN INPUT CHARACTER
e609 d7 38              LB385     STB  0037(VARNAM)+1             SAVE 2ND CHARACTER IN VARNAM+1
e60b 9a 08                        ORA  0008(ARYDIS)               OR IN THE ARRAY DISABLE FLAG - IF = $80,
                        *              DON'T SEARCH FOR VARIABLES IN THE ARRAYS
e60d 80 28                        SUBA #'(                        IS THIS AN ARRAY VARIABLE?
e60f 10 27 00 75                  LBEQ LB404                      BRANCH IF IT IS
e613 0f 08                        CLR  0008(ARYDIS)               RESET THE ARRAY DISABLE FLAG
e615 9e 1b                        LDX  001b(VARTAB)               POINT X TO THE START OF VARIABLES
e617 dc 37                        LDD  0037(VARNAM)               GET VARIABLE IN QUESTION
e619 9c 1d              LB395     CMPX 001d(ARYTAB)               COMPARE X TO THE END OF VARIABLES
e61b 27 12                        BEQ  LB3AB                      BRANCH IF END OF VARIABLES
e61d 10 a3 81                     CMPD ,X++                       * COMPARE VARIABLE IN QUESTION TO CURRENT
e620 27 3e                        BEQ  LB3DC                      * VARIABLE AND BRANCH IF MATCH
e622 30 05                        LEAX 5,X                        = MOVE POINTER TO NEXT VARIABLE AND
e624 20 f3                        BRA  e619(LB395)                = KEEP LOOKING

                        * SET CARRY IF NOT UPPER CASE ALPHA
e626 81 41              LB3A2     CMPA #'A                        * CARRY SET IF < 'A'
e628 25 04                        BCS  LB3AA                      *
e62a 80 5b                        SUBA #'Z+1                      =
                        *         SUBA #-('Z+1)       = CARRY CLEAR IF <= 'Z'
e62c 80 a5                        FCB  $80,$A5
e62e 39                 LB3AA     RTS
                        * PUT A NEW VARIABLE IN TABLE OF VARIABLES
e62f 8e 00 74           LB3AB     LDX  #0074(ZERO)                POINT X TO ZERO LOCATION
e632 ee e4                        LDU  ,S                         GET CURRENT RETURN ADDRESS
e634 11 83 e5 10                  CMPU #e510(LB287)               DID WE COME FROM 'EVALUATE ALPHA EXPR'?
e638 27 28                        BEQ  LB3DE                      YES - RETURN A ZERO VALUE
e63a dc 1f                        LDD  001f(ARYEND)               * GET END OF ARRAYS ADDRESS AND
e63c dd 43                        STD  0043(V43)                  * SAVE IT AT V43
e63e c3 00 07                     ADDD #7                         = ADD 7 TO END OF ARRAYS (EACH
e641 dd 41                        STD  0041(V41)                  = VARIABLE = 7 BYTES) AND SAVE AT V41
e643 9e 1d                        LDX  001d(ARYTAB)               * GET END OF VARIABLES AND SAVE AT V47
e645 9f 47                        STX  0047(V47)                  *
e647 bd de db                     JSR  dedb(LAC1E)                MAKE A SEVEN BYTE SLOT FOR NEW VARIABLE AT
                        *         TOP  OF VARIABLES
e64a 9e 41                        LDX  0041(V41)                  = GET NEW END OF ARRAYS AND SAVE IT
e64c 9f 1f                        STX  001f(ARYEND)               =
e64e 9e 45                        LDX  0045(V45)                  * GET NEW END OF VARIABLES AND SAVE IT
e650 9f 1d                        STX  001d(ARYTAB)               *
e652 9e 47                        LDX  0047(V47)                  GET OLD END OF VARIABLES
e654 dc 37                        LDD  0037(VARNAM)               GET NEW VARIABLE NAME
e656 ed 81                        STD  ,X++                       SAVE VARIABLE NAME
e658 4f                           CLRA                            * ZERO OUT THE FP VALUE OF THE NUMERIC
e659 5f                           CLRB                            * VARIABLE OR THE LENGTH AND ADDRESS
e65a ed 84                        STD  ,X                         * OF A STRING VARIABLE
e65c ed 02                        STD  2,X                        *
e65e a7 04                        STA  4,X                        *
e660 9f 39              LB3DC     STX  0039(VARPTR)               STORE ADDRESS OF VARIABLE VALUE
e662 39                 LB3DE     RTS
                        *
e663 90 80 00 00 00     LB3DF     FCB  $90,$80,$00,$00            ,$00 * FLOATING POINT -32768
                        *                             SMALLEST SIGNED TWO BYTE INTEGER
                        *
e668 9d 7c              LB3E4     JSR  007c(GETNCH)               GET AN INPUT CHARACTER FROM BASIC
e66a bd e3 ca           LB3E6     JSR  e3ca(LB141)                GO EVALUATE NUMERIC EXPRESSION
e66d 96 54              LB3E9     LDA  0054(FP0SGN)               GET FPA0 MANTISSA SIGN
e66f 2b 5d                        BMI  LB44A                      'FC' ERROR IF NEGATIVE NUMBER


e671 bd e3 cc           INTCNV    JSR  e3cc(LB143)                'TM' ERROR IF STRING VARIABLE
e674 96 4f                        LDA  004f(FP0EXP)               GET FPA0 EXPONENT
e676 81 90                        CMPA #$90                       * COMPARE TO 32768 - LARGEST INTEGER EXPONENT AND
e678 25 08                        BCS  LB3FE                      * BRANCH IF FPA0 < 32768
e67a 8e e6 63                     LDX  #e663(LB3DF)               POINT X TO FP VALUE OF -32768
e67d bd ee df                     JSR  LBC96                      COMPARE -32768 TO FPA0
e680 26 4c                        BNE  LB44A                      'FC' ERROR IF NOT =
e682 bd ef 11           LB3FE     JSR  LBCC8                      CONVERT FPA0 TO A TWO BYTE INTEGER
e685 dc 52                        LDD  0050(FPA0)+2               GET THE INTEGER
e687 39                           RTS
                        * EVALUATE AN ARRAY VARIABLE
e688 dc 05              LB404     LDD  0005(DIMFLG)               GET ARRAY FLAG AND VARIABLE TYPE
e68a 34 06                        PSHS B,A                        SAVE THEM ON STACK
e68c 12                           NOP                             DEAD SPACE CAUSED BY 1.2 REVISION
e68d 5f                           CLRB                            RESET DIMENSION COUNTER
e68e 9e 37              LB40A     LDX  0037(VARNAM)               GET VARIABLE NAME
e690 34 14                        PSHS X,B                        SAVE VARIABLE NAME AND DIMENSION COUNTER
e692 8d d4                        BSR  e668(LB3E4)                EVALUATE EXPRESSION (DIMENSlON LENGTH)
e694 35 34                        PULS B,X,Y                      PULL OFF VARIABLE NAME, DIMENSlON COUNTER,
                        *                             ARRAY FLAG
e696 9f 37                        STX  0037(VARNAM)               SAVE VARIABLE NAME AND VARIABLE TYPE
e698 de 52                        LDU  0050(FPA0)+2               GET DIMENSION LENGTH
e69a 34 60                        PSHS U,Y                        SAVE DIMENSION LENGTH, ARRAY FLAG, VARIABLE TYPE
e69c 5c                           INCB                            INCREASE DIMENSION COUNTER
e69d 9d 82                        JSR  0082(GETCCH)               GET CURRENT INPUT CHARACTER
e69f 81 2c                        CMPA #',                        CHECK FOR ANOTHER DIMENSION
e6a1 27 eb                        BEQ  e68e(LB40A)                BRANCH IF MORE
e6a3 d7 03                        STB  0003(TMPLOC)               SAVE DIMENSION COUNTER
e6a5 bd e4 f0                     JSR  e4f0(LB267)                SYNTAX CHECK FOR A ')'
e6a8 35 06                        PULS A,B                        * RESTORE VARIABLE TYPE AND ARRAY
e6aa dd 05                        STD  0005(DIMFLG)               * FLAG - LEAVE DIMENSION LENGTH ON STACK
e6ac 9e 1d                        LDX  001d(ARYTAB)               GET START OF ARRAYS
e6ae 9c 1f              LB42A     CMPX 001f(ARYEND)               COMPARE TO END OF ARRAYS
e6b0 27 21                        BEQ  LB44F                      BRANCH IF NO MATCH FOUND
e6b2 dc 37                        LDD  0037(VARNAM)               GET VARIABLE IN QUESTION
e6b4 10 a3 84                     CMPD ,X                         COMPARE TO CURRENT VARIABLE
e6b7 27 06                        BEQ  LB43B                      BRANCH IF =
e6b9 ec 02                        LDD  2,X                        GET OFFSET TO NEXT ARRAY VARIABLE
e6bb 30 8b                        LEAX D,X                        ADD TO CURRENT POINTER
e6bd 20 ef                        BRA  e6ae(LB42A)                KEEP SEARCHING
e6bf c6 12              LB43B     LDB  #2*9                       'REDIMENSIONED ARRAY' ERROR
e6c1 96 05                        LDA  0005(DIMFLG)               * TEST ARRAY FLAG - IF <>0 YOU ARE TRYING
e6c3 26 0b                        BNE  LB44C                      * TO REDIMENSION AN ARRAY
e6c5 d6 03                        LDB  0003(TMPLOC)               GET NUMBER OF DIMENSIONS IN ARRAY
e6c7 e1 04                        CMPB 4,X                        COMPARE TO THIS ARRAYS DIMENSIONS
e6c9 27 59                        BEQ  LB4A0                      BRANCH IF =
e6cb c6 10              LB447     LDB  #8*2                       'BAD SUBSCRIPT'
e6cd 8c                           FCB  008c(SKP2)                 SKIP TWO BYTES
e6ce c6 08              LB44A     LDB  #4*2                       'ILLEGAL FUNCTION CALL'
e6d0 7e df 03           LB44C     JMP  df03(LAC46)                JUMP TO ERROR SERVICING ROUTINE

                        * INSERT A NEW ARRAY INTO ARRAY VARIABLES
                        * EACH SET OF ARRAY VARIABLES IS PRECEEDED BY A DE-
                        * SCRIPTOR BLOCK COMPOSED OF 5+2*N BYTES WHERE N IS THE
                        * NUMBER OF DIMENSIONS IN THE ARRAY. THE BLOCK IS DEFINED
                        * AS FOLLOWS: BYTES 0,1:VARIABLE'S NAME; 2,3:TOTAL LENGTH
                        * OF ARRAY ITEMS AND DESCRIPTOR BLOCK; 4:NUMBER OF DIMEN-
                        * ISIONS; 5,6:LENGTH OF DIMENSION 1; 7,8:LENGTH OF DIMEN-
                        * SION 2; 4+N,5+N:LENGTH OF DIMENSION N.

e6d3 cc 00 05           LB44F     LDD  #5                         * 5 BYTES/ARRAY ENTRY SAVE AT COEFPT
e6d6 dd 64                        STD  0064(COEFPT)               *
e6d8 dc 37                        LDD  0037(VARNAM)               = GET NAME OF ARRAY AND SAVE IN
e6da ed 84                        STD  ,X                         = FIRST 2 BYTES OF DESCRIPTOR
e6dc d6 03                        LDB  0003(TMPLOC)               GET NUMBER OF DIMENSIONS AND SAVE IN
e6de e7 04                        STB  4,X                        * 5TH BYTE OF DESCRIPTOR
e6e0 bd de f0                     JSR  def0(LAC33)                CHECK FOR ROOM FOR DESCRIPTOR IN FREE RAM
e6e3 9f 41                        STX  0041(V41)                  TEMPORARILY SAVE DESCRIPTOR ADDRESS
e6e5 c6 0b              LB461     LDB  #11                        * DEFAULT DIMENSION VALUE:X(10)
e6e7 4f                           CLRA                            *
e6e8 0d 05                        TST  0005(DIMFLG)               = CHECK ARRAY FLAG AND BRANCH IF
e6ea 27 05                        BEQ  LB46D                      = NOT DIMENSIONING AN ARRAY
e6ec 35 06                        PULS A,B                        GET DIMENSION LENGTH
e6ee c3 00 01                     ADDD #1                         ADD ONE (X(0) HAS A LENGTH OF ONE)
e6f1 ed 05              LB46D     STD  5,X                        SAVE LENGTH OF ARRAY DIMENSION
e6f3 8d 5d                        BSR  LB4CE                      MULTIPLY ACCUM ARRAY SIZE NUMBER LENGTH
                        *                             OF NEW DIMENSION
e6f5 dd 64                        STD  0064(COEFPT)               TEMP STORE NEW CURRENT ACCUMULATED ARRAY SIZE
e6f7 30 02                        LEAX 2,X                        BUMP POINTER UP TWO
e6f9 0a 03                        DEC  0003(TMPLOC)               * DECREMENT DIMENSION COUNTER AND BRANCH IF
e6fb 26 e8                        BNE  e6e5(LB461)                * NOT DONE WITH ALL DIMENSIONS
e6fd 9f 0f                        STX  000f(TEMPTR)               SAVE ADDRESS OF (END OF ARRAY DESCRIPTOR - 5)
e6ff d3 0f                        ADDD 000f(TEMPTR)               ADD TOTAL SIZE OF NEW ARRAY
e701 10 25 f7 fc                  LBCS df01(LAC44)                'OM' ERROR IF > $FFFF
e705 1f 01                        TFR  D,X                        SAVE END OF ARRAY IN X
e707 bd de f4                     JSR  def4(LAC37)                MAKE SURE THERE IS ENOUGH FREE RAM FOR ARRAY
e70a 83 00 35                     SUBD #003a(STKBUF)-5            SUBTRACT OUT THE (STACK BUFFER - 5)
e70d dd 1f                        STD  001f(ARYEND)               SAVE NEW END OF ARRAYS
e70f 4f                           CLRA                            ZERO = TERMINATOR BYTE
e710 30 1f              LB48C     LEAX -1,X                       * STORE TWO TERMINATOR BYTES AT
e712 a7 05                        STA  5,X                        * THE END OF THE ARRAY DESCRIPTOR
e714 9c 0f                        CMPX 000f(TEMPTR)               *
e716 26 f8                        BNE  e710(LB48C)                *
e718 9e 41                        LDX  0041(V41)                  GET ADDRESS OF START OF DESCRIPTOR
e71a 96 1f                        LDA  001f(ARYEND)               GET MSB OF END OF ARRAYS; LSB ALREADY THERE
e71c 93 41                        SUBD 0041(V41)                  SUBTRACT OUT ADDRESS OF START OF DESCRIPTOR
e71e ed 02                        STD  2,X                        SAVE LENGTH OF (ARRAY AND DESCRIPTOR)
e720 96 05                        LDA  0005(DIMFLG)               * GET ARRAY FLAG AND BRANCH
e722 26 2d                        BNE  LB4CD                      * BACK IF DIMENSIONING
                        * CALCULATE POINTER TO CORRECT ELEMENT
e724 e6 04              LB4A0     LDB  4,X                        GET THE NUMBER OF DIMENSIONS
e726 d7 03                        STB  0003(TMPLOC)               TEMPORARILY SAVE
e728 4f                           CLRA                            * INITIALIZE POINTER
e729 5f                           CLRB                            * TO ZERO
e72a dd 64              LB4A6     STD  0064(COEFPT)               SAVE ACCUMULATED POINTER
e72c 35 06                        PULS A,B                        * PULL DIMENSION ARGUMENT OFF THE
e72e dd 52                        STD  0050(FPA0)+2               * STACK AND SAVE IT
e730 10 a3 05                     CMPD 5,X                        COMPARE TO STORED 'DIM' ARGUMENT
e733 24 3a                        BCC  LB4EB                      'BS' ERROR IF > = "DIM" ARGUMENT
e735 de 64                        LDU  0064(COEFPT)               * GET ACCUMULATED POINTER AND
e737 27 04                        BEQ  LB4B9                      * BRANCH IF 1ST DIMENSION
e739 8d 17                        BSR  LB4CE                      = MULTIPLY ACCUMULATED POINTER AND DIMENSION
e73b d3 52                        ADDD 0050(FPA0)+2               = LENGTH AND ADD TO CURRENT ARGUMENT
e73d 30 02              LB4B9     LEAX 2,X                        MOVE POINTER TO NEXT DIMENSION
e73f 0a 03                        DEC  0003(TMPLOC)               * DECREMENT DIMENSION COUNTER AND
e741 26 e7                        BNE  e72a(LB4A6)                * BRANCH IF ANY DIMENSIONS LEFT
                        * MULTIPLY ACCD BY 5 - 5 BYTES/ARRAY VALUE
e743 ed e3                        STD  ,--S
e745 58                           ASLB
e746 49                           ROLA                            TIMES 2
e747 58                           ASLB
e748 49                           ROLA                            TIMES 4
e749 e3 e1                        ADDD ,S++                       TIMES 5
e74b 30 8b                        LEAX D,X                        ADD OFFSET TO START OF ARRAY
e74d 30 05                        LEAX 5,X                        ADJUST POINTER FOR SIZE OF DESCRIPTOR
e74f 9f 39                        STX  0039(VARPTR)               SAVE POINTER TO ARRAY VALUE
e751 39                 LB4CD     RTS
                        * MULTIPLY 2 BYTE NUMBER IN 5,X BY THE 2 BYTE NUMBER
                        * IN COEFPT. RETURN RESULT IN ACCD, BS ERROR IF > $FFFF
e752 86 10              LB4CE     LDA  #16                        16 SHIFTS TO DO A MULTIPLY
e754 97 45                        STA  0045(V45)                  SHIFT COUNTER
e756 ec 05                        LDD  5,X                        * GET SIZE OF DIMENSION
e758 dd 17                        STD  0017(BOTSTK)               * AND SAVE IT
e75a 4f                           CLRA                            * ZERO
e75b 5f                           CLRB                            * ACCD
e75c 58                 LB4D8     ASLB                            = SHIFT ACCB LEFT
e75d 49                           ROLA                            = ONE BIT
e75e 25 0f                        BCS  LB4EB                      BS' ERROR IF CARRY
e760 08 65                        ASL  0064(COEFPT)+1             * SHIFT MULTIPLICAND LEFT ONE
e762 09 64                        ROL  0064(COEFPT)               * BIT - ADD MULTIPLIER TO ACCUMULATOR
e764 24 04                        BCC  LB4E6                      * IF CARRY <> 0
e766 d3 17                        ADDD 0017(BOTSTK)               ADD MULTIPLIER TO ACCD
e768 25 05                        BCS  LB4EB                      BS' ERROR IF CARRY (>$FFFF)
e76a 0a 45              LB4E6     DEC  0045(V45)                  * DECREMENT SHIFT COUNTER
e76c 26 ee                        BNE  e75c(LB4D8)                * IF NOT DONE
e76e 39                           RTS
e76f 7e e6 cb           LB4EB     JMP  e6cb(LB447)                BS' ERROR
                        *
                        * MEM
                        * THIS IS NOT A TRUE INDICATOR OF FREE MEMORY BECAUSE
                        * BASIC REQUIRES A STKBUF SIZE BUFFER FOR THE STACK
                        * FOR WHICH MEM DOES NOT ALLOW.
                        *
e772 1f 40              MEM       TFR  S,D                        PUT STACK POINTER INTO ACCD
e774 93 1f                        SUBD 001f(ARYEND)               SUBTRACT END OF ARRAYS
e776 21                           FCB  0021(SKP1)                 SKIP ONE BYTE
                        *CONVERT THE VALUE IN ACCB INTO A FP NUMBER IN FPA0
e777 4f                 LB4F3     CLRA                            CLEAR MS BYTE OF ACCD
                        * CONVERT THE VALUE IN ACCD INTO A FLOATING POINT NUMBER IN FPA0
e778 0f 06              GIVABF    CLR  0006(VALTYP)               SET VARIABLE TYPE TO NUMERIC
e77a dd 50                        STD  0050(FPA0)                 SAVE ACCD IN TOP OF FACA
e77c c6 90                        LDB  #$90                       EXPONENT REQUIRED IF THE TOP TWO BYTES
                        *         OF   FPA0 ARE TO BE TREATED AS AN INTEGER IN FPA0
e77e 7e ee cb                     JMP  LBC82                      CONVERT THE REST OF FPA0 TO AN INTEGER

                        * STR$
e781 bd e3 cc           STR       JSR  e3cc(LB143)                TM' ERROR IF STRING VARIABLE
e784 ce 01 f0                     LDU  #01ee(STRBUF)+2            *CONVERT FP NUMBER TO ASCII STRING IN
e787 bd f0 25                     JSR  LBDDC                      *THE STRING BUFFER
e78a 32 62                        LEAS 2,S                        PURGE THE RETURN ADDRESS FROM THE STACK
e78c 8e 01 ef                     LDX  #01ee(STRBUF)+1            *POINT X TO STRING BUFFER AND SAVE
e78f 20 0b                        BRA  LB518                      *THE STRING IN THE STRING SPACE
                        * RESERVE ACCB BYTES OF STRING SPACE. RETURN START
                        * ADDRESS IN (X) AND FRESPC
e791 9f 4d              LB50D     STX  004d(V4D)                  SAVE X IN V4D
e793 8d 5c              LB50F     BSR  LB56D                      RESERVE ACCB BYTES IN STRING SPACE
e795 9f 58              LB511     STX  0056(STRDES)+2             SAVE NEW STRING ADDRESS
e797 d7 56                        STB  0056(STRDES)               SAVE LENGTH OF RESERVED BLOCK
e799 39                           RTS
e79a 30 1f              LB516     LEAX -1,X                       MOVE POINTER BACK ONE
                        * SCAN A LINE FROM (X) UNTIL AN END OF LINE FLAG (ZERO) OR
                        * EITHER OF THE TWO TERMINATORS STORED IN CHARAC OR ENDCHR IS MATCHED.
                        * THE RESULTING STRING IS STORED IN THE STRING SPACE
                        * ONLY IF THE START OF THE STRING IS <= STRBUF+2
e79c 86 22              LB518     LDA  #'"                        * INITIALIZE
e79e 97 01                        STA  0001(CHARAC)               * TERMINATORS
e7a0 97 02              LB51A     STA  0002(ENDCHR)               * TO "
e7a2 30 01              LB51E     LEAX 1,X                        MOVE POINTER UP ONE
e7a4 9f 62                        STX  0062(RESSGN)               TEMPORARILY SAVE START OF STRING
e7a6 9f 58                        STX  0056(STRDES)+2             SAVE START OF STRING IN TEMP DESCRIPTOR
e7a8 c6 ff                        LDB  #-1                        INITIALIZE CHARACTER COUNTER TO - 1
e7aa 5c                 LB526     INCB                            INCREMENT CHARACTER COUNTER
e7ab a6 80                        LDA  ,X+                        GET CHARACTER
e7ad 27 0c                        BEQ  LB537                      BRANCH IF END OF LINE
e7af 91 01                        CMPA 0001(CHARAC)               * CHECK FOR TERMINATORS
e7b1 27 04                        BEQ  LB533                      * IN CHARAC AND ENDCHR
e7b3 91 02                        CMPA 0002(ENDCHR)               * DON'T MOVE POINTER BACK
e7b5 26 f3                        BNE  e7aa(LB526)                * ONE IF TERMINATOR IS "MATCHED"
e7b7 81 22              LB533     CMPA #'"                        = COMPARE CHARACTER TO STRING DELIMITER
e7b9 27 02                        BEQ  LB539                      = & DON'T MOVE POINTER BACK IF SO
e7bb 30 1f              LB537     LEAX -1,X                       MOVE POINTER BACK ONE
e7bd 9f 64              LB539     STX  0064(COEFPT)               SAVE END OF STRING ADDRESS
e7bf d7 56                        STB  0056(STRDES)               SAVE STRING LENGTH IN TEMP DESCRIPTOR
e7c1 de 62                        LDU  0062(RESSGN)               GET INITlAL STRING START
e7c3 11 83 01 f0                  CMPU #01ee(STRBUF)+2            COMPARE TO START OF STRING BUFFER
e7c7 22 07              LB543     BHI  LB54C                      BRANCH IF > START OF STRING BUFFER
e7c9 8d c6                        BSR  e791(LB50D)                GO RESERVE SPACE FOR THE STRING
e7cb 9e 62                        LDX  0062(RESSGN)               POINT X TO THE BEGINNING OF THE STRING
e7cd bd e8 c9                     JSR  LB645                      MOVE (B) BYTES FROM (X) TO
                        *                             [FRESPC] - MOVE STRING DATA
                        * PUT DIRECT PAGE STRING DESCRIPTOR BUFFER DATA
                        * ON THE STRING STACK. SET VARIABLE TYPE TO STRING
e7d0 9e 0b              LB54C     LDX  000b(TEMPPT)               GET NEXT AVAILABLE STRING STACK DESCRIPTOR
e7d2 8c 00 f1                     CMPX #00f1(LINHDR)              COMPARE TO TOP OF STRING DESCRIPTOR STACK - WAS #CFNBUF
e7d5 26 05                        BNE  LB558                      FORMULA O.K.
e7d7 c6 1e                        LDB  #15*2                      STRING FORMULA TOO COMPLEX' ERROR
e7d9 7e df 03           LB555     JMP  df03(LAC46)                JUMP TO ERROR SERVICING ROUTINE
e7dc 96 56              LB558     LDA  0056(STRDES)               * GET LENGTH OF STRING AND SAVE IT
                        *         STA  ,X             * IN BYTE 0 OF DESCRIPTOR
e7de a7 00                        FCB  $A7,$00
e7e0 dc 58                        LDD  0056(STRDES)+2             = GET START ADDRESS OF ACTUAL STRING
e7e2 ed 02                        STD  2,X                        = AND SAVE IN BYTES 2,3 OF DESCRIPTOR
e7e4 86 ff                        LDA  #$FF                       * VARIABLE TYPE = STRING
e7e6 97 06                        STA  0006(VALTYP)               * SAVE IN VARIABLE TYPE FLAG
e7e8 9f 0d                        STX  000d(LASTPT)               = SAVE START OF DESCRIPTOR
e7ea 9f 52                        STX  0050(FPA0)+2               = ADDRESS IN LASTPT AND FPA0
e7ec 30 05                        LEAX 5,X                        5 BYTES/STRING DESCRIPTOR
e7ee 9f 0b                        STX  000b(TEMPPT)               NEXT AVAILABLE STRING VARIABLE DESCRIPTOR
e7f0 39                           RTS
                        * RESERVE ACCB BYTES IN STRING STORAGE SPACE
                        * RETURN WITH THE STARTING ADDRESS OF THE
                        * RESERVED STRING SPACE IN (X) AND FRESPC
e7f1 0f 07              LB56D     CLR  0007(GARBFL)               CLEAR STRING REORGANIZATION FLAG
e7f3 4f                 LB56F     CLRA                            * PUSH THE LENGTH OF THE
e7f4 34 06                        PSHS B,A                        * STRING ONTO THE STACK
e7f6 dc 23                        LDD  0023(STRTAB)               GET START OF STRING VARIABLES
e7f8 a3 e0                        SUBD ,S+                        SUBTRACT STRING LENGTH
e7fa 10 93 21                     CMPD 0021(FRETOP)               COMPARE TO START OF STRING STORAGE
e7fd 25 0a                        BCS  LB585                      IF BELOW START, THEN REORGANIZE
e7ff dd 23                        STD  0023(STRTAB)               SAVE NEW START OF STRING VARIABLES
e801 9e 23                        LDX  0023(STRTAB)               GET START OF STRING VARIABLES
e803 30 01                        LEAX 1,X                        ADD ONE
e805 9f 25                        STX  0025(FRESPC)               SAVE START ADDRESS OF NEWLY RESERVED SPACE
e807 35 84                        PULS B,PC                       RESTORE NUMBER OF BYTES RESERVED AND RETURN
e809 c6 1a              LB585     LDB  #2*13                      OUT OF STRING SPACE' ERROR
e80b 03 07                        COM  0007(GARBFL)               TOGGLE REORGANIZATiON FLAG
e80d 27 ca                        BEQ  e7d9(LB555)                ERROR IF FRESHLY REORGANIZED
e80f 8d 04                        BSR  LB591                      GO REORGANIZE STRING SPACE
e811 35 04                        PULS B                          GET BACK THE NUMBER OF BYTES TO RESERVE
e813 20 de                        BRA  e7f3(LB56F)                TRY TO RESERVE ACCB BYTES AGAIN
                        * REORGANIZE THE STRING SPACE
e815 9e 27              LB591     LDX  0027(MEMSIZ)               GET THE TOP OF STRING SPACE
e817 9f 23              LB593     STX  0023(STRTAB)               SAVE TOP OF UNORGANIZED STRING SPACE
e819 4f                           CLRA                            * ZERO OUT ACCD
e81a 5f                           CLRB                            * AND RESET VARIABLE
e81b dd 4b                        STD  004b(V4B)                  * POINTER TO 0
e81d 9e 21                        LDX  0021(FRETOP)               POINT X TO START OF STRING SPACE
e81f 9f 47                        STX  0047(V47)                  SAVE POINTER IN V47
e821 8e 00 c9                     LDX  #00c9(STRSTK)              POINT X TO START OF STRING DESCRIPTOR STACK
e824 9c 0b              LB5A0     CMPX 000b(TEMPPT)               COMPARE TO ADDRESS OF NEXT AVAILABLE DESCRIPTOR
e826 27 04                        BEQ  LB5A8                      BRANCH IF TOP OF STRING STACK
e828 8d 32                        BSR  LB5D8                      CHECK FOR STRING IN UNORGANIZED STRING SPACE
e82a 20 f8                        BRA  e824(LB5A0)                KEEP CHECKING
e82c 9e 1b              LB5A8     LDX  001b(VARTAB)               GET THE END OF BASIC PROGRAM
e82e 9c 1d              LB5AA     CMPX 001d(ARYTAB)               COMPARE TO END OF VARIABLES
e830 27 04                        BEQ  LB5B2                      BRANCH IF AT TOP OF VARIABLES
e832 8d 22                        BSR  LB5D2                      CHECK FOR STRING IN UNORGANIZED STRING SPACE
e834 20 f8                        BRA  e82e(LB5AA)                KEEP CHECKING VARIABLES
e836 9f 41              LB5B2     STX  0041(V41)                  SAVE ADDRESS OF THE END OF VARIABLES
e838 9e 41              LB5B4     LDX  0041(V41)                  GET CURRENT ARRAY POINTER
e83a 9c 1f              LB5B6     CMPX 001f(ARYEND)               COMPARE TO THE END OF ARRAYS
e83c 27 35                        BEQ  LB5EF                      BRANCH IF AT END OF ARRAYS
e83e ec 02                        LDD  2,X                        GET LENGTH OF ARRAY AND DESCRIPTOR
e840 d3 41                        ADDD 0041(V41)                  * ADD TO CURRENT ARRAY POINTER
e842 dd 41                        STD  0041(V41)                  * AND SAVE IT
e844 a6 01                        LDA  1,X                        GET 1ST CHARACTER OF VARIABLE NAME
e846 2a f0                        BPL  e838(LB5B4)                BRANCH IF NUMERIC ARRAY
e848 e6 04                        LDB  4,X                        GET THE NUMBER OF DIMENSIONS IN THIS ARRAY
e84a 58                           ASLB                            MULTIPLY BY 2
e84b cb 05                        ADDB #5                         ADD FIVE BYTES (VARIABLE NAME, ARRAY
                        *                             LENGTH, NUMBER DIMENSIONS)
e84d 3a                           ABX                             X NOW POINTS TO START OF ARRAY ELEMENTS
e84e 9c 41              LB5CA     CMPX 0041(V41)                  AT END OF THIS ARRAY?
e850 27 e8                        BEQ  e83a(LB5B6)                YES - CHECK FOR ANOTHER
e852 8d 08                        BSR  LB5D8                      CHECK FOR STRING LOCATED IN
                        *                             UNORGANIZED STRING SPACE
e854 20 f8                        BRA  e84e(LB5CA)                KEEP CHECKING ELEMENTS IN THIS ARRAY
e856 a6 01              LB5D2     LDA  1,X                        GET F1RST BYTE OF VARIABLE NAME
e858 30 02                        LEAX 2,X                        MOVE POINTER TO DESCRIPTOR
e85a 2a 14                        BPL  LB5EC                      BRANCH IF VARIABLE IS NUMERIC
                        * SEARCH FOR STRING - ENTER WITH X POINTING TO
                        * THE STRING DESCRIPTOR. IF STRING IS STORED
                        * BETWEEN V47 AND STRTAB, SAVE DESCRIPTOR POINTER
                        * IN V4B AND RESET V47 TO STRING ADDRESS
e85c e6 84              LB5D8     LDB  ,X                         GET THE LENGTH OF THE STRING
e85e 27 10                        BEQ  LB5EC                      BRANCH IF NULL - NO STRING
e860 ec 02                        LDD  2,X                        GET STARTING ADDRESS OF THE STRING
e862 10 93 23                     CMPD 0023(STRTAB)               COMPARE TO THE START OF STRING VARIABLES
e865 22 09                        BHI  LB5EC                      BRANCH IF THIS STRING IS STORED IN
                        *              THE STRING VARIABLES
e867 10 93 47                     CMPD 0047(V47)                  COMPARE TO START OF STRING SPACE
e86a 23 04                        BLS  LB5EC                      BRANCH IF NOT STORED IN THE STRING SPACE
e86c 9f 4b                        STX  004b(V4B)                  SAVE VARIABLE POINTER IF STORED IN STRING SPACE
e86e dd 47                        STD  0047(V47)                  SAVE STRING STARTING ADDRESS
e870 30 05              LB5EC     LEAX 5,X                        MOVE TO NEXT VARIABLE DESCRIPTOR
e872 39                 LB5EE     RTS
e873 9e 4b              LB5EF     LDX  004b(V4B)                  GET ADDRESS OF THE DESCRIPTOR FOR THE
                        *              STRING WHICH IS STORED IN THE HIGHEST RAM ADDRESS IN
                        *              THE UNORGANIZED STRING SPACE
e875 27 fb                        BEQ  e872(LB5EE)                BRANCH IF NONE FOUND AND REORGANIZATION DONE
e877 4f                           CLRA                            CLEAR MS BYTE OF LENGTH
e878 e6 84                        LDB  ,X                         GET LENGTH OF STRING
e87a 5a                           DECB                            SUBTRACT ONE
e87b d3 47                        ADDD 0047(V47)                  ADD LENGTH OF STRING TO ITS STARTING ADDRESS
e87d dd 43                        STD  0043(V43)                  SAVE AS MOVE STARTING ADDRESS
e87f 9e 23                        LDX  0023(STRTAB)               POINT X TO THE START OF ORGANIZED STRING VARIABLES
e881 9f 41                        STX  0041(V41)                  SAVE AS MOVE ENDING ADDRESS
e883 bd de dd                     JSR  dedd(LAC20)                MOVE STRING FROM CURRENT POSITION TO THE
                        *              TOP OF UNORGANIZED STRING SPACE
e886 9e 4b                        LDX  004b(V4B)                  POINT X TO STRING DESCRIPTOR
e888 dc 45                        LDD  0045(V45)                  * GET NEW STARTING ADDRESS OF STRING AND
e88a ed 02                        STD  2,X                        * SAVE IT IN DESCRIPTOR
e88c 9e 45                        LDX  0045(V45)                  GET NEW TOP OF UNORGANIZED STRING SPACE
e88e 30 1f                        LEAX -1,X                       MOVE POINTER BACK ONE
e890 7e e8 17                     JMP  e817(LB593)                JUMP BACK AND REORGANIZE SOME MORE


e893 dc 52              LB60F     LDD  0050(FPA0)+2               * GET DESCRIPTOR ADDRESS OF STRING A
e895 34 06                        PSHS B,A                        * AND SAVE IT ON THE STACK
e897 bd e4 ac                     JSR  e4ac(LB223)                GET DESCRIPTOR ADDRESS OF STRING B
e89a bd e3 cf                     JSR  e3cf(LB146)                TM' ERROR IF NUMERIC VARIABLE
e89d 35 10                        PULS X                          * POINT X TO STRING A DESCRIPTOR
e89f 9f 62                        STX  0062(RESSGN)               * ADDRESS AND SAVE IT IN RESSGN
e8a1 e6 84                        LDB  ,X                         GET LENGTH OF STRING A
e8a3 9e 52                        LDX  0050(FPA0)+2               POINT X TO DESCRIPTOR OF STRING B
e8a5 eb 84                        ADDB ,X                         ADD LENGTH OF STRING B TO STR1NG A
e8a7 24 05                        BCC  LB62A                      BRANCH IF LENGTH < 256
e8a9 c6 1c                        LDB  #2*14                      STRING TOO LONG' ERROR IF LENGTH > 255
e8ab 7e df 03                     JMP  df03(LAC46)                JUMP TO ERROR SERVICING ROUTINE
e8ae bd e7 91           LB62A     JSR  e791(LB50D)                RESERVE ROOM IN STRING SPACE FOR NEW STRING
e8b1 9e 62                        LDX  0062(RESSGN)               GET DESCRIPTOR ADDRESS OF STRING A
e8b3 e6 84                        LDB  ,X                         GET LENGTH OF STRING A
e8b5 8d 10                        BSR  LB643                      MOVE STRING A INTO RESERVED BUFFER IN STRING SPACE
e8b7 9e 4d                        LDX  004d(V4D)                  GET DESCRIPTOR ADDRESS OF STRING B
e8b9 8d 22                        BSR  LB659                      GET LENGTH AND ADDRESS OF STRING B
e8bb 8d 0c                        BSR  LB645                      MOVE STRING B INTO REST OF RESERVED BUFFER
e8bd 9e 62                        LDX  0062(RESSGN)               POINT X TO DESCRIPTOR OF STRING A
e8bf 8d 1c                        BSR  LB659                      DELETE STRING A IF LAST STRING ON STRING STACK
e8c1 bd e7 d0                     JSR  e7d0(LB54C)                PUT STRING DESCRIPTOR ON THE STRING STACK
e8c4 7e e3 f1                     JMP  e3f1(LB168)                BRANCH BACK TO EXPRESSION EVALUATION

                        * MOVE (B) BYTES FROM 2,X TO FRESPC
e8c7 ae 02              LB643     LDX  2,X                        POINT X TO SOURCE ADDRESS
e8c9 de 25              LB645     LDU  0025(FRESPC)               POINT U TO DESTINATION ADDRESS
e8cb 5c                           INCB                            COMPENSATION FOR THE DECB BELOW
e8cc 20 04                        BRA  LB64E                      GO MOVE THE BYTES
                        * MOVE B BYTES FROM (X) TO (U)
e8ce a6 80              LB64A     LDA  ,X+                        * GET A SOURCE BYTE AND MOVE IT
e8d0 a7 c0                        STA  ,U+                        * TO THE DESTINATION
e8d2 5a                 LB64E     DECB                            DECREMENT BYTE COUNTER
e8d3 26 f9                        BNE  e8ce(LB64A)                BRANCH IF ALL BYTES NOT MOVED
e8d5 df 25                        STU  0025(FRESPC)               SAVE ENDING ADDRESS IN FRESPC
e8d7 39                           RTS
                        * RETURN LENGTH (ACCB) AND ADDRESS (X) OF
                        * STRING WHOSE DESCRIPTOR IS IN FPA0+2
                        * DELETE THE STRING IF IT IS THE LAST ONE
                        * PUT ON THE STRING STACK. REMOVE STRING FROM STRING
                        * SPACE IF IT IS AT THE BOTTOM OF STRING VARIABLES.
e8d8 bd e3 cf           LB654     JSR  e3cf(LB146)                TM' ERROR IF VARIABLE TYPE = NUMERIC
e8db 9e 52              LB657     LDX  0050(FPA0)+2               GET ADDRESS OF SELECTED STRING DESCRIPTOR
e8dd e6 84              LB659     LDB  ,X                         GET LENGTH OF STRING
e8df 8d 18                        BSR  LB675                      * CHECK TO SEE IF THIS STRING DESCRIPTOR WAS
e8e1 26 13                        BNE  LB672                      * THE LAST ONE PUT ON THE STRING STACK AND
                        *                             * BRANCH IF NOT
e8e3 ae 07                        LDX  5+2,X                      GET START ADDRESS OF STRING JUST REMOVED
e8e5 30 1f                        LEAX -1,X                       MOVE POINTER DOWN ONE
e8e7 9c 23                        CMPX 0023(STRTAB)               COMPARE TO START OF STRING VARIABLES
e8e9 26 08                        BNE  LB66F                      BRANCH IF THIS STRING IS NOT AT THE BOTTOM
                        *                             OF STRING VARIABLES
e8eb 34 04                        PSHS B                          SAVE LENGTH; ACCA WAS CLEARED
e8ed d3 23                        ADDD 0023(STRTAB)               * ADD THE LENGTH OF THE JUST REMOVED STRING
e8ef dd 23                        STD  0023(STRTAB)               * TO THE START OF STRING VARIABLES - THIS WILL
                        *                             * REMOVE THE STRING FROM THE STRING SPACE
e8f1 35 04                        PULS B                          RESTORE LENGTH
e8f3 30 01              LB66F     LEAX 1,X                        ADD ONE TO POINTER
e8f5 39                           RTS
e8f6 ae 02              LB672     LDX  2,X                        *POINT X TO ADDRESS OF STRING NOT
e8f8 39                           RTS                             *ON THE STRING STACK
                        * REMOVE STRING FROM STRING STACK. ENTER WITH X
                        * POINTING TO A STRING DESCRIPTOR - DELETE THE
                        * STRING FROM STACK IF IT IS ON TOP OF THE
                        * STACK. IF THE STRING IS DELETED, SET THE ZERO FLAG
e8f9 9c 0d              LB675     CMPX 000d(LASTPT)               *COMPARE TO LAST USED DESCRIPTOR ADDRESS
e8fb 26 07                        BNE  LB680                      *ON THE STRING STACK, RETURN IF DESCRIPTOR
                        *                             *ADDRESS NOT ON THE STRING STACK
e8fd 9f 0b                        STX  000b(TEMPPT)               SAVE LAST USED DESCRIPTOR AS NEXT AVAILABLE
e8ff 30 1b                        LEAX -5,X                       * MOVE LAST USED DESCRIPTOR BACK 5 BYTES
e901 9f 0d                        STX  000d(LASTPT)               * AND SAVE AS THE LAST USED DESCRIPTOR ADDR
e903 4f                           CLRA                            SET ZERO FLAG
e904 39                 LB680     RTS

                        * LEN
e905 8d 03              LEN       BSR  LB686                      POINT X TO PROPER STRING AND GET LENGTH
e907 7e e7 77           LB683     JMP  e777(LB4F3)                CONVERT ACCB TO FP NUMBER IN FPA0
                        * POINT X TO STRING ADDRESS LOAD LENGTH INTO
                        * ACCB. ENTER WITH THE STRING DESCRIPTOR IN
                        * BOTTOM TWO BYTES OF FPA0
e90a 8d cc              LB686     BSR  e8d8(LB654)                GET LENGTH AND ADDRESS OF STRING
e90c 0f 06                        CLR  0006(VALTYP)               SET VARIABLE TYPE TO NUMERIC
e90e 5d                           TSTB                            SET FLAGS ACCORDING TO LENGTH
e90f 39                           RTS

                        * CHR$
e910 bd e9 92           CHR       JSR  LB70E                      CONVERT FPA0 TO AN INTEGER IN ACCD
e913 c6 01              LB68F     LDB  #1                         * RESERVE ONE BYTE IN
e915 bd e7 f1                     JSR  e7f1(LB56D)                * THE STRING SPACE
e918 96 53                        LDA  0050(FPA0)+3               GET ASCII STRING VALUE
e91a bd e7 95                     JSR  e795(LB511)                SAVE RESERVED STRING DESCRIPTOR IN TEMP DESCRIPTOR
e91d a7 84                        STA  ,X                         SAVE THE STRING (IT'S ONLY ONE BYTE)
e91f 32 62              LB69B     LEAS 2,S                        PURGE THE RETURN ADDRESS OFF OF THE STACK
e921 7e e7 d0           LB69D     JMP  e7d0(LB54C)                PUT TEMP DESCRIPTOR DATA ONTO STRING STACK


e924 8d 02              ASC       BSR  LB6A4                      PUT 1ST CHARACTER OF STRING INTO ACCB
e926 20 df                        BRA  e907(LB683)                CONVERT ACCB INTO FP NUMBER IN FPA0
e928 8d e0              LB6A4     BSR  e90a(LB686)                POINT X TO STRING DESCRIPTOR
e92a 27 5e                        BEQ  LB706                      FC' ERROR IF NULL STRING
e92c e6 84                        LDB  ,X                         GET FIRST BYTE OF STRING
e92e 39                           RTS


e92f 8d 48              LEFT      BSR  LB6F5                      GET ARGUMENTS FROM STACK
e931 4f                 LB6AD     CLRA                            CLEAR STRING POINTER OFFSET - OFFSET = 0 FOR LEFT$
e932 e1 84              LB6AE     CMPB ,X                         * COMPARE LENGTH PARAMETER TO LENGTH OF
e934 23 03                        BLS  LB6B5                      * STRING AND BRANCH IF LENGTH OF STRING
                        *                             >= LENGTH PARAMETER
e936 e6 84                        LDB  ,X                         USE LENGTH OF STRING OTHERWISE
e938 4f                           CLRA                            CLEAR STRING POINTER OFFSET (0 FOR LEFT$)
e939 34 06              LB6B5     PSHS B,A                        PUSH PARAMETERS ONTO STACK
e93b bd e7 93                     JSR  e793(LB50F)                RESERVE ACCB BYTES IN THE STRING SPACE
e93e 9e 4d                        LDX  004d(V4D)                  POINT X TO STRING DESCRIPTOR
e940 8d 9b                        BSR  e8dd(LB659)                GET ADDRESS OF OLD STRING (X=ADDRESS)
e942 35 04                        PULS B                          * PULL STRING POINTER OFFSET OFF OF THE STACK
e944 3a                           ABX                             * AND ADD IT TO STRING ADDRESS
e945 35 04                        PULS B                          PULL LENGTH PARAMETER OFF OF THE STACK
e947 bd e8 c9                     JSR  e8c9(LB645)                MOVE ACCB BYTES FROM (X) TO [FRESPC]
e94a 20 d5                        BRA  e921(LB69D)                PUT TEMP STRING DESCRIPTOR ONTO THE STRING STACK

                        * RIGHT$
e94c 8d 2b              RIGHT     BSR  LB6F5                      GET ARGUMENTS FROM STACK
e94e a0 84                        SUBA ,X                         ACCA=LENGTH PARAMETER - LENGTH OF OLD STRING
e950 40                           NEGA                            NOW ACCA = LENGTH OF OLD STRING
e951 20 df                        BRA  e932(LB6AE)                PUT NEW STRING IN THE STRING SPACE

                        * MID$
e953 c6 ff              MID       LDB  #$FF                       * GET DEFAULT VALUE OF LENGTH AND
e955 d7 53                        STB  0050(FPA0)+3               * SAVE IT IN FPA0
e957 9d 82                        JSR  0082(GETCCH)               GET CURRENT CHARACTER FROM BASIC
e959 81 29                        CMPA #')                        ARGUMENT DELIMITER?
e95b 27 05                        BEQ  LB6DE                      YES - NO LENGTH PARAMETER GIVEN
e95d bd e4 f6                     JSR  e4f6(LB26D)                SYNTAX CHECK FOR COMMA
e960 8d 2d                        BSR  LB70B                      EVALUATE NUMERIC EXPRESSION (LENGTH)
e962 8d 15              LB6DE     BSR  LB6F5                      GET ARGUMENTS FROM STACK
e964 27 24                        BEQ  LB706                      FC' ERROR IF NULL STRING
e966 5f                           CLRB                            CLEAR LENGTH COUNTER (DEFAULT VALUE)
e967 4a                           DECA                            *SUOTRACT ONE FROM POSITION PARAMETER (THESE
e968 a1 84                        CMPA ,X                         *ROUTINES EXPECT 1ST POSITION TO BE ZERO, NOT ONE)
                        *                             *AND COMPARE IT TO LENGTH OF OLD STRING
e96a 24 cd                        BCC  e939(LB6B5)                IF POSITION > LENGTH OF OLD STRING, THEN NEW
                        *                             STRING WILL BE A NULL STRING
e96c 1f 89                        TFR  A,B                        SAVE ABSOLUTE POSITION PARAMETER IN ACCB
e96e e0 84                        SUBB ,X                         ACCB=POSITION-LENGTH OF OLD STRING
e970 50                           NEGB                            NOW ACCB=LENGTH OF OLDSTRING-POSITION
e971 d1 53                        CMPB 0050(FPA0)+3               *IF THE AMOUNT OF OLD STRING TO THE RIGHT OF
e973 23 c4                        BLS  e939(LB6B5)                *POSITION IS <= THE LENGTH PARAMETER, BRANCH AND
                        * USE ALL OF THE STRING TO THE RIGHT OF THE POSITION
                        * INSTEAD OF THE LENGTH PARAMETER
e975 d6 53                        LDB  0050(FPA0)+3               GET LENGTH OF NEW STRING
e977 20 c0                        BRA  e939(LB6B5)                PUT NEW STRING IN STRING SPACE
                        * DO A SYNTAX CHECK FOR ")", THEN PULL THE PREVIOUSLY CALCULATED NUMERIC
                        * ARGUMENT (ACCD) AND STRING ARGUMENT DESCRIPTOR ADDR OFF OF THE STACK
e979 bd e4 f0           LB6F5     JSR  e4f0(LB267)                SYNTAX CHECK FOR A ")"
e97c ee e4                        LDU  ,S                         LOAD THE RETURN ADDRESS INTO U REGISTER
e97e ae 65                        LDX  5,S                        * GET ADDRESS OF STRING AND
e980 9f 4d                        STX  004d(V4D)                  * SAVE IT IN V4D
e982 a6 64                        LDA  4,S                        = PUT LENGTH OF STRING IN
e984 e6 64                        LDB  4,S                        = BOTH ACCA AND ACCB
e986 32 67                        LEAS 7,S                        REMOVE DESCRIPTOR AND RETURN ADDRESS FROM STACK
e988 1f 35                        TFR  U,PC                       JUMP TO ADDRESS IN U REGISTER
e98a 7e e6 ce           LB706     JMP  e6ce(LB44A)                ILLEGAL FUNCTION CALL'
                        * EVALUATE AN EXPRESSION - RETURN AN INTEGER IN
                        * ACCB - 'FC' ERROR IF EXPRESSION > 255
e98d 9d 7c              LB709     JSR  007c(GETNCH)               GET NEXT BASIC INPUT CHARACTER
e98f bd e3 ca           LB70B     JSR  e3ca(LB141)                EVALUATE A NUMERIC EXPRESSION
e992 bd e6 6d           LB70E     JSR  e66d(LB3E9)                CONVERT FPA0 TO INTEGER IN ACCD
e995 4d                           TSTA                            TEST MS BYTE OF INTEGER
e996 26 f2                        BNE  e98a(LB706)                FC' ERROR IF EXPRESSION > 255
e998 0e 82                        JMP  0082(GETCCH)               GET CURRENT INPUT CHARACTER FROM BASIC

                        * VAL
e99a bd e9 0a           VAL       JSR  e90a(LB686)                POINT X TO STRING ADDRESS
e99d 10 27 02 e1                  LBEQ LBA39                      IF NULL STRING SET FPA0
e9a1 de 83                        LDU  0083(CHARAD)               SAVE INPUT POINTER IN REGISTER U
e9a3 9f 83                        STX  0083(CHARAD)               POINT INPUT POINTER TO ADDRESS OF STRING
e9a5 3a                           ABX  MOVE POINTER TO             END OF STRING TERMINATOR
e9a6 a6 84                        LDA  ,X                         GET LAST BYTE OF STRING
e9a8 34 52                        PSHS U,X,A                      SAVE INPUT POINTER, STRING TERMINATOR
                        *         ADDRESS AND CHARACTER
e9aa 6f 84                        CLR  ,X                         CLEAR STRING TERMINATOR : FOR ASCII - FP CONVERSION
e9ac 9d 82                        JSR  0082(GETCCH)               GET CURRENT CHARACTER FROM BASIC
e9ae bd ef 5b                     JSR  LBD12                      CONVERT AN ASCII STRING TO FLOATING POINT
e9b1 35 52                        PULS A,X,U                      RESTORE CHARACTERS AND POINTERS
e9b3 a7 84                        STA  ,X                         REPLACE STRING TERMINATOR
e9b5 df 83                        STU  0083(CHARAD)               RESTORE INPUT CHARACTER
e9b7 39                           RTS

e9b8 8d 07              LB734     BSR  LB73D                      * EVALUATE AN EXPRESSION, RETURN
e9ba 9f 2b                        STX  002b(BINVAL)               * THE VALUE IN X; STORE IT IN BINVAL
e9bc bd e4 f6           LB738     JSR  e4f6(LB26D)                SYNTAX CHECK FOR A COMMA
e9bf 20 ce                        BRA  e98f(LB70B)                EVALUATE EXPRESSION IN RANGE 0 <= X < 256
                        * EVALUATE EXPRESSION : RETURN INTEGER PORTION IN X - 'FC' ERROR IF

e9c1 bd e3 ca           LB73D     JSR  e3ca(LB141)                EVALUATE NUMERIC EXPRESSION
e9c4 96 54              LB740     LDA  0054(FP0SGN)               GET SIGN OF FPA0 MANTISSA
e9c6 2b c2                        BMI  e98a(LB706)                ILLEGAL FUNCTION CALL' IF NEGATIVE
e9c8 96 4f                        LDA  004f(FP0EXP)               GET EXPONENT OF FPA0
e9ca 81 90                        CMPA #$90                       COMPARE TO LARGEST POSITIVE INTEGER
e9cc 22 bc                        BHI  e98a(LB706)                ILLEGAL FUNCTION CALL' IF TOO LARGE
e9ce bd ef 11                     JSR  LBCC8                      SHIFT BINARY POINT TO EXTREME RIGHT OF FPA0
e9d1 9e 52                        LDX  0050(FPA0)+2               LOAD X WITH LOWER TWO BYTES OF FPA0
e9d3 39                           RTS

                        * PEEK
e9d4 8d ee              PEEK      BSR  e9c4(LB740)                CONVERT FPA0 TO INTEGER IN REGISTER X
e9d6 e6 84                        LDB  ,X                         GET THE VALUE BEING 'PEEK'ED
e9d8 7e e7 77                     JMP  e777(LB4F3)                CONVERT ACCB INTO A FP NUMBER

                        * POKE
e9db 8d db              POKE      BSR  e9b8(LB734)                EVALUATE 2 EXPRESSIONS
e9dd 9e 2b                        LDX  002b(BINVAL)               GET THE ADDRESS TO BE 'POKE'ED
e9df e7 84                        STB  ,X                         STORE THE DATA IN THAT ADDRESS
e9e1 39                           RTS


                        * LIST
e9e2 34 01              LIST      PSHS CC                         SAVE ZERO FLAG ON STACK
e9e4 bd e2 14                     JSR  e214(LAF67)                CONVERT DECIMAL LINE NUMBER TO BINARY
e9e7 bd df a2                     JSR  dfa2(LAD01)                * FIND RAM ADDRESS OF THAT LINE NUMBER AND
e9ea 9f 66                        STX  0066(LSTTXT)               * SAVE IT IN LSTTXT
e9ec 35 01                        PULS CC                         GET ZERO FLAG FROM STACK
e9ee 27 12                        BEQ  LB784                      BRANCH IF END OF LINE
e9f0 9d 82                        JSR  0082(GETCCH)               GET CURRENT CHARACTER FROM BASIC
e9f2 27 13                        BEQ  LB789                      BRANCH IF END OF LINE
e9f4 81 a7                        CMPA #00a7(TOK_MINUS)           MINUS TOKEN (IS IT A RANGE OF LINE NUMBERS?)
e9f6 26 09                        BNE  LB783                      NO - RETURN
e9f8 9d 7c                        JSR  007c(GETNCH)               GET NEXT CHARACTER FROM BASIC
e9fa 27 06                        BEQ  LB784                      BRANCH IF END OF LINE
e9fc bd e2 14                     JSR  e214(LAF67)                GET ENDING LINE NUMBER
e9ff 27 06                        BEQ  LB789                      BRANCH IF LEGAL LINE NUMBER
ea01 39                 LB783 RTS
                        * LIST THE ENTIRE PROGRAM
ea02 ce ff ff           LB784     LDU  #$FFFF                     * SET THE DEFAULT ENDING LINE NUMBER
ea05 df 2b                        STU  002b(BINVAL)               * TO $FFFF
ea07 32 62              LB789     LEAS 2,S                        PURGE RETURN ADDRESS FROM THE STACK
ea09 9e 66                        LDX  0066(LSTTXT)               POINT X TO STARTING LINE ADDRESS
ea0b bd eb a9           LB78D     JSR  LB95C                      MOVE CURSOR TO START OF A NEW LINE
ea0e bd dc 97                     JSR  dc97(LA549)                CHECK FOR A BREAK OR PAUSE
ea11 ec 84                        LDD  ,X                         GET ADDRESS OF NEXT BASIC LINE
ea13 26 03                        BNE  LB79F                      BRANCH IF NOT END OF PROGRAM
                        LB797
ea15 7e df 22                     JMP  df22(LAC73)                RETURN TO BASIC'S MAIN INPUT LOOP
ea18 9f 66              LB79F     STX  0066(LSTTXT)               SAVE NEW STARTING LINE ADDRESS
ea1a ec 02                        LDD  2,X                        * GET THE LINE NUMBER OF THIS LINE AND
ea1c 10 93 2b                     CMPD 002b(BINVAL)               * COMPARE IT TO ENDING LINE NUMBER
ea1f 22 f4                        BHI  LB797                      EXIT IF LINE NUMBER > ENDING LINE NUMBER
ea21 bd f0 15                     JSR  LBDCC                      PRINT THE NUMBER IN ACCD ON SCREEN IN DECIMAL
ea24 bd eb f5                     JSR  LB9AC                      SEND A SPACE TO CONSOLE OUT
ea27 9e 66                        LDX  0066(LSTTXT)               GET RAM ADDRESS OF THIS LINE
ea29 8d 10                        BSR  LB7C2                      UNCRUNCH A LINE
ea2b ae 9f 00 66                  LDX  [LSTTXT]                   POINT X TO START OF NEXT LINE
ea2f ce 00 f4                     LDU  #00f3(LINBUF)+1            POINT U TO BUFFER FULL OF UNCRUNCHED LINE
ea32 a6 c0              LB7B9     LDA  ,U+                        GET A BYTE FROM THE BUFFER
ea34 27 d5                        BEQ  ea0b(LB78D)                BRANCH IF END OF BUFFER
ea36 bd eb fa                     JSR  LB9B1                      SEND CHARACTER TO CONSOLE OUT
ea39 20 f7                        BRA  ea32(LB7B9)                GET ANOTHER CHARACTER

                        * UNCRUNCH A LINE INTO BASIC'S LINE INPUT BUFFER
ea3b 30 04              LB7C2     LEAX 4,X                        MOVE POINTER PAST ADDRESS OF NEXT LINE AND LINE NUMBER
ea3d 10 8e 00 f4                  LDY  #00f3(LINBUF)+1            UNCRUNCH LINE INTO LINE INPUT BUFFER
ea41 a6 80              LB7CB     LDA  ,X+                        GET A CHARACTER
ea43 27 51                        BEQ  LB820                      BRANCH IF END OF LINE
ea45 2b 15                        BMI  LB7E6                      BRANCH IF IT'S A TOKEN
ea47 81 3a                        CMPA #':                        CHECK FOR END OF SUB LINE
ea49 26 0d                        BNE  LB7E2                      BRNCH IF NOT END OF SUB LINE
ea4b e6 84                        LDB  ,X                         GET CHARACTER FOLLOWING COLON
ea4d c1 84                        CMPB #0084(TOK_ELSE)            TOKEN FOR ELSE?
ea4f 27 f0                        BEQ  ea41(LB7CB)                YES - DON'T PUT IT IN BUFFER
ea51 c1 83                        CMPB #0083(TOK_SNGL_Q)          TOKEN FOR REMARK?
ea53 27 ec                        BEQ  ea41(LB7CB)                YES - DON'T PUT IT IN BUFFER
ea55 8c                           FCB  008c(SKP2)                 SKIP TWO BYTES
ea56 86 21              LB7E0     LDA  #'!                        EXCLAMATION POINT
ea58 8d 30              LB7E2     BSR  LB814                      PUT CHARACTER IN BUFFER
ea5a 20 e5                        BRA  ea41(LB7CB)                GET ANOTHER CHARACTER

ea5c ce db e4           LB7E6     LDU  #dbee(COMVEC)-10           FIRST DO COMMANDS
ea5f 81 ff                        CMPA #$FF                       CHECK FOR SECONDARY TOKEN
ea61 26 04                        BNE  LB7F1                      BRANCH IF NON SECONDARY TOKEN
ea63 a6 80                        LDA  ,X+                        GET SECONDARY TOKEN
ea65 33 45                        LEAU 5,U                        BUMP IT UP TO SECONDARY FUNCTIONS
ea67 84 7f              LB7F1     ANDA #$7F                       MASK OFF BIT 7 OF TOKEN
ea69 33 4a              LB7F3     LEAU 10,U                       MOVE TO NEXT COMMAND TABLE
ea6b 6d c4                        TST  ,U                         IS THIS TABLE ENABLED?
ea6d 27 e7                        BEQ  ea56(LB7E0)                NO - ILLEGAL TOKEN
ea6f a0 c4                        SUBA ,U                         SUBTRACT THE NUMBER OF TOKENS FROM THE CURRENT TOKEN NUMBER
ea71 2a f6                        BPL  ea69(LB7F3)                BRANCH IF TOKEN NOT IN THIS TABLE
ea73 ab c4                        ADDA ,U                         RESTORE TOKEN NUMBER RELATIVE TO THIS TABLE
ea75 ee 41                        LDU  1,U                        POINT U TO COMMAND DICTIONARY TABLE
ea77 4a                 LB801     DECA                            DECREMENT TOKEN NUMBER
ea78 2b 06                        BMI  LB80A                      BRANCH IF THIS IS THE CORRECT TOKEN
                        * SKIP THROUGH DICTIONARY TABLE TO START OF NEXT TOKEN
ea7a 6d c0              LB804     TST  ,U+                        GRAB A BYTE
ea7c 2a fc                        BPL  ea7a(LB804)                BRANCH IF BIT 7 NOT SET
ea7e 20 f7                        BRA  ea77(LB801)                GO SEE IF THIS IS THE CORRECT TOKEN
ea80 a6 c4              LB80A     LDA  ,U                         GET A CHARACTER FROM DICTIONARY TABLE
ea82 8d 06                        BSR  LB814                      PUT CHARACTER IN BUFFER
ea84 6d c0                        TST  ,U+                        CHECK FOR START OF NEXT TOKEN
ea86 2a f8                        BPL  ea80(LB80A)                BRANCH IF NOT DONE WITH THIS TOKEN
ea88 20 b7                        BRA  ea41(LB7CB)                GO GET ANOTHER CHARACTER
ea8a 10 8c 01 ed        LB814     CMPY #00f3(LINBUF)+LBUFMX       TEST FOR END OF LINE INPUT BUFFER
ea8e 24 06                        BCC  LB820                      BRANCH IF AT END OF BUFFER
ea90 84 7f                        ANDA #$7F                       MASK OFF BIT 7
ea92 a7 a0                        STA  ,Y+                        * SAVE CHARACTER IN BUFFER AND
ea94 6f a4                        CLR  ,Y                         * CLEAR NEXT CHARACTER SLOT IN BUFFER
ea96 39                 LB820     RTS
                        *
                        * CRUNCH THE LINE THAT THE INPUT POINTER IS
                        * POINTING TO INTO THE LINE INPUT BUFFER
                        * RETURN LENGTH OF CRUNCHED LINE IN ACCD
                        *
ea97 9e 83              LB821     LDX  0083(CHARAD)               GET BASIC'S INPUT POINTER ADDRESS
ea99 ce 00 f3                     LDU  #00f3(LINBUF)              POINT X TO LINE INPUT BUFFER
ea9c 0f 43              LB829     CLR  0043(V43)                  CLEAR ILLEGAL TOKEN FLAG
ea9e 0f 44                        CLR  0044(V44)                  CLEAR DATA FLAG
eaa0 a6 80              LB82D     LDA  ,X+                        GET INPUT CHAR
eaa2 27 21                        BEQ  LB852                      BRANCH IF END OF LINE
eaa4 0d 43                        TST  0043(V43)                  * CHECK ILLEGAL TOKEN FLAG & BRANCH IF NOT
eaa6 27 0f                        BEQ  LB844                      * PROCESSING AN ILLEGAL TOKEN
eaa8 bd e6 26                     JSR  e626(LB3A2)                SET CARRY IF NOT UPPER CASE ALPHA
eaab 24 18                        BCC  LB852                      BRANCH IF UPPER CASE ALPHA
eaad 81 30                        CMPA #'0                        * DON'T CRUNCH ASCII NUMERIC CHARACTERS
eaaf 25 04                        BLO  LB842                      * BRANCH IF NOT NUMERIC
eab1 81 39                        CMPA #'9                        *
eab3 23 10                        BLS  LB852                      * BRANCH IF NUMERIC
                        * END UP HERE IF NOT UPPER CASE ALPHA OR NUMERIC
eab5 0f 43              LB842     CLR  0043(V43)                  CLEAR ILLEGAL TOKEN FLAG
eab7 81 20              LB844     CMPA #0020(SPACE)               SPACE?
eab9 27 0a                        BEQ  LB852                      DO NOT REMOVE SPACES
eabb 97 42                        STA  0042(V42)                  SAVE INPUT CHARACTER AS SCAN DELIMITER
eabd 81 22                        CMPA #'"                        CHECK FOR STRING DELIMITER
eabf 27 38                        BEQ  LB886                      BRANCH IF STRING
eac1 0d 44                        TST  0044(V44)                  * CHECK DATA FLAG AND BRANCH IF CLEAR
eac3 27 19                        BEQ  LB86B                      * DO NOT CRUNCH DATA
eac5 a7 c0              LB852     STA  ,U+                        SAVE CHARACTER IN BUFFER
eac7 27 06                        BEQ  LB85C                      BRANCH IF END OF LINE
eac9 81 3a                        CMPA #':                        * CHECK FOR END OF SUBLINE
eacb 27 cf                        BEQ  ea9c(LB829)                * AND RESET FLAGS IF END OF SUBLINE
eacd 20 d1              LB85A     BRA  eaa0(LB82D)                GO GET ANOTHER CHARACTER
eacf 6f c0              LB85C     CLR  ,U+                        * DOUBLE ZERO AT END OF LINE
ead1 6f c0                        CLR  ,U+                        *
ead3 1f 30                        TFR  U,D                        SAVE ADDRESS OF END OF LINE IN ACCD
ead5 83 00 f1                     SUBD #00f1(LINHDR)              LENGTH OF LINE IN ACCD
ead8 8e 00 f2                     LDX  #00f3(LINBUF)-1            * SET THE INPUT POINTER TO ONE BEFORE
eadb 9f 83                        STX  0083(CHARAD)               * THE START OF THE CRUNCHED LINE
eadd 39                           RTS  EXIT 'CRUNCH'
eade 81 3f              LB86B     CMPA #'?                        CHECK FOR "?" - PRINT ABBREVIATION
eae0 26 04                        BNE  LB873                      BRANCH IF NOT PRINT ABBREVIATION
eae2 86 87                        LDA  #0087(TOK_PRINT)           * GET THE PRINT TOKEN AND SAVE IT
eae4 20 df                        BRA  eac5(LB852)                * IN BUFFER
eae6 81 27              LB873     CMPA #''                        APOSTROPHE IS SAME AS REM
eae8 26 13                        BNE  LB88A                      BRANCH IF NOT REMARK
eaea cc 3a 83                     LDD  #$3A00+TOK_SNGL            _Q COLON, REM TOKEN
eaed ed c1                        STD  ,U++                       SAVE IN BUFFER
eaef 0f 42              LB87C     CLR  0042(V42)                  SET DELIMITER = 0 (END OF LINE)
eaf1 a6 80              LB87E     LDA  ,X+                        SCAN TILL WE MATCH [V42]
eaf3 27 d0                        BEQ  eac5(LB852)                BRANCH IF END OF LINE
eaf5 91 42                        CMPA 0042(V42)                  DELIMITER?
eaf7 27 cc                        BEQ  eac5(LB852)                BRANCH OUT IF SO
eaf9 a7 c0              LB886     STA  ,U+                        DON'T CRUNCH REMARKS OR STRINGS
eafb 20 f4                        BRA  eaf1(LB87E)                GO GET MORE STRING OR REMARK
eafd 81 30              LB88A     CMPA #'0                        * LESS THAN ASCII ZERO?
eaff 25 04                        BCS  LB892                      * BRANCH IF SO
eb01 81 3c                        CMPA #';+1                      = CHECK FOR NUMERIC VALUE, COLON OR SEMICOLON
eb03 25 c0                        BCS  eac5(LB852)                = AND INSERT IN BUFFER IF SO
eb05 30 1f              LB892     LEAX -1,X                       MOVE INPUT POINTER BACK ONE
eb07 34 50                        PSHS U,X                        SAVE POINTERS TO INPUT STRING, OUTPUT STRING
eb09 0f 41                        CLR  0041(V41)                  TOKEN FLAG 0 = COMMAND, FF = SECONDARY
eb0b ce db e4                     LDU  #dbee(COMVEC)-10           POINT U TO COMMAND INTERPRETATION
                        *                             TABLE FOR BASIC - 10
eb0e 0f 42              LB89B     CLR  0042(V42)                  INITIALIZE V42 AS TOKEN COUNTER
eb10 33 4a              LB89D     LEAU 10,U                       MOVE TO NEXT COMMAND INTERPRETATION TABLE
eb12 a6 c4                        LDA  ,U                         GET NUMBER OF COMMANDS
eb14 27 31                        BEQ  LB8D4                      GO DO SECONDARY FUNCTIONS IF NO COMMAND TABLE
eb16 10 ae 41                     LDY  1,U                        POINT Y TO COMMAND DICTIONARY TABLE
eb19 ae e4              LB8A6     LDX  ,S                         GET POINTER TO INPUT STRING
eb1b e6 a0              LB8A8     LDB  ,Y+                        GET A BYTE FROM DICTIONARY TABLE
eb1d e0 80                        SUBB ,X+                        SUBTRACT INPUT CHARACTER
eb1f 27 fa                        BEQ  eb1b(LB8A8)                LOOP IF SAME
eb21 c1 80                        CMPB #$80                       LAST CHAR IN RESERVED WORD TABLE HAD
                        *                             BIT 7 SET, SO IF WE HAVE $80 HERE
                        *                             THEN IT IS A GOOD COMPARE
eb23 26 38                        BNE  LB8EA                      BRANCH IF NO MATCH - CHECK ANOTHER COMMAND
eb25 32 62                        LEAS 2,S                        DELETE OLD INPUT POINTER FROM STACK
eb27 35 40                        PULS U                          GET POINTER TO OUTPUT STRING
eb29 da 42                        ORB  0042(V42)                  OR IN THE TABLE POSITION TO MAKE THE TOKEN
                        *                             - NOTE THAT B ALREADY HAD $80 IN IT -
eb2b 96 41                        LDA  0041(V41)                  * CHECK TOKEN FLAG AND BRANCH
eb2d 26 06                        BNE  LB8C2                      * IF SECONDARY
eb2f c1 84                        CMPB #0084(TOK_ELSE)            IS IT ELSE TOKEN?
eb31 26 06                        BNE  LB8C6                      NO
eb33 86 3a                        LDA  #':                        PUT A COLON (SUBLINE) BEFORE ELSE TOKEN
eb35 ed c1              LB8C2     STD  ,U++                       SECONDARY TOKENS PRECEEDED BY $FF
eb37 20 94                        BRA  eacd(LB85A)                GO PROCESS MORE INPUT CHARACTERS
eb39 e7 c0              LB8C6     STB  ,U+                        SAVE THIS TOKEN
eb3b c1 86                        CMPB #0086(TOK_DATA)            DATA TOKEN?
eb3d 26 02                        BNE  LB8CE                      NO
eb3f 0c 44                        INC  0044(V44)                  SET DATA FLAG
eb41 c1 82              LB8CE     CMPB #0082(TOK_REM)             REM TOKEN?
eb43 27 aa                        BEQ  eaef(LB87C)                YES
eb45 20 86              LB8D2     BRA  eacd(LB85A)                GO PROCESS MORE INPUT CHARACTERS
                        * CHECK FOR A SECONDARY TOKEN
eb47 ce db e9           LB8D4     LDU  #dbee(COMVEC)-5            NOW DO SECONDARY FUNCTIONS
eb4a 03 41                        COM  0041(V41)                  TOGGLE THE TOKEN FLAG
eb4c 26 c0                        BNE  eb0e(LB89B)                BRANCH IF NOW CHECKING SECONDARY COMMANDS

                        * THIS CODE WILL PROCESS INPUT DATA WHICH CANNOT BE CRUNCHED AND SO
                        * IS ASSUMED TO BE ILLEGAL DATA OR AN ILLEGAL TOKEN
eb4e 35 50                        PULS X,U                        RESTORE INPUT AND OUTPUT POINTERS
eb50 a6 80                        LDA  ,X+                        * MOVE THE FIRST CHARACTER OF AN
eb52 a7 c0                        STA  ,U+                        * ILLEGAL TOKEN
eb54 bd e6 26                     JSR  e626(LB3A2)                SET CARRY IF NOT ALPHA
eb57 25 ec                        BCS  eb45(LB8D2)                BRANCH IF NOT ALPHA
eb59 03 43                        COM  0043(V43)                  SET ILLEGAL TOKEN FLAG IF UPPER CASE ALPHA
eb5b 20 e8                        BRA  eb45(LB8D2)                PROCESS MORE INPUT CHARACTERS
eb5d 0c 42              LB8EA     INC  0042(V42)                  INCREMENT TOKEN COUNTER
eb5f 4a                           DECA                            DECR COMMAND COUNTER
eb60 27 ae                        BEQ  eb10(LB89D)                GET ANOTHER COMMAND TABLE IF DONE W/THIS ONE
eb62 31 3f                        LEAY -1,Y                       MOVE POINTER BACK ONE
eb64 e6 a0              LB8F1     LDB  ,Y+                        * GET TO NEXT
eb66 2a fc                        BPL  eb64(LB8F1)                * RESERVED WORD
eb68 20 af                        BRA  eb19(LB8A6)                GO SEE IF THIS WORD IS A MATCH

                        * PRINT
eb6a 27 39              PRINT     BEQ  LB958                      BRANCH IF NO ARGUMENT
eb6c 8d 01                        BSR  LB8FE                      CHECK FOR ALL PRINT OPTIONS
eb6e 39                           RTS
                        LB8FE
eb6f bd fa cf           LB918     JSR  XVEC9                      CALL EXTENDED BASIC ADD-IN
eb72 27 3e              LB91B     BEQ  LB965                      RETURN IF END OF LINE
eb74 81 9f              LB91D     CMPA #009f(TOK_TAB)             TOKEN FOR TAB( ?
eb76 27 53                        BEQ  LB97E                      YES
eb78 81 2c                        CMPA #',                        COMMA?
eb7a 27 37                        BEQ  LB966                      YES - ADVANCE TO NEXT TAB FIELD
eb7c 81 3b                        CMPA #';                        SEMICOLON?
eb7e 27 60                        BEQ  LB997                      YES - DO NOT ADVANCE CURSOR
eb80 bd e3 df                     JSR  e3df(LB156)                EVALUATE EXPRESSION
eb83 96 06                        LDA  0006(VALTYP)               * GET VARIABLE TYPE AND
eb85 34 02                        PSHS A                          * SAVE IT ON THE STACK
eb87 26 06                        BNE  LB938                      BRANCH IF STRING VARIABLE
eb89 bd f0 22                     JSR  LBDD9                      CONVERT FP NUMBER TO AN ASCII STRING
eb8c bd e7 9a                     JSR  e79a(LB516)                PARSE A STRING FROM (X-1) AND PUT
                        *                             DESCRIPTOR ON STRING STACK
eb8f 8d 57              LB938     BSR  LB99F                      PRINT STRING POINTED TO BY X
eb91 35 04                        PULS B                          GET VARIABLE TYPE BACK
eb93 bd dc 30                     JSR  dc30(LA35F)                SET UP TAB WIDTH ZONE, ETC
eb96 5d                 LB949     TSTB                            CHECK CURRENT PRINT POSITION
eb97 26 08                        BNE  LB954                      BRANCH IF NOT AT START OF LINE
eb99 9d 82                        JSR  0082(GETCCH)               GET CURRENT INPUT CHARACTER
eb9b 81 2c                        CMPA #',                        COMMA?
eb9d 27 14                        BEQ  LB966                      SKIP TO NEXT TAB FIELD
eb9f 8d 54                        BSR  LB9AC                      SEND A SPACE TO CONSOLE OUT
eba1 9d 82              LB954     JSR  0082(GETCCH)               GET CURRENT INPUT CHARACTER
eba3 26 cf                        BNE  eb74(LB91D)                BRANCH IF NOT END OF LINE
eba5 86 0d              LB958     LDA  #000d(CR)                  * SEND A CR TO
eba7 20 51                        BRA  LB9B1                      * CONSOLE OUT
eba9 bd dc 30           LB95C     JSR  dc30(LA35F)                SET UP TAB WIDTH, ZONE ETC
ebac 27 f7                        BEQ  eba5(LB958)                BRANCH IF WIDTH = ZERO
ebae 96 6c                        LDA  006c(DEVPOS)               GET PRINT POSITION
ebb0 26 f3                        BNE  eba5(LB958)                BRANCH IF NOT AT START OF LINE
ebb2 39                 LB965     RTS
                        * SKIP TO NEXT TAB FIELD
ebb3 bd dc 30           LB966     JSR  dc30(LA35F)                SET UP TAB WIDTH, ZONE ETC
ebb6 27 0a                        BEQ  LB975                      BRANCH IF LINE WIDTH = 0 (CASSETTE)
ebb8 d6 6c                        LDB  006c(DEVPOS)               GET CURRENT POSITION
ebba d1 6b                        CMPB 006b(DEVLCF)               COMPARE TO LAST TAB ZONE
ebbc 25 06                        BCS  LB977                      BRANCH IF < LAST TAB ZONE
ebbe 8d e5                        BSR  eba5(LB958)                SEND A CARRIAGE RETURN TO CONSOLE OUT
ebc0 20 1e                        BRA  LB997                      GET MORE DATA
ebc2 d6 6c              LB975     LDB  006c(DEVPOS)               *
ebc4 d0 6a              LB977     SUBB 006a(DEVCFW)               * SUBTRACT TAB FIELD WIDTH FROM CURRENT
ebc6 24 fc                        BCC  ebc4(LB977)                * POSITION UNTIL CARRY SET - NEGATING THE
ebc8 50                           NEGB                            * REMAINDER LEAVES THE NUMBER OF SPACES TO NEXT
                        *              * TAB ZONE IN ACCB
ebc9 20 10                        BRA  LB98E                      GO ADVANCE TO NEXT TAB ZONE

                        * PRINT TAB(
ebcb bd e9 8d           LB97E     JSR  e98d(LB709)                EVALUATE EXPRESSION - RETURN VALUE IN B
ebce 81 29                        CMPA #')                        * 'SYNTAX' ERROR IF NOT ')'
ebd0 10 26 f9 2c                  LBNE e500(LB277)                *
ebd4 bd dc 30                     JSR  dc30(LA35F)                SET UP TAB WIDTH, ZONE ETC
ebd7 d0 6c                        SUBB 006c(DEVPOS)               GET DIFFERENCE OF PRINT POSITION & TAB POSITION
ebd9 23 05                        BLS  LB997                      BRANCH IF TAB POSITION < CURRENT POSITION
                        LB98E
ebdb 8d 18              LB992     BSR  LB9AC                      SEND A SPACE TO CONSOLE OUT
ebdd 5a                           DECB                            DECREMENT DIFFERENCE COUNT
ebde 26 fb                        BNE  ebdb(LB992)                BRANCH UNTIL CURRENT POSITION = TAB POSITION
ebe0 9d 7c              LB997     JSR  007c(GETNCH)               GET NEXT CHARACTER FROM BASIC
ebe2 7e eb 72                     JMP  eb72(LB91B)                LOOK FOR MORE PRINT DATA
                        * COPY A STRING FROM (X) TO CONSOLE OUT
ebe5 bd e7 9c           LB99C     JSR  e79c(LB518)                PARSE A STRING FROM X AND PUT
                        *         DESCRIPTOR ON STRING STACK
ebe8 bd e8 db           LB99F     JSR  e8db(LB657)                GET LENGTH OF STRING AND REMOVE
                        *         DESCRIPTOR FROM STRING STACK
ebeb 5c                           INCB                            COMPENSATE FOR DECB BELOW
ebec 5a                 LB9A3     DECB                            DECREMENT COUNTER
ebed 27 c3                        BEQ  ebb2(LB965)                EXIT ROUTINE
ebef a6 80                        LDA  ,X+                        GET A CHARACTER FROM X
ebf1 8d 07                        BSR  LB9B1                      SEND TO CONSOLE OUT
ebf3 20 f7                        BRA  ebec(LB9A3)                KEEP LOOPING
ebf5 86 20              LB9AC     LDA  #0020(SPACE)               SPACE TO CONSOLE OUT
ebf7 8c                           FCB  008c(SKP2)                 SKIP NEXT TWO BYTES
ebf8 86 3f              LB9AF     LDA  #'?                        QUESTION MARK TO CONSOLE OUT
ebfa 7e db 14           LB9B1     JMP  db14(PUTCHR)               JUMP TO CONSOLE OUT

                        * FLOATING POINT MATH PACKAGE

                        * ADD .5 TO FPA0
ebfd 8e f1 09           LB9B4     LDX  #LBEC0                     FLOATING POINT CONSTANT (.5)
ec00 20 09                        BRA  LB9C2                      ADD .5 TO FPA0
                        * SUBTRACT FPA0 FROM FP NUMBER POINTED
                        * TO BY (X), LEAVE RESULT IN FPA0
ec02 bd ed 78           LB9B9     JSR  LBB2F                      COPY PACKED FP DATA FROM (X) TO FPA1

                        * ARITHMETIC OPERATION (-) JUMPS HERE - SUBTRACT FPA0 FROM FPA1 (ENTER
                        * WITH EXPONENT OF FPA0 IN ACCB AND EXPONENT OF FPA1 IN ACCA)
ec05 03 54              LB9BC     COM  0054(FP0SGN)               CHANGE MANTISSA SIGN OF FPA0
ec07 03 62                        COM  0062(RESSGN)               REVERSE RESULT SIGN FLAG
ec09 20 03                        BRA  LB9C5                      GO ADD FPA1 AND FPA0
                        * ADD FP NUMBER POINTED TO BY
                        * (X) TO FPA0 - LEAVE RESULT IN FPA0
ec0b bd ed 78           LB9C2     JSR  LBB2F                      UNPACK PACKED FP DATA FROM (X) TO
                        *         FPA1; RETURN EXPONENT OF FPA1 IN ACCA

                        * ARITHMETIC OPERATION (+) JUMPS HERE - ADD FPA0 TO

ec0e 5d                 LB9C5     TSTB                            CHECK EXPONENT OF FPA0
ec0f 10 27 02 80                  LBEQ LBC4A                      COPY FPA1 TO FPA0 IF FPA0 =
ec13 8e 00 5c                     LDX  #005c(FP1EXP)              POINT X TO FPA1
ec16 1f 89              LB9CD     TFR  A,B                        PUT EXPONENT OF FPA1 INTO ACCB
ec18 5d                           TSTB                            CHECK EXPONENT
ec19 27 6c                        BEQ  LBA3E                      RETURN IF EXPONENT = 0 (ADDING 0 TO FPA0)
ec1b d0 4f                        SUBB 004f(FP0EXP)               SUBTRACT EXPONENT OF FPA0 FROM EXPONENT OF FPA1
ec1d 27 69                        BEQ  LBA3F                      BRANCH IF EXPONENTS ARE EQUAL
ec1f 25 0a                        BCS  LB9E2                      BRANCH IF EXPONENT FPA0 > FPA1
ec21 97 4f                        STA  004f(FP0EXP)               REPLACE FPA0 EXPONENT WITH FPA1 EXPONENT
ec23 96 61                        LDA  0061(FP1SGN)               * REPLACE FPA0 MANTISSA SIGN
ec25 97 54                        STA  0054(FP0SGN)               * WITH FPA1 MANTISSA SIGN
ec27 8e 00 4f                     LDX  #004f(FP0EXP)              POINT X TO FPA0
ec2a 50                           NEGB                            NEGATE DIFFERENCE OF EXPONENTS
ec2b c1 f8              LB9E2     CMPB #-8                        TEST DIFFERENCE OF EXPONENTS
ec2d 2f 59                        BLE  LBA3F                      BRANCH IF DIFFERENCE OF EXPONENTS <= 8
ec2f 4f                           CLRA                            CLEAR OVERFLOW BYTE
ec30 64 01                        LSR  1,X                        SHIFT MS BYTE OF MANTISSA; BIT 7 = 0
ec32 bd ed 03                     JSR  LBABA                      GO SHIFT MANTISSA OF (X) TO THE RIGHT (B) TIMES
ec35 d6 62              LB9EC     LDB  0062(RESSGN)               GET SIGN FLAG
ec37 2a 0b                        BPL  LB9FB                      BRANCH IF FPA0 AND FPA1 SIGNS ARE THE SAME
ec39 63 01                        COM  1,X                        * COMPLEMENT MANTISSA POINTED
ec3b 63 02                        COM  2,X                        * TO BY (X) THE
ec3d 63 03                        COM  3,X                        * ADCA BELOW WILL
ec3f 63 04                        COM  4,X                        * CONVERT THIS OPERATION
ec41 43                           COMA                            * INTO A NEG (MANTISSA)
ec42 89 00                        ADCA #0                         ADD ONE TO ACCA - COMA ALWAYS SETS THE CARRY FLAG
                        * THE PREVIOUS TWO BYTES MAY BE REPLACED BY A NEGA
                        *
                        * ADD MANTISSAS OF FPA0 AND FPA1, PUT RESULT IN FPA0
ec44 97 63              LB9FB     STA  0063(FPSBYT)               SAVE FPA SUB BYTE
ec46 96 53                        LDA  0050(FPA0)+3               * ADD LS BYTE
ec48 99 60                        ADCA 005d(FPA1)+3               * OF MANTISSA
ec4a 97 53                        STA  0050(FPA0)+3               SAVE IN FPA0 LSB
ec4c 96 52                        LDA  0050(FPA0)+2               * ADD NEXT BYTE
ec4e 99 5f                        ADCA 005d(FPA1)+2               * OF MANTISSA
ec50 97 52                        STA  0050(FPA0)+2               SAVE IN FPA0
ec52 96 51                        LDA  0050(FPA0)+1               * ADD NEXT BYTE
ec54 99 5e                        ADCA 005d(FPA1)+1               * OF MANTISSA
ec56 97 51                        STA  0050(FPA0)+1               SAVE IN FPA0
ec58 96 50                        LDA  0050(FPA0)                 * ADD MS BYTE
ec5a 99 5d                        ADCA 005d(FPA1)                 * OF MANTISSA
ec5c 97 50                        STA  0050(FPA0)                 SAVE IN FPA0
ec5e 5d                           TSTB TEST SIGN FLAG
ec5f 2a 44                        BPL  LBA5C                      BRANCH IF FPA0 & FPA1 SIGNS WERE ALIKE
ec61 25 02              LBA18     BCS  LBA1C                      BRANCH IF POSITIVE MANTISSA
ec63 8d 5d                        BSR  LBA79                      NEGATE FPA0 MANTISSA

                        * NORMALIZE FPA0
ec65 5f                 LBA1C     CLRB                            CLEAR TEMPORARY EXPONENT ACCUMULATOR
ec66 96 50              LBA1D     LDA  0050(FPA0)                 TEST MSB OF MANTISSA
ec68 26 2e                        BNE  LBA4F                      BRANCH IF <> 0
ec6a 96 51                        LDA  0050(FPA0)+1               * IF THE MSB IS
ec6c 97 50                        STA  0050(FPA0)                 * 0, THEN SHIFT THE
ec6e 96 52                        LDA  0050(FPA0)+2               * MANTISSA A WHOLE BYTE
ec70 97 51                        STA  0050(FPA0)+1               * AT A TIME. THIS
ec72 96 53                        LDA  0050(FPA0)+3               * IS FASTER THAN ONE
ec74 97 52                        STA  0050(FPA0)+2               * BIT AT A TIME
ec76 96 63                        LDA  0063(FPSBYT)               * BUT USES MORE MEMORY.
ec78 97 53                        STA  0050(FPA0)+3               * FPSBYT, THE CARRY IN
ec7a 0f 63                        CLR  0063(FPSBYT)               * BYTE, REPLACES THE MATISSA LSB.
ec7c cb 08                        ADDB #8                         SHIFTING ONE BYTE = 8 BIT SHIFTS; ADD 8 TO EXPONENT
ec7e c1 28                        CMPB #5*8                       CHECK FOR 5 SHIFTS
ec80 2d e4                        BLT  ec66(LBA1D)                BRANCH IF < 5 SHIFTS, IF > 5, THEN MANTISSA = 0
ec82 4f                 LBA39     CLRA                            A ZERO EXPONENT = 0 FLOATING POINT
ec83 97 4f              LBA3A     STA  004f(FP0EXP)               ZERO OUT THE EXPONENT
ec85 97 54                        STA  0054(FP0SGN)               ZERO OUT THE MANTISSA SIGN
ec87 39                 LBA3E     RTS
ec88 8d 6d              LBA3F     BSR  LBAAE                      SHIFT FPA0 MANTISSA TO RIGHT
ec8a 5f                           CLRB                            CLEAR CARRY FLAG
ec8b 20 a8                        BRA  ec35(LB9EC)
                        * SHIFT FPA0 LEFT ONE BIT UNTIL BIT 7
                        * OF MATISSA MS BYTE = 1
ec8d 5c                 LBA44     INCB                            ADD ONE TO EXPONENT ACCUMULATOR
ec8e 08 63                        ASL  0063(FPSBYT)               SHIFT SUB BYTE ONE LEFT
ec90 09 53                        ROL  0050(FPA0)+3               SHIFT LS BYTE
ec92 09 52                        ROL  0050(FPA0)+2               SHIFT NS BYTE
ec94 09 51                        ROL  0050(FPA0)+1               SHIFT NS BYTE
ec96 09 50                        ROL  0050(FPA0)                 SHIFT MS BYTE
ec98 2a f3              LBA4F     BPL  ec8d(LBA44)                BRANCH IF NOT YET NORMALIZED
ec9a 96 4f                        LDA  004f(FP0EXP)               GET CURRENT EXPONENT
ec9c 34 04                        PSHS B                          SAVE EXPONENT MODIFIER CAUSED BY NORMALIZATION
ec9e a0 e0                        SUBA ,S+                        SUBTRACT ACCUMULATED EXPONENT MODIFIER
eca0 97 4f                        STA  004f(FP0EXP)               SAVE AS NEW EXPONENT
eca2 23 de                        BLS  ec82(LBA39)                SET FPA0 = 0 IF THE NORMALIZATION CAUSED
                        *         MORE OR EQUAL NUMBER OF LEFT SHIFTS THAN THE
                        *         SIZE OF THE EXPONENT
eca4 8c                           FCB  008c(SKP2)                 SKIP 2 BYTES
eca5 25 08              LBA5C     BCS  LBA66                      BRANCH IF MANTISSA OVERFLOW
eca7 08 63                        ASL  0063(FPSBYT)               SUB BYTE BIT 7 TO CARRY - USE AS ROUND-OFF
                        *                             FLAG (TRUNCATE THE REST OF SUB BYTE)
eca9 86 00                        LDA  #0                         CLRA, BUT DO NOT CHANGE CARRY FLAG
ecab 97 63                        STA  0063(FPSBYT)               CLEAR THE SUB BYTE
ecad 20 0c                        BRA  LBA72                      GO ROUND-OFF RESULT
ecaf 0c 4f              LBA66     INC  004f(FP0EXP)               INCREMENT EXPONENT - MULTIPLY BY 2
ecb1 27 28                        BEQ  LBA92                      OVERFLOW ERROR IF CARRY PAST $FF
ecb3 06 50                        ROR  0050(FPA0)                 * SHIFT MANTISSA
ecb5 06 51                        ROR  0050(FPA0)+1               * ONE TO
ecb7 06 52                        ROR  0050(FPA0)+2               * THE RIGHT -
ecb9 06 53                        ROR  0050(FPA0)+3               * DIVIDE BY TWO
ecbb 24 04              LBA72     BCC  LBA78                      BRANCH IF NO ROUND-OFF NEEDED
ecbd 8d 0d                        BSR  LBA83                      ADD ONE TO MANTISSA - ROUND OFF
ecbf 27 ee                        BEQ  ecaf(LBA66)                BRANCH iF OVERFLOW - MANTISSA = 0
ecc1 39                 LBA78     RTS
                        * NEGATE FPA0 MANTISSA
ecc2 03 54              LBA79     COM  0054(FP0SGN)               TOGGLE SIGN OF MANTISSA
ecc4 03 50              LBA7B     COM  0050(FPA0)                 * COMPLEMENT ALL 4 MANTISSA BYTES
ecc6 03 51                        COM  0050(FPA0)+1               *
ecc8 03 52                        COM  0050(FPA0)+2               *
ecca 03 53                        COM  0050(FPA0)+3               *
                        * ADD ONE TO FPA0 MANTISSA
eccc 9e 52              LBA83     LDX  0050(FPA0)+2               * GET BOTTOM 2 MANTISSA
ecce 30 01                        LEAX 1,X                        * BYTES, ADD ONE TO
ecd0 9f 52                        STX  0050(FPA0)+2               * THEM AND SAVE THEM
ecd2 26 06                        BNE  LBA91                      BRANCH IF NO OVERFLOW
ecd4 9e 50                        LDX  0050(FPA0)                 * IF OVERFLOW ADD ONE
ecd6 30 01                        LEAX 1,X                        * TO TOP 2 MANTISSA
ecd8 9f 50                        STX  0050(FPA0)                 * BYTES AND SAVE THEM
ecda 39                 LBA91     RTS
ecdb c6 0a              LBA92     LDB  #2*5                       OV' OVERFLOW ERROR
ecdd 7e df 03                     JMP  df03(LAC46)                PROCESS AN ERROR
ece0 8e 00 12           LBA97     LDX  #0013(FPA2)-1              POINT X TO FPA2
                        * SHIFT FPA POINTED TO BY (X) TO
                        * THE RIGHT -(B) TIMES. EXIT WITH
                        * ACCA CONTAINING DATA SHIFTED OUT
                        * TO THE RIGHT (SUB BYTE) AND THE DATA
                        * SHIFTED IN FROM THE LEFT WILL COME FROM FPCARY
ece3 a6 04              LBA9A     LDA  4,X                        GET LS BYTE OF MANTISSA (X)
ece5 97 63                        STA  0063(FPSBYT)               SAVE IN FPA SUB BYTE
ece7 a6 03                        LDA  3,X                        * SHIFT THE NEXT THREE BYTES OF THE
ece9 a7 04                        STA  4,X                        * MANTISSA RIGHT ONE COMPLETE BYTE.
eceb a6 02                        LDA  2,X                        *
eced a7 03                        STA  3,X                        *
ecef a6 01                        LDA  1,X                        *
ecf1 a7 02                        STA  2,X                        *
ecf3 96 5b                        LDA  005b(FPCARY)               GET THE CARRY IN BYTE
ecf5 a7 01                        STA  1,X                        STORE AS THE MS MANTISSA BYTE OF (X)
ecf7 cb 08              LBAAE     ADDB #8                         ADD 8 TO DIFFERENCE OF EXPONENTS
ecf9 2f e8                        BLE  ece3(LBA9A)                BRANCH IF EXPONENT DIFFERENCE < -8
ecfb 96 63                        LDA  0063(FPSBYT)               GET FPA SUB BYTE
ecfd c0 08                        SUBB #8                         CAST OUT THE 8 ADDED IN ABOVE
ecff 27 0c                        BEQ  LBAC4                      BRANCH IF EXPONENT DIFFERENCE = 0


ed01 67 01              LBAB8     ASR  1,X                        * SHIFT MANTISSA AND SUB BYTE ONE BIT TO THE RIGHT
ed03 66 02              LBABA     ROR  2,X                        *
ed05 66 03                        ROR  3,X                        *
ed07 66 04                        ROR  4,X                        *
ed09 46                           RORA                            *
ed0a 5c                           INCB                            ADD ONE TO EXPONENT DIFFERENCE
ed0b 26 f4                        BNE  ed01(LBAB8)                BRANCH IF EXPONENTS NOT =
ed0d 39                 LBAC4     RTS
ed0e 81 00 00 00 00     LBAC5     FCB  $81,$00,$00,$00            ,$00 FLOATING POINT CONSTANT 1.0

                        * ARITHMETIC OPERATION (*) JUMPS HERE - MULTIPLY
                        * FPA0 BY (X) - RETURN PRODUCT IN FPA0
ed13 8d 63              LBACA     BSR  LBB2F                      MOVE PACKED FPA FROM (X) TO FPA1
ed15 27 60              LBACC     BEQ  LBB2E                      BRANCH IF EXPONENT OF FPA0 = 0
ed17 8d 78                        BSR  LBB48                      CALCULATE EXPONENT OF PRODUCT
                        * MULTIPLY FPA0 MANTISSA BY FPA1. NORMALIZE
                        * HIGH ORDER BYTES OF PRODUCT IN FPA0. THE
                        * LOW ORDER FOUR BYTES OF THE PRODUCT WILL
                        * BE STORED IN VAB-VAE.
ed19 86 00              LBAD0     LDA  #0                         * ZERO OUT MANTISSA OF FPA2
ed1b 97 13                        STA  0013(FPA2)                 *
ed1d 97 14                        STA  0013(FPA2)+1               *
ed1f 97 15                        STA  0013(FPA2)+2               *
ed21 97 16                        STA  0013(FPA2)+3               *
ed23 d6 53                        LDB  0050(FPA0)+3               GET LS BYTE OF FPA0
ed25 8d 22                        BSR  LBB00                      MULTIPLY BY FPA1
ed27 d6 63                        LDB  0063(FPSBYT)               * TEMPORARILY SAVE SUB BYTE 4
ed29 d7 8b                        STB  008b(VAE)                  *
ed2b d6 52                        LDB  0050(FPA0)+2               GET NUMBER 3 MANTISSA BYTE OF FPA0
ed2d 8d 1a                        BSR  LBB00                      MULTIPLY BY FPA1
ed2f d6 63                        LDB  0063(FPSBYT)               * TEMPORARILY SAVE SUB BYTE 3
ed31 d7 8a                        STB  008a(VAD)                  *
ed33 d6 51                        LDB  0050(FPA0)+1               GET NUMBER 2 MANTISSA BYTE OF FPA0
ed35 8d 12                        BSR  LBB00                      MULTIPLY BY FPA1
ed37 d6 63                        LDB  0063(FPSBYT)               * TEMPORARILY SAVE SUB BYTE 2
ed39 d7 89                        STB  0089(VAC)                  *
ed3b d6 50                        LDB  0050(FPA0)                 GET MS BYTE OF FPA0 MANTISSA
ed3d 8d 0c                        BSR  LBB02                      MULTIPLY BY FPA1
ed3f d6 63                        LDB  0063(FPSBYT)               * TEMPORARILY SAVE SUB BYTE 1
ed41 d7 88                        STB  0088(VAB)                  *
ed43 bd ee 54                     JSR  LBC0B                      COPY MANTISSA FROM FPA2 TO FPA0
ed46 7e ec 65                     JMP  ec65(LBA1C)                NORMALIZE FPA0
ed49 27 95              LBB00     BEQ  ece0(LBA97)                SHIFT FPA2 ONE BYTE TO RIGHT
ed4b 43                 LBB02     COMA                            SET CARRY FLAG
                        * MULTIPLY FPA1 MANTISSA BY ACCB AND
                        * ADD PRODUCT TO FPA2 MANTISSA
ed4c 96 13              LBB03     LDA  0013(FPA2)                 GET FPA2 MS BYTE
ed4e 56                           RORB ROTATE CARRY FL            AG INTO SHIFT COUNTER;
                        *         DATA BIT INTO CARRY
ed4f 27 26                        BEQ  LBB2E                      BRANCH WHEN 8 SHIFTS DONE
ed51 24 16                        BCC  LBB20                      DO NOT ADD FPA1 IF DATA BIT = 0
ed53 96 16                        LDA  0013(FPA2)+3               * ADD MANTISSA LS BYTE
ed55 9b 60                        ADDA 005d(FPA1)+3               *
ed57 97 16                        STA  0013(FPA2)+3               *
ed59 96 15                        LDA  0013(FPA2)+2               = ADD MANTISSA NUMBER 3 BYTE
ed5b 99 5f                        ADCA 005d(FPA1)+2               =
ed5d 97 15                        STA  0013(FPA2)+2               =
ed5f 96 14                        LDA  0013(FPA2)+1               * ADD MANTISSA NUMBER 2 BYTE
ed61 99 5e                        ADCA 005d(FPA1)+1               *
ed63 97 14                        STA  0013(FPA2)+1               *
ed65 96 13                        LDA  0013(FPA2)                 = ADD MANTISSA MS BYTE
ed67 99 5d                        ADCA 005d(FPA1)                 =
ed69 46                 LBB20     RORA * ROTATE CARRY             INTO MS BYTE
ed6a 97 13                        STA  0013(FPA2)                 *
ed6c 06 14                        ROR  0013(FPA2)+1               = ROTATE FPA2 ONE BIT TO THE RIGHT
ed6e 06 15                        ROR  0013(FPA2)+2               =
ed70 06 16                        ROR  0013(FPA2)+3               =
ed72 06 63                        ROR  0063(FPSBYT)               =
ed74 4f                           CLRA                            CLEAR CARRY FLAG
ed75 20 d5                        BRA  ed4c(LBB03)                KEEP LOOPING
ed77 39                 LBB2E     RTS
                        * UNPACK A FP NUMBER FROM (X) TO FPA1
ed78 ec 01              LBB2F     LDD  1,X                        GET TWO MSB BYTES OF MANTISSA FROM
                        *         FPA  POINTED TO BY X
ed7a 97 61                        STA  0061(FP1SGN)               SAVE PACKED MANTISSA SIGN BYTE
ed7c 8a 80                        ORA  #$80                       FORCE BIT 7 OF MSB MANTISSA = 1
ed7e dd 5d                        STD  005d(FPA1)                 SAVE 2 MSB BYTES IN FPA1
ed80 d6 61                        LDB  0061(FP1SGN)               * GET PACKED MANTISSA SIGN BYTE. EOR W/FPA0
ed82 d8 54                        EORB 0054(FP0SGN)               * SIGN - NEW SIGN POSITION IF BOTH OLD SIGNS ALIKE,
ed84 d7 62                        STB  0062(RESSGN)               * NEG IF BOTH OLD SIGNS DIFF. SAVE ADJUSTED
                        *                             * MANTISSA SIGN BYTE
ed86 ec 03                        LDD  3,X                        = GET 2 LSB BYTES OF MANTISSA
ed88 dd 5f                        STD  005d(FPA1)+2               = AND PUT IN FPA1
ed8a a6 84                        LDA  ,X                         * GET EXPONENT FROM (X) AND
ed8c 97 5c                        STA  005c(FP1EXP)               * PUT IN EXPONENT OF FPA1
ed8e d6 4f                        LDB  004f(FP0EXP)               GET EXPONENT OF FPA0
ed90 39                           RTS
                        * CALCULATE EXPONENT FOR PRODUCT OF FPA0 & FPA1
                        * ENTER WITH EXPONENT OF FPA1 IN ACCA
ed91 4d                 LBB48     TSTA                            TEST EXPONENT OF FPA1
ed92 27 16                        BEQ  LBB61                      PURGE RETURN ADDRESS & SET FPA0 = 0
ed94 9b 4f                        ADDA 004f(FP0EXP)               ADD FPA1 EXPONENT TO FPA0 EXPONENT
ed96 46                           RORA                            ROTATE CARRY INTO BIT 7; BIT 0 INTO CARRY
ed97 49                           ROLA                            SET OVERFLOW FLAG
ed98 28 10                        BVC  LBB61                      BRANCH IF EXPONENT TOO LARGE OR SMALL
ed9a 8b 80                        ADDA #$80                       ADD $80 BIAS TO EXPONENT
ed9c 97 4f                        STA  004f(FP0EXP)               SAVE NEW EXPONENT
ed9e 27 0c                        BEQ  LBB63                      SET FPA0
eda0 96 62                        LDA  0062(RESSGN)               GET MANTISSA SIGN
eda2 97 54                        STA  0054(FP0SGN)               SAVE AS MANTISSA SIGN OF FPA0
eda4 39                           RTS
                        * IF FPA0 = POSITIVE THEN 'OV' ERROR IF FPA0
                        * = IS NEGATIVE THEN FPA0 = 0
eda5 96 54              LBB5C     LDA  0054(FP0SGN)               GET MANTISSA SIGN OF FPA0
eda7 43                           COMA                            CHANGE SIGN OF FPA0 MANTISSA
eda8 20 02                        BRA  LBB63
edaa 32 62              LBB61     LEAS 2,S                        PURGE RETURN ADDRESS FROM STACK
edac 10 2a fe d2        LBB63     LBPL ec82(LBA39)                ZERO FPA0 MANTISSA SIGN & EXPONENT
edb0 7e ec db           LBB67     JMP  ecdb(LBA92)                OV' OVERFLOW ERROR
                        * FAST MULTIPLY BY 10 AND LEAVE RESULT IN FPA0
edb3 bd ee a8           LBB6A     JSR  LBC5F                      TRANSFER FPA0 TO FPA1
edb6 27 0d                        BEQ  LBB7C                      BRANCH IF EXPONENT = 0
edb8 8b 02                        ADDA #2                         ADD 2 TO EXPONENT (TIMES 4)
edba 25 f4                        BCS  edb0(LBB67)                OV' ERROR IF EXPONENT > $FF
edbc 0f 62                        CLR  0062(RESSGN)               CLEAR RESULT SIGN BYTE
edbe bd ec 16                     JSR  ec16(LB9CD)                ADD FPA1 TO FPA0 (TIMES 5)
edc1 0c 4f                        INC  004f(FP0EXP)               ADD ONE TO EXPONENT (TIMES 10)
edc3 27 eb                        BEQ  edb0(LBB67)                OV' ERROR IF EXPONENT > $FF
edc5 39                 LBB7C     RTS
edc6 84 20 00 00 00     LBB7D     FCB  $84,$20,$00,$00            ,$00 FLOATING POINT CONSTANT 10
                        * DIVIDE FPA0 BY 10
edcb bd ee a8           LBB82     JSR  LBC5F                      MOVE FPA0 TO FPA1
edce 8e ed c6                     LDX  #edc6(LBB7D)               POINT TO FLOATING POINT CONSTANT 10
edd1 5f                           CLRB                            ZERO MANTISSA SIGN BYTE
edd2 d7 62              LBB89     STB  0062(RESSGN)               STORE THE QUOTIENT MANTISSA SIGN BYTE
edd4 bd ee 5d                     JSR  LBC14                      UNPACK AN FP NUMBER FROM (X) INTO FPA0
edd7 8c                           FCB  008c(SKP2)                 SKIP TWO BYTES
                        * DIVIDE (X) BY FPA0-LEAVE NORMALIZED QUOTIENT IN FPA0
edd8 8d 9e              LBB8F     BSR  ed78(LBB2F)                GET FP NUMBER FROM (X) TO FPA1

                        * ARITHMETIC OPERATION (/) JUMPS HERE. DIVIDE FPA1 BY FPA0 (ENTER WITH
                        * EXPONENT OF FPA1 IN ACCA AND FLAGS SET BY TSTA)

                        * DIVIDE FPA1 BY FPA0
edda 27 73              LBB91     BEQ  LBC06                      /0' DIVIDE BY ZERO ERROR
eddc 00 4f                        NEG  004f(FP0EXP)               GET EXPONENT OF RECIPROCAL OF DIVISOR
edde 8d b1                        BSR  ed91(LBB48)                CALCULATE EXPONENT OF QUOTIENT
ede0 0c 4f                        INC  004f(FP0EXP)               INCREMENT EXPONENT
ede2 27 cc                        BEQ  edb0(LBB67)                OV' OVERFLOW ERROR
ede4 8e 00 13                     LDX  #0013(FPA2)                POINT X TO MANTISSA OF FPA2 - HOLD
                        *                             TEMPORARY QUOTIENT IN FPA2
ede7 c6 04                        LDB  #4                         5 BYTE DIVIDE
ede9 d7 03                        STB  0003(TMPLOC)               SAVE BYTE COUNTER
edeb c6 01                        LDB  #1                         SHIFT COUNTER-AND TEMPORARY QUOTIENT BYTE
                        * COMPARE FPA0 MANTISSA TO FPA1 MANTISSA -
                        * SET CARRY FLAG IF FPA1 >= FPA0
eded 96 50              LBBA4     LDA  0050(FPA0)                 * COMPARE THE TWO MS BYTES
edef 91 5d                        CMPA 005d(FPA1)                 * OF FPA0 AND FPA1 AND
edf1 26 13                        BNE  LBBBD                      * BRANCH IF <>
edf3 96 51                        LDA  0050(FPA0)+1               = COMPARE THE NUMBER 2
edf5 91 5e                        CMPA 005d(FPA1)+1               = BYTES AND
edf7 26 0d                        BNE  LBBBD                      = BRANCH IF <>
edf9 96 52                        LDA  0050(FPA0)+2               * COMPARE THE NUMBER 3
edfb 91 5f                        CMPA 005d(FPA1)+2               * BYTES AND
edfd 26 07                        BNE  LBBBD                      * BRANCH IF <>
edff 96 53                        LDA  0050(FPA0)+3               = COMPARE THE LS BYTES
ee01 91 60                        CMPA 005d(FPA1)+3               = AND BRANCH
ee03 26 01                        BNE  LBBBD                      = IF <>
ee05 43                           COMA                            SET CARRY FLAG IF FPA0 = FPA1
ee06 1f a8              LBBBD     TFR  CC,A                       SAVE CARRY FLAG STATUS IN ACCA; CARRY
                        *         CLEAR IF FPA0 > FPA1
ee08 59                           ROLB                            ROTATE CARRY INTO TEMPORARY QUOTIENT BYTE
ee09 24 0a                        BCC  LBBCC                      CARRY WILL BE SET AFTER 8 SHIFTS
ee0b e7 80                        STB  ,X+                        SAVE TEMPORARY QUOTIENT
ee0d 0a 03                        DEC  0003(TMPLOC)               DECREMENT BYTE COUNTER
ee0f 2b 34                        BMI  LBBFC                      BRANCH IF DONE
ee11 27 2e                        BEQ  LBBF8                      BRANCH IF LAST BYTE
ee13 c6 01                        LDB  #1                         RESET SHIFT COUNTER AND TEMPORARY QUOTIENT BYTE
ee15 1f 8a              LBBCC     TFR  A,CC                       RESTORE CARRY FLAG AND
ee17 25 0e                        BCS  LBBDE                      BRANCH IF FPA0 =< FPA1
ee19 08 60              LBBD0     ASL  005d(FPA1)+3               * SHIFT FPA1 MANTISSA 1 BIT TO LEFT
ee1b 09 5f                        ROL  005d(FPA1)+2               *
ee1d 09 5e                        ROL  005d(FPA1)+1               *
ee1f 09 5d                        ROL  005d(FPA1)                 *
ee21 25 e3                        BCS  ee06(LBBBD)                BRANCH IF CARRY - ADD ONE TO PARTIAL QUOTIENT
ee23 2b c8                        BMI  eded(LBBA4)                IF MSB OF HIGH ORDER MANTISSA BYTE IS
                        *         SET, CHECK THE MAGNITUDES OF FPA0, FPA1
ee25 20 df                        BRA  ee06(LBBBD)                CARRY IS CLEAR, CHECK ANOTHER BIT
                        * SUBTRACT FPA0 FROM FPA1 - LEAVE RESULT IN FPA1
ee27 96 60              LBBDE     LDA  005d(FPA1)+3               * SUBTRACT THE LS BYTES OF MANTISSA
ee29 90 53                        SUBA 0050(FPA0)+3               *
ee2b 97 60                        STA  005d(FPA1)+3               *
ee2d 96 5f                        LDA  005d(FPA1)+2               = THEN THE NEXT BYTE
ee2f 92 52                        SBCA 0050(FPA0)+2               =
ee31 97 5f                        STA  005d(FPA1)+2               =
ee33 96 5e                        LDA  005d(FPA1)+1               * AND THE NEXT
ee35 92 51                        SBCA 0050(FPA0)+1               *
ee37 97 5e                        STA  005d(FPA1)+1               *
ee39 96 5d                        LDA  005d(FPA1)                 = AND FINALLY, THE MS BYTE OF MANTISSA
ee3b 92 50                        SBCA 0050(FPA0)                 =
ee3d 97 5d                        STA  005d(FPA1)                 =
ee3f 20 d8                        BRA  ee19(LBBD0)                GO SHIFT FPA1
ee41 c6 40              LBBF8     LDB  #$40                       USE ONLY TWO BITS OF THE LAST BYTE (FIFTH)
ee43 20 d0                        BRA  ee15(LBBCC)                GO SHIFT THE LAST BYTE
ee45 56                 LBBFC     RORB * SHIFT CARRY (            ALWAYS SET HERE) INTO
ee46 56                           RORB * BIT 5 AND MOV            E
ee47 56                           RORB * BITS 1,0 TO B            ITS 7,6
ee48 d7 63                        STB  0063(FPSBYT)               SAVE SUB BYTE
ee4a 8d 08                        BSR  LBC0B                      MOVE MANTISSA OF FPA2 TO FPA0
ee4c 7e ec 65                     JMP  ec65(LBA1C)                NORMALIZE FPA0
ee4f c6 14              LBC06     LDB  #2*10                      /0' ERROR
ee51 7e df 03                     JMP  df03(LAC46)                PROCESS THE ERROR
                        * COPY MANTISSA FROM FPA2 TO FPA0
ee54 9e 13              LBC0B     LDX  0013(FPA2)                 * MOVE TOP 2 BYTES
ee56 9f 50                        STX  0050(FPA0)                 *
ee58 9e 15                        LDX  0013(FPA2)+2               = MOVE BOTTOM 2 BYTES
ee5a 9f 52                        STX  0050(FPA0)+2               =
ee5c 39                           RTS
                        * COPY A PACKED FP NUMBER FROM (X) TO FPA0
ee5d 34 02              LBC14     PSHS A                          SAVE ACCA
ee5f ec 01                        LDD  1,X                        GET TOP TWO MANTISSA BYTES
ee61 97 54                        STA  0054(FP0SGN)               SAVE MS BYTE OF MANTISSA AS MANTISSA SIGN
ee63 8a 80                        ORA  #$80                       UNPACK MS BYTE
ee65 dd 50                        STD  0050(FPA0)                 SAVE UNPACKED TOP 2 MANTISSA BYTES
ee67 0f 63                        CLR  0063(FPSBYT)               CLEAR MANTISSA SUB BYTE
ee69 e6 84                        LDB  ,X                         GET EXPONENT TO ACCB
ee6b ae 03                        LDX  3,X                        * MOVE LAST 2
ee6d 9f 52                        STX  0050(FPA0)+2               * MANTISSA BYTES
ee6f d7 4f                        STB  004f(FP0EXP)               SAVE EXPONENT
ee71 35 82                        PULS A,PC                       RESTORE ACCA AND RETURN

ee73 8e 00 45           LBC2A     LDX  #0045(V45)                 POINT X TO MANTISSA OF FPA4
ee76 20 06                        BRA  LBC35                      MOVE FPA0 TO FPA4
ee78 8e 00 40           LBC2F     LDX  #0040(V40)                 POINT X TO MANTISSA OF FPA3
ee7b 8c                           FCB  008c(SKP2)                 SKIP TWO BYTES
ee7c 9e 3b              LBC33     LDX  003b(VARDES)               POINT X TO VARIABLE DESCRIPTOR IN VARDES
                        * PACK FPA0 AND MOVE IT TO ADDRESS IN X
ee7e 96 4f              LBC35     LDA  004f(FP0EXP)               * COPY EXPONENT
ee80 a7 84                        STA  ,X                         *
ee82 96 54                        LDA  0054(FP0SGN)               GET MANTISSA SIGN BIT
ee84 8a 7f                        ORA  #$7F                       MASK THE BOTTOM 7 BITS
ee86 94 50                        ANDA 0050(FPA0)                 AND BIT 7 OF MANTISSA SIGN INTO BIT 7 OF MS BYTE
ee88 a7 01                        STA  1,X                        SAVE MS BYTE
ee8a 96 51                        LDA  0050(FPA0)+1               * MOVE 2ND MANTISSA BYTE
ee8c a7 02                        STA  2,X                        *
ee8e de 52                        LDU  0050(FPA0)+2               = MOVE BOTTOM 2 MANTISSA BYTES
ee90 ef 03                        STU  3,X                        =
ee92 39                           RTS
                        * MOVE FPA1 TO FPA0 RETURN W/MANTISSA SIGN IN ACCA
ee93 96 61              LBC4A     LDA  0061(FP1SGN)               * COPY MANTISSA SIGN FROM
ee95 97 54              LBC4C     STA  0054(FP0SGN)               * FPA1 TO FPA0
ee97 9e 5c                        LDX  005c(FP1EXP)               = COPY EXPONENT + MS BYTE FROM
ee99 9f 4f                        STX  004f(FP0EXP)               = FPA1 TO FPA0
ee9b 0f 63                        CLR  0063(FPSBYT)               CLEAR MANTISSA SUB BYTE
ee9d 96 5e                        LDA  005d(FPA1)+1               * COPY 2ND MANTISSA BYTE
ee9f 97 51                        STA  0050(FPA0)+1               * FROM FPA1 TO FPA0
eea1 96 54                        LDA  0054(FP0SGN)               GET MANTISSA SIGN
eea3 9e 5f                        LDX  005d(FPA1)+2               * COPY 3RD AND 4TH MANTISSA BYTE
eea5 9f 52                        STX  0050(FPA0)+2               * FROM FPA1 TO FPA0
eea7 39                           RTS
                        * TRANSFER FPA0 TO FPA1
eea8 dc 4f              LBC5F     LDD  004f(FP0EXP)               * TRANSFER EXPONENT & MS BYTE
eeaa dd 5c                        STD  005c(FP1EXP)               *
eeac 9e 51                        LDX  0050(FPA0)+1               = TRANSFER MIDDLE TWO BYTES
eeae 9f 5e                        STX  005d(FPA1)+1               =
eeb0 9e 53                        LDX  0050(FPA0)+3               * TRANSFER BOTTOM TWO BYTES
eeb2 9f 60                        STX  005d(FPA1)+3               *
eeb4 4d                           TSTA                            SET FLAGS ACCORDING TO EXPONENT
eeb5 39                           RTS
                        * CHECK FPA0; RETURN ACCB = 0 IF FPA0 = 0,
                        * ACCB = $FF IF FPA0 = NEGATIVE, ACCB = 1 IF FPA0 = POSITIVE
eeb6 d6 4f              LBC6D     LDB  004f(FP0EXP)               GET EXPONENT
eeb8 27 08                        BEQ  LBC79                      BRANCH IF FPA0 = 0
eeba d6 54              LBC71     LDB  0054(FP0SGN)               GET SIGN OF MANTISSA
eebc 59                 LBC73     ROLB                            BIT 7 TO CARRY
eebd c6 ff                        LDB  #$FF                       NEGATIVE FLAG
eebf 25 01                        BCS  LBC79                      BRANCH IF NEGATIVE MANTISSA
eec1 50                           NEGB                            ACCB = 1 IF POSITIVE MANTISSA
eec2 39                 LBC79     RTS

                        * SGN
eec3 8d f1              SGN       BSR  eeb6(LBC6D)                SET ACCB ACCORDING TO SIGN OF FPA0
                        * CONVERT A SIGNED NUMBER IN ACCB INTO A FLOATING POINT NUMBER
eec5 d7 50              LBC7C     STB  0050(FPA0)                 SAVE ACCB IN FPA0
eec7 0f 51                        CLR  0050(FPA0)+1               CLEAR NUMBER 2 MANTISSA BYTE OF FPA0
eec9 c6 88                        LDB  #$88                       EXPONENT REQUIRED IF FPA0 IS TO BE AN INTEGER
eecb 96 50              LBC82     LDA  0050(FPA0)                 GET MS BYTE OF MANTISSA
eecd 80 80                        SUBA #$80                       SET CARRY IF POSITIVE MANTISSA
eecf d7 4f              LBC86     STB  004f(FP0EXP)               SAVE EXPONENT
eed1 dc 74                        LDD  0074(ZERO)                 * ZERO OUT ACCD AND
eed3 dd 52                        STD  0050(FPA0)+2               * BOTTOM HALF OF FPA0
eed5 97 63                        STA  0063(FPSBYT)               CLEAR SUB BYTE
eed7 97 54                        STA  0054(FP0SGN)               CLEAR SIGN OF FPA0 MANTISSA
eed9 7e ec 61                     JMP  ec61(LBA18)                GO NORMALIZE FPA0

                        * ABS
eedc 0f 54              ABS       CLR  0054(FP0SGN)               FORCE MANTISSA SIGN OF FPA0 POSITIVE
eede 39                           RTS
                        * COMPARE A PACKED FLOATING POINT NUMBER POINTED TO
                        * BY (X) TO AN UNPACKED FP NUMBER IN FPA0. RETURN
                        * ZERO FLAG SET AND ACCB = 0, IF EQUAL; ACCB = 1 IF
                        * FPA0 > (X); ACCB = $FF IF FPA0 < (X)
eedf e6 84              LBC96     LDB  ,X                         CHECK EXPONENT OF (X)
eee1 27 d3                        BEQ  eeb6(LBC6D)                BRANCH IF FPA = 0
eee3 e6 01                        LDB  1,X                        GET MS BYTE OF MANTISSA OF (X)
eee5 d8 54                        EORB 0054(FP0SGN)               EOR WITH SIGN OF FPA0
eee7 2b d1                        BMI  eeba(LBC71)                BRANCH IF SIGNS NOT =
                        * COMPARE FPA0 WITH FP NUMBER POINTED TO BY (X).
                        * FPA0 IS NORMALIZED, (X) IS PACKED.
eee9 d6 4f              LBCA0     LDB  004f(FP0EXP)               * GET EXPONENT OF
eeeb e1 84                        CMPB ,X                         * FPA0, COMPARE TO EXPONENT OF
eeed 26 1d                        BNE  LBCC3                      * (X) AND BRANCH IF <>.
eeef e6 01                        LDB  1,X                        * GET MS BYTE OF (X), KEEP ONLY
eef1 ca 7f                        ORB  #$7F                       * THE SIGN BIT - 'AND' THE BOTTOM 7
eef3 d4 50                        ANDB 0050(FPA0)                 * BITS OF FPA0 INTO ACCB
eef5 e1 01                        CMPB 1,X                        = COMPARE THE BOTTOM 7 BITS OF THE MANTISSA
eef7 26 13                        BNE  LBCC3                      = MS BYTE AND BRANCH IF <>
eef9 d6 51                        LDB  0050(FPA0)+1               * COMPARE 2ND BYTE
eefb e1 02                        CMPB 2,X                        * OF MANTISSA,
eefd 26 0d                        BNE  LBCC3                      * BRANCH IF <>
eeff d6 52                        LDB  0050(FPA0)+2               = COMPARE 3RD BYTE
ef01 e1 03                        CMPB 3,X                        = OF MANTISSA,
ef03 26 07                        BNE  LBCC3                      = BRANCH IF <>
ef05 d6 53                        LDB  0050(FPA0)+3               * SUBTRACT LS BYTE
ef07 e0 04                        SUBB 4,X                        * OF (X) FROM LS BYTE OF
ef09 26 01                        BNE  LBCC3                      * FPA0, BRANCH IF <>
ef0b 39                           RTS                             RETURN IF FP (X) = FPA0
ef0c 56                 LBCC3     RORB                            SHIFT CARRY TO BIT 7; CARRY SET IF FPA0 < (X)
ef0d d8 54                        EORB 0054(FP0SGN)               TOGGLE SIZE COMPARISON BIT IF FPA0 IS NEGATIVE
ef0f 20 ab                        BRA  eebc(LBC73)                GO SET ACCB ACCORDING TO COMPARISON
                        * DE-NORMALIZE FPA0 : SHIFT THE MANTISSA UNTIL THE BINARY POINT IS TO THE RIGHT
                        * OF THE LEAST SIGNIFICANT BYTE OF THE MANTISSA
ef11 d6 4f              LBCC8     LDB  004f(FP0EXP)               GET EXPONENT OF FPA0
ef13 27 3d                        BEQ  LBD09                      ZERO MANTISSA IF FPA0 = 0
ef15 c0 a0                        SUBB #$A0                       SUBTRACT $A0 FROM FPA0 EXPONENT T THIS WILL YIELD
                        *                             THE NUMBER OF SHIFTS REQUIRED TO DENORMALIZE FPA0. WHEN
                        *                             THE EXPONENT OF FPA0 IS = ZERO, THEN THE BINARY POINT
                        *                             WILL BE TO THE RIGHT OF THE MANTISSA
ef17 96 54                        LDA  0054(FP0SGN)               TEST SIGN OF FPA0 MANTISSA
ef19 2a 05                        BPL  LBCD7                      BRANCH IF POSITIVE
ef1b 03 5b                        COM  005b(FPCARY)               COMPLEMENT CARRY IN BYTE
ef1d bd ec c4                     JSR  ecc4(LBA7B)                NEGATE MANTISSA OF FPA0
ef20 8e 00 4f           LBCD7     LDX  #004f(FP0EXP)              POINT X TO FPA0
ef23 c1 f8                        CMPB #-8                        EXPONENT DIFFERENCE < -8?
ef25 2e 06                        BGT  LBCE4                      YES
ef27 bd ec f7                     JSR  ecf7(LBAAE)                SHIFT FPA0 RIGHT UNTIL FPA0 EXPONENT = $A0
ef2a 0f 5b                        CLR  005b(FPCARY)               CLEAR CARRY IN BYTE
ef2c 39                           RTS
ef2d 0f 5b              LBCE4     CLR  005b(FPCARY)               CLEAR CARRY IN BYTE
ef2f 96 54                        LDA  0054(FP0SGN)               * GET SIGN OF FPA0 MANTISSA
ef31 49                           ROLA                            * ROTATE IT INTO THE CARRY FLAG
ef32 06 50                        ROR  0050(FPA0)                 ROTATE CARRY (MANTISSA SIGN) INTO BIT 7
                        *                             OF LS BYTE OF MANTISSA
ef34 7e ed 03                     JMP  ed03(LBABA)                DE-NORMALIZE FPA0

                        * INT
                        * THE INT STATEMENT WILL "DENORMALIZE" FPA0 - THAT IS IT WILL SHIFT THE BINARY POINT
                        * TO THE EXTREME RIGHT OF THE MANTISSA TO FORCE ITS EXPONENT TO BE $AO. ONCE
                        * THIS IS DONE THE MANTISSA OF FPA0 WILL CONTAIN THE FOUR LEAST SIGNIFICANT
                        * BYTES OF THE INTEGER PORTION OF FPA0. AT THE CONCLUSION OF THE DE-NORMALIZATION
                        * ONLY THE INTEGER PORTION OF FPA0 WILL REMAIN.
                        *
ef37 d6 4f              INT       LDB  004f(FP0EXP)               GET EXPONENT OF FPA0
ef39 c1 a0                        CMPB #$A0                       LARGEST POSSIBLE INTEGER EXPONENT
ef3b 24 1d                        BCC  LBD11                      RETURN IF FPA0 >= 32768
ef3d 8d d2                        BSR  ef11(LBCC8)                SHIFT THE BINARY POINT ONE TO THE RIGHT OF THE
                        *                             LS BYTE OF THE FPA0 MANTISSA
ef3f d7 63                        STB  0063(FPSBYT)               ACCB = 0: ZERO OUT THE SUB BYTE
ef41 96 54                        LDA  0054(FP0SGN)               GET MANTISSA SIGN
ef43 d7 54                        STB  0054(FP0SGN)               FORCE MANTISSA SIGN TO BE POSITIVE
ef45 80 80                        SUBA #$80                       SET CARRY IF MANTISSA
ef47 86 a0                        LDA  #$A0                       * GET DENORMALIZED EXPONENT AND
ef49 97 4f                        STA  004f(FP0EXP)               * SAVE IT IN FPA0 EXPONENT
ef4b 96 53                        LDA  0050(FPA0)+3               = GET LS BYTE OF FPA0 AND
ef4d 97 01                        STA  0001(CHARAC)               = SAVE IT IN CHARAC
ef4f 7e ec 61                     JMP  ec61(LBA18)                NORMALIZE FPA0

ef52 d7 50              LBD09     STB  0050(FPA0)                 * LOAD MANTISSA OF FPA0 WITH CONTENTS OF ACCB
ef54 d7 51                        STB  0050(FPA0)+1               *
ef56 d7 52                        STB  0050(FPA0)+2               *
ef58 d7 53                        STB  0050(FPA0)+3               *
ef5a 39                 LBD11     RTS                             *

                        * CONVERT ASCII STRING TO FLOATING POINT
ef5b 9e 74              LBD12     LDX  0074(ZERO)                 (X) = 0
ef5d 9f 54                        STX  0054(FP0SGN)               * ZERO OUT FPA0 & THE SIGN FLAG (COEFCT)
ef5f 9f 4f                        STX  004f(FP0EXP)               *
ef61 9f 51                        STX  0050(FPA0)+1               *
ef63 9f 52                        STX  0050(FPA0)+2               *
ef65 9f 47                        STX  0047(V47)                  INITIALIZE EXPONENT & EXPONENT SIGN FLAG TO ZERO
ef67 9f 45                        STX  0045(V45)                  INITIALIZE RIGHT DECIMAL CTR & DECIMAL PT FLAG TO 0
ef69 25 64                        BCS  LBD86                      IF CARRY SET (NUMERIC CHARACTER), ASSUME ACCA CONTAINS FIRST
                        *         NUMERIC CHAR, SIGN IS POSITIVE AND SKIP THE RAM HOOK
ef6b bd f6 98                     JSR  XVEC19                     CALL EXTENDED BASIC ADD-IN
ef6e 81 2d              LBD25     CMPA #'-                        * CHECK FOR A LEADING MINUS SIGN AND BRANCH
ef70 26 04                        BNE  LBD2D                      * IF NO MINUS SIGN
ef72 03 55                        COM  0055(COEFCT)               TOGGLE SIGN; 0 = +; FF = -
ef74 20 04                        BRA  LBD31                      INTERPRET THE REST OF THE STRING
ef76 81 2b              LBD2D     CMPA #'+                        * CHECK FOR LEADING PLUS SlGN AND BRANCH
ef78 26 04                        BNE  LBD35                      * IF NOT A PLUS SIGN
ef7a 9d 7c              LBD31     JSR  007c(GETNCH)               GET NEXT INPUT CHARACTER FROM BASIC
ef7c 25 51                        BCS  LBD86                      BRANCH IF NUMERIC CHARACTER
ef7e 81 2e              LBD35     CMPA #'.                        DECIMAL POlNT?
ef80 27 28                        BEQ  LBD61                      YES
ef82 81 45                        CMPA #'E                        "E" SHORTHAND FORM (SCIENTIFIC NOTATION)?
ef84 26 28                        BNE  LBD65                      NO
                        * EVALUATE EXPONENT OF EXPONENTIAL FORMAT
ef86 9d 7c                        JSR  007c(GETNCH)               GET NEXT INPUT CHARACTER FROM BASIC
ef88 25 64                        BCS  LBDA5                      BRANCH IF NUMERIC
ef8a 81 a7                        CMPA #00a7(TOK_MINUS)           MINUS TOKEN?
ef8c 27 0e                        BEQ  LBD53                      YES
ef8e 81 2d                        CMPA #'-                        ASCII MINUS?
ef90 27 0a                        BEQ  LBD53                      YES
ef92 81 a6                        CMPA #00a6(TOK_PLUS)            PLUS TOKEN?
ef94 27 08                        BEQ  LBD55                      YES
ef96 81 2b                        CMPA #'+                        ASCII PLUS?
ef98 27 04                        BEQ  LBD55                      YES
ef9a 20 06                        BRA  LBD59                      BRANCH IF NO SIGN FOUND
ef9c 03 48              LBD53     COM  0048(V48)                  SET EXPONENT SIGN FLAG TO NEGATIVE
                        * STRIP A DECIMAL NUMBER FROM BASIC LINE, CONVERT IT TO BINARY IN V47
ef9e 9d 7c              LBD55     JSR  007c(GETNCH)               GET NEXT INPUT CHARACTER FROM BASIC
efa0 25 4c                        BCS  LBDA5                      IF NUMERIC CHARACTER, CONVERT TO BINARY
efa2 0d 48              LBD59     TST  0048(V48)                  * CHECK EXPONENT SIGN FLAG
efa4 27 08                        BEQ  LBD65                      * AND BRANCH IF POSITIVE
efa6 00 47                        NEG  0047(V47)                  NEGATE VALUE OF EXPONENT
efa8 20 04                        BRA  LBD65
efaa 03 46              LBD61     COM  0046(V46)                  *TOGGLE DECIMAL PT FLAG AND INTERPRET ANOTHER
efac 26 cc                        BNE  ef7a(LBD31)                *CHARACTER IF <> 0 - TERMINATE INTERPRETATION
                        *         IF   SECOND DECIMAL POINT
                        * ADJUST FPA0 FOR THE DECIMAL EXPONENT IN V47
efae 96 47              LBD65     LDA  0047(V47)                  * GET EXPONENT, SUBTRACT THE NUMBER OF
efb0 90 45                        SUBA 0045(V45)                  * PLACES TO THE RIGHT OF DECIMAL POINT
efb2 97 47                        STA  0047(V47)                  * AND RESAVE IT.
efb4 27 12                        BEQ  LBD7F                      EXIT ROUTINE IF ADJUSTED EXPONENT = ZERO
efb6 2a 09                        BPL  LBD78                      BRANCH IF POSITIVE EXPONENT
efb8 bd ed cb           LBD6F     JSR  edcb(LBB82)                DIVIDE FPA0 BY 10
efbb 0c 47                        INC  0047(V47)                  INCREMENT EXPONENT COUNTER (MULTIPLY BY 10)
efbd 26 f9                        BNE  efb8(LBD6F)                KEEP MULTIPLYING
efbf 20 07                        BRA  LBD7F                      EXIT ROUTINE
efc1 bd ed b3           LBD78     JSR  edb3(LBB6A)                MULTIPLY FPA0 BY 10
efc4 0a 47                        DEC  0047(V47)                  DECREMENT EXPONENT COUNTER (DIVIDE BY 10)
efc6 26 f9                        BNE  efc1(LBD78)                KEEP MULTIPLYING
efc8 96 55              LBD7F     LDA  0055(COEFCT)               GET THE SIGN FLAG
efca 2a 8e                        BPL  ef5a(LBD11)                RETURN IF POSITIVE
efcc 7e f1 32                     JMP  LBEE9                      TOGGLE MANTISSA SIGN OF FPA0, IF NEGATIVE
                        *MULTIPLY FPA0 BY TEN AND ADD ACCA TO THE RESULT
efcf d6 45              LBD86     LDB  0045(V45)                  *GET THE RIGHT DECIMAL COUNTER AND SUBTRACT
efd1 d0 46                        SUBB 0046(V46)                  *THE DECIMAL POINT FLAG FROM IT. IF DECIMAL POINT
efd3 d7 45                        STB  0045(V45)                  *FLAG=0, NOTHING HAPPENS. IF DECIMAL POINT FLAG IS
                        *                             -1, THEN RIGHT DECIMAL COUNTER IS INCREMENTED BY ONE
efd5 34 02                        PSHS A                          SAVE NEW DIGIT ON STACK
efd7 bd ed b3                     JSR  edb3(LBB6A)                MULTIPLY FPA0 BY 10
efda 35 04                        PULS B                          GET NEW DIGIT BACK
efdc c0 30                        SUBB #'0                        MASK OFF ASCII
efde 8d 02                        BSR  LBD99                      ADD ACCB TO FPA0
efe0 20 98                        BRA  ef7a(LBD31)                GET ANOTHER CHARACTER FROM BASIC
efe2 bd ee 78           LBD99     JSR  ee78(LBC2F)                PACK FPA0 AND SAVE IT IN FPA3
efe5 bd ee c5                     JSR  eec5(LBC7C)                CONVERT ACCB TO FP NUMBER IN FPA0
efe8 8e 00 40                     LDX  #0040(V40)                 * ADD FPA0 TO
efeb 7e ec 0b                     JMP  ec0b(LB9C2)                * FPA3


efee d6 47              LBDA5     LDB  0047(V47)
eff0 58                           ASLB                            TIMES 2
eff1 58                           ASLB                            TIMES 4
eff2 db 47                        ADDB 0047(V47)                  ADD 1 = TIMES 5
eff4 58                           ASLB                            TIMES 10
eff5 80 30                        SUBA #'0                        *MASK OFF ASCII FROM ACCA, PUSH
eff7 34 04                        PSHS B                          *RESULT ONTO THE STACK AND
eff9 ab e0                        ADDA ,S+                        ADD lT TO ACCB
effb 97 47                        STA  0047(V47)                  SAVE IN V47
effd 20 9f                        BRA  ef9e(LBD55)                INTERPRET ANOTHER CHARACTER
                        *
efff 9b 3e bc 1f fd     LBDB6     FCB  $9B,$3E,$BC,$1F            ,$FD * 99999999.9
f004 9e 6e 6b 27 fd     LBDBB     FCB  $9E,$6E,$6B,$27            ,$FD * 999999999
f009 9e 6e 6b 28 00     LBDC0     FCB  $9E,$6E,$6B,$28            ,$00 * 1E + 09
                        *
f00e 8e de a4           LBDC5     LDX  #dea5(LABE8)-1             POINT X TO " IN " MESSAGE
f011 8d 0c                        BSR  LBDD6                      COPY A STRING FROM (X) TO CONSOLE OUT
f013 dc 68                        LDD  0068(CURLIN)               GET CURRENT BASIC LINE NUMBER TO ACCD
                        * CONVERT VALUE IN ACCD INTO A DECIMAL NUMBER
                        * AND PRINT IT TO CONSOLE OUT
f015 dd 50              LBDCC     STD  0050(FPA0)                 SAVE ACCD IN TOP HALF OF FPA0
f017 c6 90                        LDB  #$90                       REQ'D EXPONENT IF TOP HALF OF ACCD = INTEGER
f019 43                           COMA                            SET CARRY FLAG - FORCE POSITIVE MANTISSA
f01a bd ee cf                     JSR  eecf(LBC86)                ZERO BOTTOM HALF AND SIGN OF FPA0, THEN
                        *         SAVE EXPONENT AND NORMALIZE IT
f01d 8d 03                        BSR  LBDD9                      CONVERT FP NUMBER TO ASCII STRING
f01f 7e eb e5           LBDD6     JMP  ebe5(LB99C)                COPY A STRING FROM (X) TO CONSOLE OUT

                        * CONVERT FP NUMBER TO ASCII STRING
f022 ce 01 f1           LBDD9     LDU  #01ee(STRBUF)+3            POINT U TO BUFFER WHICH WILL NOT CAUSE
                        *                             THE STRING TO BE STORED IN STRING SPACE
f025 86 20              LBDDC     LDA  #0020(SPACE)               SPACE = DEFAULT SIGN FOR POSITIVE #
f027 d6 54                        LDB  0054(FP0SGN)               GET SIGN OF FPA0
f029 2a 02                        BPL  LBDE4                      BRANCH IF POSITIVE
f02b 86 2d                        LDA  #'-                        ASCII MINUS SIGN
f02d a7 c0              LBDE4     STA  ,U+                        STORE SIGN OF NUMBER
f02f df 64                        STU  0064(COEFPT)               SAVE BUFFER POINTER
f031 97 54                        STA  0054(FP0SGN)               SAVE SIGN (IN ASCII)
f033 86 30                        LDA  #'0                        ASCII ZERO IF EXPONENT = 0
f035 d6 4f                        LDB  004f(FP0EXP)               GET FPA0 EXPONENT
f037 10 27 00 c6                  LBEQ LBEB8                      BRANCH IF FPA0 = 0
f03b 4f                           CLRA                            BASE 10 EXPONENT=0 FOR FP NUMBER > 1
f03c c1 80                        CMPB #$80                       CHECK EXPONENT
f03e 22 08                        BHI  LBDFF                      BRANCH IF FP NUMBER > 1
                        * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 TO SPEED UP THE CONVERSION PROCESS
f040 8e f0 09                     LDX  #f009(LBDC0)               POINT X TO FP 1E+09
f043 bd ed 13                     JSR  ed13(LBACA)                MULTIPLY FPA0 BY (X)
f046 86 f7                        LDA  #-9                        BASE 10 EXPONENT = -9
f048 97 45              LBDFF     STA  0045(V45)                  BASE 10 EXPONENT
                        * PSEUDO - NORMALIZE THE FP NUMBER TO A VALUE IN THE RANGE
                        * OF 999,999,999 RO 99,999,999.9 - THIS IS THE LARGEST
                        * NUMBER RANGE IN WHICH ALL OF THE DIGITS ARE
                        * SIGNIFICANT WHICH CAN BE DISPLAYED WITHOUT USING
                        * SCIENTIFIC NOTATION
f04a 8e f0 04           LBE01     LDX  #f004(LBDBB)               POINT X TO FP 999,999,999
f04d bd ee e9                     JSR  eee9(LBCA0)                COMPARE FPA0 TO 999,999,999
f050 2e 0f                        BGT  LBE18                      BRANCH IF > 999,999,999
f052 8e ef ff           LBE09     LDX  #efff(LBDB6)               POINT X TO FP 99,999,999.9
f055 bd ee e9                     JSR  eee9(LBCA0)                COMPARE FPA0 TO 99,999,999.9
f058 2e 0e                        BGT  LBE1F                      BRANCH IF > 99,999,999.9 (IN RANGE)
f05a bd ed b3                     JSR  edb3(LBB6A)                MULTIPLY FPA0 BY 10
f05d 0a 45                        DEC  0045(V45)                  SUBTRACT ONE FROM DECIMAL OFFSET
f05f 20 f1                        BRA  f052(LBE09)                PSEUDO - NORMALIZE SOME MORE
f061 bd ed cb           LBE18     JSR  edcb(LBB82)                DIVIDE FPA0 BY 10
f064 0c 45                        INC  0045(V45)                  ADD ONE TO BASE 10 EXPONENT
f066 20 e2                        BRA  f04a(LBE01)                PSEUDO - NORMALIZE SOME MORE
f068 bd eb fd           LBE1F     JSR  ebfd(LB9B4)                ADD .5 TO FPA0 (ROUND OFF)
f06b bd ef 11                     JSR  ef11(LBCC8)                CONVERT FPA0 TO AN INTEGER
f06e c6 01                        LDB  #1                         DEFAULT DECIMAL POINT FLAG (FORCE IMMED DECIMAL PT)
f070 96 45                        LDA  0045(V45)                  * GET BASE 10 EXPONENT AND ADD TEN TO IT
f072 8b 0a                        ADDA #9+1                       * (NUMBER 'NORMALIZED' TO 9 PLACES & DECIMAL PT)
f074 2b 09                        BMI  LBE36                      BRANCH IF NUMBER < 1.0
f076 81 0b                        CMPA #9+2                       NINE PLACES MAY BE DISPLAYED WITHOUT
                        *         USING SCIENTIFIC NOTATION
f078 24 05                        BCC  LBE36                      BRANCH IF SCIENTIFIC NOTATION REQUIRED
f07a 4a                           DECA                            * SUBTRACT 1 FROM MODIFIED BASE 10 EXPONENT CTR
f07b 1f 89                        TFR  A,B                        * AND SAVE IT IN ACCB (DECiMAL POINT FLAG)
f07d 86 02                        LDA  #2                         FORCE EXPONENT = 0 - DON'T USE SCIENTIFIC NOTATION
f07f 4a                 LBE36     DECA                            * SUBTRACT TWO (WITHOUT AFFECTING CARRY)
f080 4a                           DECA                            * FROM BASE 10 EXPONENT
f081 97 47                        STA  0047(V47)                  SAVE EXPONENT - ZERO EXPONENT = DO NOT DISPLAY
                        *         IN   SCIENTIFIC NOTATION
f083 d7 45                        STB  0045(V45)                  DECIMAL POINT FLAG - NUMBER OF PLACES TO
                        *         LEFT OF DECIMAL POINT
f085 2e 0d                        BGT  LBE4B                      BRANCH IF >= 1
f087 de 64                        LDU  0064(COEFPT)               POINT U TO THE STRING BUFFER
f089 86 2e                        LDA  #'.                        * STORE A PERIOD
f08b a7 c0                        STA  ,U+                        * IN THE BUFFER
f08d 5d                           TSTB CHECK DECIMAL P            OINT FLAG
f08e 27 04                        BEQ  LBE4B                      BRANCH IF NOTHING TO LEFT OF DECIMAL POINT
f090 86 30                        LDA  #'0                        * STORE A ZERO
f092 a7 c0                        STA  ,U+                        * IN THE BUFFER

                        * CONVERT FPA0 INTO A STRING OF ASCII DIGITS
f094 8e f1 0e           LBE4B     LDX  #LBEC5                     POINT X TO FP POWER OF 10 MANTISSA
f097 c6 80                        LDB  #0+$80                     INITIALIZE DIGIT COUNTER TO 0+$80
                        * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA
                        * IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSA, IT IS
                        * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB IS HOW
                        * THE ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURING.
f099 96 53              LBE50     LDA  0050(FPA0)+3               * ADD MANTISSA LS
f09b ab 03                        ADDA 3,X                        * BYTE OF FPA0
f09d 97 53                        STA  0050(FPA0)+3               * AND (X)
f09f 96 52                        LDA  0050(FPA0)+2               = ADD MANTISSA
f0a1 a9 02                        ADCA 2,X                        = NUMBER 3 BYTE OF
f0a3 97 52                        STA  0050(FPA0)+2               = FPA0 AND (X)
f0a5 96 51                        LDA  0050(FPA0)+1               * ADD MANTISSA
f0a7 a9 01                        ADCA 1,X                        * NUMBER 2 BYTE OF
f0a9 97 51                        STA  0050(FPA0)+1               * FPA0 AND (X)
f0ab 96 50                        LDA  0050(FPA0)                 = ADD MANTISSA
f0ad a9 84                        ADCA ,X                         = MS BYTE OF
f0af 97 50                        STA  0050(FPA0)                 = FPA0 AND (X)
f0b1 5c                           INCB                            ADD ONE TO DIGIT COUNTER
f0b2 56                           RORB ROTATE CARRY IN            TO BIT 7
f0b3 59                           ROLB                            *SET OVERFLOW FLAG AND BRANCH IF CARRY = 1 AND
f0b4 28 e3                        BVC  f099(LBE50)                *POSITIVE MANTISSA OR CARRY = 0 AND NEG MANTISSA
f0b6 24 03                        BCC  LBE72                      BRANCH IF NEGATIVE MANTISSA
f0b8 c0 0b                        SUBB #10+1                      * TAKE THE 9'S COMPLEMENT IF
f0ba 50                           NEGB                            * ADDING MANTISSA
f0bb cb 2f              LBE72     ADDB #'0-1                      ADD ASCII OFFSET TO DIGIT
f0bd 30 04                        LEAX 4,X                        MOVE TO NEXT POWER OF 10 MANTISSA
f0bf 1f 98                        TFR  B,A                        SAVE DIGIT IN ACCA
f0c1 84 7f                        ANDA #$7F                       MASK OFF BIT 7 (ADD/SUBTRACT FLAG)
f0c3 a7 c0                        STA  ,U+                        STORE DIGIT IN STRING BUFFER
f0c5 0a 45                        DEC  0045(V45)                  DECREMENT DECIMAL POINT FLAG
f0c7 26 04                        BNE  LBE84                      BRANCH IF NOT TIME FOR DECIMAL POINT
f0c9 86 2e                        LDA  #'.                        * STORE DECIMAL POINT IN
f0cb a7 c0                        STA  ,U+                        * STRING BUFFER
f0cd 53                 LBE84     COMB                            TOGGLE BIT 7 (ADD/SUBTRACT FLAG)
f0ce c4 80                        ANDB #$80                       MASK OFF ALL BUT ADD/SUBTRACT FLAG
f0d0 8c f1 32                     CMPX #LBEC5+36                  COMPARE X TO END OF MANTISSA TABLE
f0d3 26 c4                        BNE  f099(LBE50)                BRANCH IF NOT AT END OF TABLE
                        * BLANK TRAILING ZEROS AND STORE EXPONENT IF ANY
f0d5 a6 c2              LBE8C     LDA  ,-U                        GET THE LAST CHARACTER; MOVE POINTER BACK
f0d7 81 30                        CMPA #'0                        WAS IT A ZERO?
f0d9 27 fa                        BEQ  f0d5(LBE8C)                IGNORE TRAILING ZEROS IF SO
f0db 81 2e                        CMPA #'.                        CHECK FOR DECIMAL POINT
f0dd 26 02                        BNE  LBE98                      BRANCH IF NOT DECIMAL POINT
f0df 33 5f                        LEAU -1,U                       STEP OVER THE DECIMAL POINT
f0e1 86 2b              LBE98     LDA  #'+                        ASCII PLUS SIGN
f0e3 d6 47                        LDB  0047(V47)                  GET SCIENTIFIC NOTATION EXPONENT
f0e5 27 1c                        BEQ  LBEBA                      BRANCH IF NOT SCIENTIFIC NOTATION
f0e7 2a 03                        BPL  LBEA3                      BRANCH IF POSITIVE EXPONENT
f0e9 86 2d                        LDA  #'-                        ASCII MINUS SIGN
f0eb 50                           NEGB                            NEGATE EXPONENT IF NEGATIVE
f0ec a7 42              LBEA3     STA  2,U                        STORE EXPONENT SIGN IN STRING
f0ee 86 45                        LDA  #'E                        * GET ASCII 'E' (SCIENTIFIC NOTATION
f0f0 a7 41                        STA  1,U                        * FLAG) AND SAVE IT IN THE STRING
f0f2 86 2f                        LDA  #'0-1                      INITIALIZE ACCA TO ASCII ZERO


f0f4 4c                 LBEAB     INCA                            ADD ONE TO 10'S DIGIT OF EXPONENT
f0f5 c0 0a                        SUBB #10                        SUBTRACT 10 FROM ACCB
f0f7 24 fb                        BCC  f0f4(LBEAB)                ADD 1 TO 10'S DIGIT IF NO CARRY
f0f9 cb 3a                        ADDB #'9+1                      CONVERT UNITS DIGIT TO ASCII
f0fb ed 43                        STD  3,U                        SAVE EXPONENT IN STRING
f0fd 6f 45                        CLR  5,U                        CLEAR LAST BYTE (TERMINATOR)
f0ff 20 04                        BRA  LBEBC                      GO RESET POINTER
f101 a7 c4              LBEB8     STA  ,U                         STORE LAST CHARACTER
f103 6f 41              LBEBA     CLR  1,U                        CLEAR LAST BYTE (TERMINATOR - REQUIRED BY
                        *         PRINT SUBROUTINES)
f105 8e 01 f1           LBEBC     LDX  #01ee(STRBUF)+3            RESET POINTER TO START OF BUFFER
f108 39                           RTS
                        *
f109 80 00 00 00 00     LBEC0     FCB  $80,$00,$00,$00            ,$00 FLOATING POINT .5
                        *
                        *** TABLE OF UNNORMALIZED POWERS OF 10
f10e fa 0a 1f 00        LBEC5     FCB  $FA,$0A,$1F,$00             -100000000
f112 00 98 96 80        LBEC9     FCB  $00,$98,$96,$80             10000000
f116 ff f0 bd c0        LBECD     FCB  $FF,$F0,$BD,$C0             -1000000
f11a 00 01 86 a0        LBED1     FCB  $00,$01,$86,$A0             100000
f11e ff ff d8 f0        LBED5     FCB  $FF,$FF,$D8,$F0             -10000
f122 00 00 03 e8        LBED9     FCB  $00,$00,$03,$E8             1000
f126 ff ff ff 9c        LBEDD     FCB  $FF,$FF,$FF,$9C             -100
f12a 00 00 00 0a        LBEE1     FCB  $00,$00,$00,$0A             10
f12e ff ff ff ff        LBEE5     FCB  $FF,$FF,$FF,$FF             -1
                        *
                        *
f132 96 4f              LBEE9     LDA  004f(FP0EXP)               GET EXPONENT OF FPA0
f134 27 02                        BEQ  LBEEF                      BRANCH IF FPA0 = 0
f136 03 54                        COM  0054(FP0SGN)               TOGGLE MANTISSA SIGN OF FPA0
f138 39                 LBEEF     RTS
                        * EXPAND A POLYNOMIAL OF THE FORM
                        * AQ+BQ**3+CQ**5+DQ**7.... WHERE Q = FPA0
                        * AND THE X REGISTER POINTS TO A TABLE OF
                        * COEFFICIENTS A,B,C,D....
f139 9f 64              LBEF0     STX  0064(COEFPT)               SAVE COEFFICIENT TABLE POINTER
f13b bd ee 78                     JSR  ee78(LBC2F)                MOVE FPA0 TO FPA3
f13e 8d 05                        BSR  LBEFC                      MULTIPLY FPA3 BY FPA0
f140 8d 08                        BSR  LBF01                      EXPAND POLYNOMIAL
f142 8e 00 40                     LDX  #0040(V40)                 POINT X TO FPA3
f145 7e ed 13           LBEFC     JMP  ed13(LBACA)                MULTIPLY (X) BY FPA0

                        * CALCULATE THE VALUE OF AN EXPANDED POLYNOMIAL
                        * EXPRESSION. ENTER WITH (X) POINTING TO A TABLE
                        * OF COEFFICIENTS, THE FIRST BYTE OF WHICH IS THE
                        * NUMBER OF (COEFFICIENTS-1) FOLLOWED BY THAT NUMBER
                        * OF PACKED FLOATING POINT NUMBERS. THE
                        * POLYNOMIAL IS EVALUATED AS FOLLOWS: VALUE =
                        * (((FPA0*Y0+Y1)*FPA0+Y2)*FPA0YN)
f148 9f 64              LBEFF     STX  0064(COEFPT)               SAVE COEFFICIENT TABLE POINTER
f14a bd ee 73           LBF01     JSR  ee73(LBC2A)                MOVE FPA0 TO FPA4
f14d 9e 64                        LDX  0064(COEFPT)               GET THE COEFFICIENT POINTER
f14f e6 80                        LDB  ,X+                        GET THE TOP OF COEFFICIENT TABLE TO
f151 d7 55                        STB  0055(COEFCT)               * USE AND STORE IT IN TEMPORARY COUNTER
f153 9f 64                        STX  0064(COEFPT)               SAVE NEW COEFFICIENT POINTER
f155 8d ee              LBF0C     BSR  f145(LBEFC)                MULTIPLY (X) BY FPA0
f157 9e 64                        LDX  0064(COEFPT)               *GET COEFFICIENT POINTER
f159 30 05                        LEAX 5,X                        *MOVE TO NEXT FP NUMBER
f15b 9f 64                        STX  0064(COEFPT)               *SAVE NEW COEFFICIENT POINTER
f15d bd ec 0b                     JSR  ec0b(LB9C2)                ADD (X) AND FPA0
f160 8e 00 45                     LDX  #0045(V45)                 POINT (X) TO FPA4
f163 0a 55                        DEC  0055(COEFCT)               DECREMENT TEMP COUNTER
f165 26 ee                        BNE  f155(LBF0C)                BRANCH IF MORE COEFFICIENTS LEFT
f167 39                           RTS

                        * RND
f168 bd ee b6           RND       JSR  eeb6(LBC6D)                TEST FPA0
f16b 2b 1f                        BMI  LBF45                      BRANCH IF FPA0 = NEGATIVE
f16d 27 15                        BEQ  LBF3B                      BRANCH IF FPA0 = 0
f16f 8d 10                        BSR  LBF38                      CONVERT FPA0 TO AN INTEGER
f171 bd ee 78                     JSR  ee78(LBC2F)                PACK FPA0 TO FPA3
f174 8d 0e                        BSR  LBF3B                      GET A RANDOM NUMBER: FPA0 < 1.0
f176 8e 00 40                     LDX  #0040(V40)                 POINT (X) TO FPA3
f179 8d ca                        BSR  f145(LBEFC)                MULTIPLY (X) BY FPA0
f17b 8e ed 0e                     LDX  #ed0e(LBAC5)               POINT (X) TO FP VALUE OF 1.0
f17e bd ec 0b                     JSR  ec0b(LB9C2)                ADD 1.0 TO FPA0
f181 7e ef 37           LBF38     JMP  ef37(INT)                  CONVERT FPA0 TO AN INTEGER
                        * CALCULATE A RANDOM NUMBER IN THE RANGE 0.0 < X <= 1.0
f184 9e b1              LBF3B     LDX  00b0(RVSEED)+1             * MOVE VARIABLE
f186 9f 50                        STX  0050(FPA0)                 * RANDOM NUMBER
f188 9e b3                        LDX  00b0(RVSEED)+3             * SEED TO
f18a 9f 52                        STX  0050(FPA0)+2               * FPA0
f18c be f1 b9           LBF45     LDX  RSEED                      = MOVE FIXED
f18f 9f 5d                        STX  005d(FPA1)                 = RANDOM NUMBER
f191 be f1 bb                     LDX  RSEED+2                    = SEED TO
f194 9f 5f                        STX  005d(FPA1)+2               = MANTISSA OF FPA0
f196 bd ed 19                     JSR  ed19(LBAD0)                MULTIPLY FPA0 X FPA1
f199 dc 8a                        LDD  008a(VAD)                  GET THE TWO LOWEST ORDER PRODUCT BYTES
f19b c3 65 8b                     ADDD #$658B                     ADD A CONSTANT
f19e dd b3                        STD  00b0(RVSEED)+3             SAVE NEW LOW ORDER VARIABLE RANDOM # SEED
f1a0 dd 52                        STD  0050(FPA0)+2               SAVE NEW LOW ORDER BYTES OF FPA0 MANTISSA
f1a2 dc 88                        LDD  0088(VAB)                  GET 2 MORE LOW ORDER PRODUCT BYTES
f1a4 c9 b0                        ADCB #$B0                       ADD A CONSTANT
f1a6 89 05                        ADCA #5                         ADD A CONSTANT
f1a8 dd b1                        STD  00b0(RVSEED)+1             SAVE NEW HIGH ORDER VARIABLE RANDOM # SEED
f1aa dd 50                        STD  0050(FPA0)                 SAVE NEW HIGH ORDER FPA0 MANTISSA
f1ac 0f 54                        CLR  0054(FP0SGN)               FORCE FPA0 MANTISSA = POSITIVE
f1ae 86 80                        LDA  #$80                       * SET FPA0 BIASED EXPONENT
f1b0 97 4f                        STA  004f(FP0EXP)               * TO 0 1 < FPA0 < 0
f1b2 96 15                        LDA  0013(FPA2)+2               GET A BYTE FROM FPA2 (MORE RANDOMNESS)
f1b4 97 63                        STA  0063(FPSBYT)               SAVE AS SUB BYTE
f1b6 7e ec 65                     JMP  ec65(LBA1C)                NORMALIZE FPA0
                        *
f1b9 40 e6              RSEED     FDB  $40E6                      *CONSTANT RANDOM NUMBER GENERATOR SEED
f1bb 4d ab                        FDB  $4DAB                      *

                        * SIN
                        * THE SIN FUNCTION REQUIRES AN ARGUMENT IN RADIANS AND WILL REPEAT ITSELF EVERY
                        * 2*PI RADIANS. THE ARGUMENT IS DIVIDED BY 2*PI AND ONLY THE FRACTIONAL PART IS
                        * RETAINED. SINCE THE ARGUMENT WAS DIVIDED BY 2*P1, THE COEFFICIENTS MUST BE
                        * MULTIPLIED BY THE APPROPRIATE POWER OF 2*PI.

                        * SIN IS EVALUATED USING THE TRIGONOMETRIC IDENTITIES BELOW:
                        * SIN(X)=SIN(PI-X) & -SIN(PI/2-X)=SIN((3*PI)/2+X)
f1bd bd ee a8           SIN       JSR  eea8(LBC5F)                COPY FPA0 TO FPA1
f1c0 8e f2 02                     LDX  #LBFBD                     POINT (X) TO 2*PI
f1c3 d6 61                        LDB  0061(FP1SGN)               *GET MANTISSA SIGN OF FPA1
f1c5 bd ed d2                     JSR  edd2(LBB89)                *AND DIVIDE FPA0 BY 2*PI
f1c8 bd ee a8                     JSR  eea8(LBC5F)                COPY FPA0 TO FPA1
f1cb 8d b4                        BSR  f181(LBF38)                CONVERT FPA0 TO AN INTEGER
f1cd 0f 62                        CLR  0062(RESSGN)               SET RESULT SIGN = POSITIVE
f1cf 96 5c                        LDA  005c(FP1EXP)               *GET EXPONENT OF FPA1
f1d1 d6 4f                        LDB  004f(FP0EXP)               *GET EXPONENT OF FPA0
f1d3 bd ec 05                     JSR  ec05(LB9BC)                *SUBTRACT FPA0 FROM FPA1
                        * NOW FPA0 CONTAINS ONLY THE FRACTIONAL PART OF ARGUMENT/2*PI
f1d6 8e f2 07                     LDX  #LBFC2                     POINT X TO FP (.25)
f1d9 bd ec 02                     JSR  ec02(LB9B9)                SUBTRACT FPA0 FROM .25 (PI/2)
f1dc 96 54                        LDA  0054(FP0SGN)               GET MANTISSA SIGN OF FPA0
f1de 34 02                        PSHS A                          SAVE IT ON STACK
f1e0 2a 09                        BPL  LBFA6                      BRANCH IF MANTISSA POSITIVE
f1e2 bd eb fd                     JSR  ebfd(LB9B4)                ADD .5 (PI) TO FPA0
f1e5 96 54                        LDA  0054(FP0SGN)               GET SIGN OF FPA0
f1e7 2b 05                        BMI  LBFA9                      BRANCH IF NEGATIVE
f1e9 03 0a                        COM  000a(RELFLG)               COM IF +(3*PI)/2 >= ARGUMENT >+ PI/2 (QUADRANT FLAG)
f1eb bd f1 32           LBFA6     JSR  f132(LBEE9)                TOGGLE MANTISSA SIGN OF FPA0
f1ee 8e f2 07           LBFA9     LDX  #LBFC2                     POINT X TO FP (.25)
f1f1 bd ec 0b                     JSR  ec0b(LB9C2)                ADD .25 (PI/2) TO FPA0
f1f4 35 02                        PULS A                          GET OLD MANTISSA SIGN
f1f6 4d                           TSTA                            * BRANCH IF OLD
f1f7 2a 03                        BPL  LBFB7                      * SIGN WAS POSITIVE
f1f9 bd f1 32                     JSR  f132(LBEE9)                TOGGLE MANTISSA SIGN
f1fc 8e f2 0c           LBFB7     LDX  #LBFC7                     POINT X TO TABLE OF COEFFICIENTS
f1ff 7e f1 39                     JMP  f139(LBEF0)                GO CALCULATE POLYNOMIAL VALUE

f202 83 49 0f da a2     LBFBD     FCB  $83,$49,$0F,$DA            ,$A2 6.28318531 (2*PI)
f207 7f 00 00 00 00     LBFC2     FCB  $7F,$00,$00,$00            ,$00 .25


f20c 05                 LBFC7     FCB  6-1                        SIX COEFFICIENTS
f20d 84 e6 1a 2d 1b     LBFC8     FCB  $84,$E6,$1A,$2D            ,$1B * -((2*PI)**11)/11!
f212 86 28 07 fb f8     LBFCD     FCB  $86,$28,$07,$FB            ,$F8 * ((2*PI)**9)/9!
f217 87 99 68 89 01     LBFD2     FCB  $87,$99,$68,$89            ,$01 * -((2*PI)**7)/7!
f21c 87 23 35 df e1     LBFD7     FCB  $87,$23,$35,$DF            ,$E1 * ((2*PI)**5)/5!
f221 86 a5 5d e7 28     LBFDC     FCB  $86,$A5,$5D,$E7            ,$28 * -((2*PI)**3)/3!
f226 83 49 0f da a2     LBFE1     FCB  $83,$49,$0F,$DA            ,$A2 *

f22b a1 54 46 8f 13               FCB  $A1,$54,$46,$8F            ,$13 UNUSED GARBAGE BYTES
f230 8f 52 43 89 cd               FCB  $8F,$52,$43,$89            ,$CD UNUSED GARBAGE BYTES
                        * EXTENDED BASIC

                        * COS
                        * THE VALUE OF COS(X) IS DETERMINED BY THE TRIG IDENTITY COS(X)=SIN((PI/2)+X)
f235 8e f2 68           COS       LDX  #L83AB                     POINT X TO FP CONSTANT (P1/2)
f238 bd ec 0b                     JSR  ec0b(LB9C2)                ADD FPA0 TO (X)
f23b 7e f1 bd           L837E     JMP  f1bd(SIN)                  JUMP TO SIN ROUTINE

                        * TAN
                        * THE VALUE OF TAN(X) IS DETERMINED BY THE TRIG IDENTITY TAN(X)=SIN(X)/COS(X)
f23e bd ee 78           TAN       JSR  ee78(LBC2F)                PACK FPA0 AND MOVE IT TO FPA3
f241 0f 0a                        CLR  000a(RELFLG)               RESET QUADRANT FLAG
f243 8d f6                        BSR  f23b(L837E)                CALCULATE SIN OF ARGUMENT
f245 8e 00 4a                     LDX  #004a(V4A)                 POINT X TO FPA5
f248 bd ee 7e                     JSR  ee7e(LBC35)                PACK FPA0 AND MOVE IT TO FPA5
f24b 8e 00 40                     LDX  #0040(V40)                 POINT X TO FPA3
f24e bd ee 5d                     JSR  ee5d(LBC14)                MOVE FPA3 TO FPA0
f251 0f 54                        CLR  0054(FP0SGN)               FORCE FPA0 MANTISSA TO BE POSITIVE
f253 96 0a                        LDA  000a(RELFLG)               GET THE QUADRANT FLAG - COS NEGATIVE IN QUADS 2,3
f255 8d 0c                        BSR  L83A6                      CALCULATE VALUE OF COS(FPA0)
f257 0d 4f                        TST  004f(FP0EXP)               CHECK EXPONENT OF FPA0
f259 10 27 fa 7e                  LBEQ ecdb(LBA92)                'OV' ERROR IF COS(X)=0
f25d 8e 00 4a                     LDX  #004a(V4A)                 POINT X TO FPA5
f260 7e ed d8           L83A3     JMP  edd8(LBB8F)                DIVIDE (X) BY FPA0 - SIN(X)/COS(X)
f263 34 02              L83A6     PSHS A                          SAVE SIGN FLAG ON STACK
f265 7e f1 eb                     JMP  f1eb(LBFA6)                EXPAND POLYNOMIAL

f268 81 49 0f da a2     L83AB     FCB  $81,$49,$0F,$DA            ,$A2 1.57079633 (PI/2)

                        * ATN
                        * A 12 TERM TAYLOR SERIES IS USED TO EVALUATE THE
                        * ARCTAN EXPRESSION. TWO  DIFFERENT FORMULI ARE USED
                        * TO EVALUATE THE EXPRESSION DEPENDING UPON
                        * WHETHER OR NOT THE ARGUMENT SQUARED IS > OR < 1.0

                        * IF X**2<1 THEN ATN=X-(X**3)/3+(X**5)/5-(X**7)/7. . .
                        * IF X**2>=1 THEN ATN=PI/2-(1/X-1/((X**3)*3)+(1/((X**5)*5)-. . .)

f26d 96 54              ATN       LDA  0054(FP0SGN)               * GET THE SIGN OF THE MANTISSA AND
f26f 34 02                        PSHS A                          * SAVE IT ON THE STACK
f271 2a 02                        BPL  L83B8                      BRANCH IF POSITIVE MANTISSA
f273 8d 24                        BSR  L83DC                      CHANGE SIGN OF FPA0
f275 96 4f              L83B8     LDA  004f(FP0EXP)               * GET EXPONENT OF FPA0 AND
f277 34 02                        PSHS A                          * SAVE IT ON THE STACK
f279 81 81                        CMPA #$81                       IS FPAO < 1.0?
f27b 25 05                        BLO  L83C5                      YES
f27d 8e ed 0e                     LDX  #ed0e(LBAC5)               POINT X TO FP CONSTANT 1.0
f280 8d de                        BSR  f260(L83A3)                GET RECIPROCAL OF FPA0
f282 8e f2 9d           L83C5     LDX  #L83E0                     POINT (X) TO TAYLOR SERIES COEFFICIENTS
f285 bd f1 39                     JSR  f139(LBEF0)                EXPAND POLYNOMIAL
f288 35 02                        PULS A                          GET EXPONENT OF ARGUMENT
f28a 81 81                        CMPA #$81                       WAS ARGUMENT < 1.0?
f28c 25 06                        BLO  L83D7                      YES
f28e 8e f2 68                     LDX  #f268(L83AB)               POINT (X) TO FP NUMBER (PI/2)
f291 bd ec 02                     JSR  ec02(LB9B9)                SUBTRACT FPA0 FROM (PI/2)
f294 35 02              L83D7     PULS A                          * GET SIGN OF INITIAL ARGUMENT MANTISSA
f296 4d                           TSTA                            * AND SET FLAGS ACCORDING TO IT
f297 2a 03                        BPL  L83DF                      RETURN IF ARGUMENT WAS POSITIVE
f299 7e f1 32           L83DC     JMP  f132(LBEE9)                CHANGE MANTISSA SIGN OF FPA0
f29c 39                 L83DF     RTS
                        *
                        * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR ARCTANGENT
f29d 0b                 L83E0     FCB  $0B                        TWELVE COEFFICIENTS
f29e 76 b3 83 bd d3     L83E1     FCB  $76,$B3,$83,$BD            ,$D3 -6.84793912E-04 1/23
f2a3 79 1e f4 a6 f5     L83E6     FCB  $79,$1E,$F4,$A6            ,$F5 +4.85094216E-03 1/21
f2a8 7b 83 fc b0 10     L83EB     FCB  $7B,$83,$FC,$B0            ,$10 -0.0161117018
f2ad 7c 0c 1f 67 ca     L83F0     FCB  $7C,$0C,$1F,$67            ,$CA 0.0342096381
f2b2 7c de 53 cb c1     L83F5     FCB  $7C,$DE,$53,$CB            ,$C1 -0.0542791328
f2b7 7d 14 64 70 4c     L83FA     FCB  $7D,$14,$64,$70            ,$4C 0.0724571965
f2bc 7d b7 ea 51 7a     L83FF     FCB  $7D,$B7,$EA,$51            ,$7A -0.0898023954
f2c1 7d 63 30 88 7e     L8404     FCB  $7D,$63,$30,$88            ,$7E 0.110932413
f2c6 7e 92 44 99 3a     L8409     FCB  $7E,$92,$44,$99            ,$3A -0.142839808
f2cb 7e 4c cc 91 c7     L840E     FCB  $7E,$4C,$CC,$91            ,$C7 0.199999121
f2d0 7f aa aa aa 13     L8413     FCB  $7F,$AA,$AA,$AA            ,$13 -0.333333316
f2d5 81 00 00 00 00     L8418     FCB  $81,$00,$00,$00            ,$00 1
                        *
                        *** TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR LN(X)
                        *
f2da 03                 L841D     FCB  3                          FOUR COEFFICIENTS
f2db 7f 5e 56 cb 79     L841E     FCB  $7F,$5E,$56,$CB            ,$79 0.434255942
f2e0 80 13 9b 0b 64     L8423     FCB  $80,$13,$9B,$0B            ,$64 0.576584541
f2e5 80 76 38 93 16     L8428     FCB  $80,$76,$38,$93            ,$16 0.961800759
f2ea 82 38 aa 3b 20     L842D     FCB  $82,$38,$AA,$3B            ,$20 2.88539007

f2ef 80 35 04 f3 34     L8432     FCB  $80,$35,$04,$F3            ,$34 1/SQR(2)

f2f4 81 35 04 f3 34     L8437     FCB  $81,$35,$04,$F3            ,$34 SQR(2)

f2f9 80 80 00 00 00     L843C     FCB  $80,$80,$00,$00            ,$00 -0.5

f2fe 80 31 72 17 f8     L8441     FCB  $80,$31,$72,$17            ,$F8 LN(2)
                        *
                        * LOG - NATURAL LOGARITHM (LN)

                        * THE NATURAL OR NAPERIAN LOGARITHM IS CALCULATED USING
                        * MATHEMATICAL IDENTITIES. FPA0 IS OF THE FORM FPA0=A*(2**B) (SCIENTIFIC
                        * NOTATION). THEREFORE, THE LOG ROUTINE DETERMINES THE VALUE OF
                        * LN(A*(2**B)). A SERIES OF MATHEMATICAL IDENTITIES WILL EXPAND THIS
                        * TERM: LN(A*(2**B))=(-1/2+(1/LN(2))*(LN(A*SQR(2)))+B)*LN(2). ALL OF
                        * THE TERMS OF THE LATTER EXPRESSION ARE CONSTANTS EXCEPT FOR THE
                        * LN(A*SQR(2)) TERM WHICH IS EVALUATED USING THE TAYLOR SERIES EXPANSION
f303 bd ee b6           LOG       JSR  eeb6(LBC6D)                CHECK STATUS OF FPA0
f306 10 2f f3 c4                  LBLE e6ce(LB44A)                'FC' ERROR IF NEGATIVE OR ZERO
f30a 8e f2 ef                     LDX  #f2ef(L8432)               POINT (X) TO FP NUMBER (1/SQR(2))
f30d 96 4f                        LDA  004f(FP0EXP)               *GET EXPONENT OF ARGUMENT
f30f 80 80                        SUBA #$80                       *SUBTRACT OFF THE BIAS AND
f311 34 02                        PSHS A                          *SAVE IT ON THE STACK
f313 86 80                        LDA  #$80
f315 97 4f                        STA  004f(FP0EXP)
f317 bd ec 0b                     JSR  ec0b(LB9C2)                ADD FPA0 TO (X)
f31a 8e f2 f4                     LDX  #f2f4(L8437)               POINT X TO SQR(2)
f31d bd ed d8                     JSR  edd8(LBB8F)                DIVIDE SQR(2) BY FPA0
f320 8e ed 0e                     LDX  #ed0e(LBAC5)               POINT X TO FP VALUE OF 1.00
f323 bd ec 02                     JSR  ec02(LB9B9)                SUBTRACT FPA0 FROM (X)
                        *         NOW  FPA0 = (1-SQR(2)*X)/(1+SQR(2)*X) WHERE X IS ARGUMENT
f326 8e f2 da                     LDX  #f2da(L841D)               POINT X TO TABLE OF COEFFICIENTS
f329 bd f1 39                     JSR  f139(LBEF0)                EXPAND POLYNOMIAL
f32c 8e f2 f9                     LDX  #f2f9(L843C)               POINT X TO FP VALUE OF (-.5)
f32f bd ec 0b                     JSR  ec0b(LB9C2)                ADD FPA0 TO X
f332 35 04                        PULS B                          GET EXPONENT OF ARGUMENT BACK (WITHOUT BIAS)
f334 bd ef e2                     JSR  efe2(LBD99)                ADD ACCB TO FPA0
f337 8e f2 fe                     LDX  #f2fe(L8441)               POINT X TO LN(2)
f33a 7e ed 13                     JMP  ed13(LBACA)                MULTIPLY FPA0 * LN(2)

                        * SQR
f33d bd ee a8           SQR       JSR  eea8(LBC5F)                MOVE FPA0 TO FPA1
f340 8e f1 09                     LDX  #f109(LBEC0)               POINT (X) TO FP NUMBER (.5)
f343 bd ee 5d                     JSR  ee5d(LBC14)                COPY A PACKED NUMBER FROM (X) TO FPA0

                        * ARITHMETIC OPERATOR FOR EXPONENTIATION JUMPS
                        * HERE. THE FORMULA USED TO EVALUATE EXPONENTIATION
                        * IS A**X=E**(X LN A) = E**(FPA0*LN(FPA1)), E=2.7182818
f346 27 67              L8489     BEQ  EXP                        DO A NATURAL EXPONENTIATION IF EXPONENT = 0
f348 4d                           TSTA                            *CHECK VALUE BEING EXPONENTIATED
f349 26 03                        BNE  L8491                      *AND BRANCH IF IT IS <> 0
f34b 7e ec 83                     JMP  ec83(LBA3A)                FPA0=0 IF RAISING ZERO TO A POWER
f34e 8e 00 4a           L8491     LDX  #004a(V4A)                 * PACK FPA0 AND SAVE
f351 bd ee 7e                     JSR  ee7e(LBC35)                * IT IN FPA5 (ARGUMENT'S EXPONENT)
f354 5f                           CLRB                            ACCB=DEFAULT RESULT SIGN FLAG; 0=POSITIVE
f355 96 61                        LDA  0061(FP1SGN)               *CHECK THE SIGN OF ARGUMENT
f357 2a 10                        BPL  L84AC                      *BRANCH IF POSITIVE
f359 bd ef 37                     JSR  ef37(INT)                  CONVERT EXPONENT INTO AN INTEGER
f35c 8e 00 4a                     LDX  #004a(V4A)                 POINT X TO FPA5 (ORIGINAL EXPONENT)
f35f 96 61                        LDA  0061(FP1SGN)               GET MANTISSA SIGN OF FPA1 (ARGUMENT)
f361 bd ee e9                     JSR  eee9(LBCA0)                *COMPARE FPA0 TO (X) AND
f364 26 03                        BNE  L84AC                      *BRANCH IF NOT EQUAL
f366 43                           COMA                            TOGGLE FPA1 MANTISSA SIGN - FORCE POSITIVE
f367 d6 01                        LDB  0001(CHARAC)               GET LS BYTE OF INTEGER VALUE OF EXPONENT (RESULT SIGN FLAG)
f369 bd ee 95           L84AC     JSR  ee95(LBC4C)                COPY FPA1 TO FPA0; ACCA = MANTISSA SIGN
f36c 34 04                        PSHS B                          PUT RESULT SIGN FLAG ON THE STACK
f36e bd f3 03                     JSR  f303(LOG)
f371 8e 00 4a                     LDX  #004a(V4A)                 POINT (X) TO FPA5
f374 bd ed 13                     JSR  ed13(LBACA)                MULTIPLY FPA0 BY FPA5
f377 8d 36                        BSR  EXP                        CALCULATE E**(FPA0)
f379 35 02                        PULS A                          * GET RESULT SIGN FLAG FROM THE STACK
f37b 46                           RORA * AND BRANCH IF             NEGATIVE
f37c 10 25 fd b2                  LBCS f132(LBEE9)                CHANGE SIGN OF FPA0 MANTISSA
f380 39                           RTS

                        * CORRECTION FACTOR FOR EXPONENTIAL FUNCTION
f381 81 38 aa 3b 29     L84C4     FCB  $81,$38,$AA,$3B            ,$29 1.44269504 ( CF )
                        *
                        * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR E**X
                        *
f386 07                 L84C9     FCB  7                          EIGHT COEFFICIENTS
f387 71 34 58 3e 56     L84CA     FCB  $71,$34,$58,$3E            ,$56 2.14987637E-05: 1/(7!*(CF**7))
f38c 74 16 7e b3 1b     L84CF     FCB  $74,$16,$7E,$B3            ,$1B 1.4352314E-04 : 1/(6!*(CF**6))
f391 77 2f ee e3 85     L84D4     FCB  $77,$2F,$EE,$E3            ,$85 1.34226348E-03: 1/(5!*(CF**5))
f396 7a 1d 84 1c 2a     L84D9     FCB  $7A,$1D,$84,$1C            ,$2A 9.61401701E-03: 1/(4!*(CF**4))
f39b 7c 63 59 58 0a     L84DE     FCB  $7C,$63,$59,$58            ,$0A 0.0555051269
f3a0 7e 75 fd e7 c6     L84E3     FCB  $7E,$75,$FD,$E7            ,$C6 0.240226385
f3a5 80 31 72 18 10     L84E8     FCB  $80,$31,$72,$18            ,$10 0.693147186
f3aa 81 00 00 00 00     L84ED     FCB  $81,$00,$00,$00            ,$00 1
                        *
                        * EXP ( E**X)
                        * THE EXPONENTIAL FUNCTION IS EVALUATED BY FIRST MULTIPLYING THE
                        * ARGUMENT BY A CORRECTION FACTOR (CF). AFTER THIS IS DONE, AN
                        * ARGUMENT >= 127 WILL YIELD A ZERO RESULT (NO UNDERFLOW) FOR A
                        * NEGATIVE ARGUMENT OR AN 'OV' (OVERFLOW) ERROR FOR A POSITIVE
                        * ARGUMENT. THE POLYNOMIAL COEFFICIENTS ARE MODIFIED TO REFLECT
                        * THE CF MULTIPLICATION AT THE START OF THE EVALUATION PROCESS.

f3af 8e f3 81           EXP       LDX  #f381(L84C4)               POINT X TO THE CORRECTION FACTOR
f3b2 bd ed 13                     JSR  ed13(LBACA)                MULTIPLY FPA0 BY (X)
f3b5 bd ee 78                     JSR  ee78(LBC2F)                PACK FPA0 AND STORE IT IN FPA3
f3b8 96 4f                        LDA  004f(FP0EXP)               *GET EXPONENT OF FPA0 AND
f3ba 81 88                        CMPA #$88                       *COMPARE TO THE MAXIMUM VALUE
f3bc 25 03                        BLO  L8504                      BRANCH IF FPA0 < 128
f3be 7e ed a5           L8501     JMP  eda5(LBB5C)                SET FPA0 = 0 OR 'OV' ERROR
f3c1 bd ef 37           L8504     JSR  ef37(INT)                  CONVERT FPA0 TO INTEGER
f3c4 96 01                        LDA  0001(CHARAC)               GET LS BYTE OF INTEGER
f3c6 8b 81                        ADDA #$81                       * WAS THE ARGUMENT =127, IF SO
f3c8 27 f4                        BEQ  f3be(L8501)                * THEN 'OV' ERROR; THIS WILL ALSO ADD THE $80 BIAS
                        *              * REQUIRED WHEN THE NEW EXPONENT IS CALCULATED BELOW
f3ca 4a                           DECA                            DECREMENT ONE FROM THE EXPONENT, BECAUSE $81, NOT $80 WAS USED ABOVE
f3cb 34 02                        PSHS A                          SAVE EXPONENT OF INTEGER PORTION ON STACK
f3cd 8e 00 40                     LDX  #0040(V40)                 POINT (X) TO FPA3
f3d0 bd ec 02                     JSR  ec02(LB9B9)                SUBTRACT FPA0 FROM (X) - GET FRACTIONAL PART OF ARGUMENT
f3d3 8e f3 86                     LDX  #f386(L84C9)               POINT X TO COEFFICIENTS
f3d6 bd f1 48                     JSR  f148(LBEFF)                EVALUATE POLYNOMIAL FOR FRACTIONAL PART
f3d9 0f 62                        CLR  0062(RESSGN)               FORCE THE MANTISSA TO BE POSITIVE
f3db 35 02                        PULS A                          GET INTEGER EXPONENT FROM STACK
f3dd bd ed 91                     JSR  ed91(LBB48)                * CALCULATE EXPONENT OF NEW FPA0 BY ADDING THE EXPONENTS OF THE
                        *              * INTEGER AND FRACTIONAL PARTS
f3e0 39                           RTS

                        * FIX
f3e1 bd ee b6           FIX       JSR  eeb6(LBC6D)                CHECK STATUS OF FPA0
f3e4 2b 03                        BMI  L852C                      BRANCH IF FPA0 = NEGATIVE
f3e6 7e ef 37           L8529     JMP  ef37(INT)                  CONVERT FPA0 TO INTEGER
f3e9 03 54              L852C     COM  0054(FP0SGN)               TOGGLE SIGN OF FPA0 MANTISSA
f3eb 8d f9                        BSR  f3e6(L8529)                CONVERT FPA0 TO INTEGER
f3ed 7e f1 32                     JMP  f132(LBEE9)                TOGGLE SIGN OF FPA0

                        * EDIT
f3f0 bd f8 1e           EDIT      JSR  L89AE                      GET LINE NUMBER FROM BASIC
f3f3 32 62                        LEAS $02,S PURGE RET            URN ADDRESS OFF OF THE STACK
f3f5 86 01              L8538     LDA  #$01                       'LIST' FLAG
f3f7 97 98                        STA  0098(VD8)                  SET FLAG TO LIST LINE
f3f9 bd df a2                     JSR  dfa2(LAD01)                GO FIND THE LINE NUMBER IN PROGRAM
f3fc 10 25 ed 7f                  LBCS LAED2 ERROR #7             'UNDEFINED LINE #'
f400 bd ea 3b                     JSR  ea3b(LB7C2)                GO UNCRUNCH LINE INTO BUFFER AT LINBUF+1
f403 1f 20                        TFR  Y,D                        PUT ABSOLUTE ADDRESS OF END OF LINE TO ACCD
f405 83 00 f5                     SUBD #00f3(LINBUF)+2 SUBTR      ACT OUT THE START OF LINE
f408 d7 97                        STB  0097(VD7)                  SAVE LENGTH OF LINE
f40a dc 2b              L854D     LDD  002b(BINVAL)               GET THE HEX VALUE OF LINE NUMBER
f40c bd f0 15                     JSR  f015(LBDCC)                LIST THE LINE NUMBER ON THE SCREEN
f40f bd eb f5                     JSR  ebf5(LB9AC)                PRINT A SPACE
f412 8e 00 f4                     LDX  #00f3(LINBUF)+1            POINT X TO BUFFER
f415 d6 98                        LDB  0098(VD8)                  * CHECK TO SEE IF LINE IS TO BE
f417 26 25                        BNE  L8581                      * LISTED TO SCREEN - BRANCH IF IT IS
f419 5f                 L855C     CLRB                            RESET DIGIT ACCUMULATOR - DEFAULT VALUE
f41a bd f5 44           L855D     JSR  L8687                      GET KEY STROKE
f41d bd fc e9                     JSR  L90AA                      SET CARRY IF NOT NUMERIC
f420 25 0b                        BLO  L8570                      BRANCH IF NOT NUMERIC
f422 80 30                        SUBA #'0' MASK OFF A            SCII
f424 34 02                        PSHS A SAVE IT ON ST            ACK
f426 86 0a                        LDA  #10                        NUMBER BEING CONVERTED IS BASE 10
f428 3d                           MUL  MULTIPLY ACCUMU            LATED VALUE BY BASE (10)
f429 eb e0                        ADDB ,S+ ADD DIGIT T            O ACCUMULATED VALUE
f42b 20 ed                        BRA  f41a(L855D)                CHECK FOR ANOTHER DIGIT
f42d c0 01              L8570     SUBB #$01 * REPEAT P            ARAMETER IN ACCB; IF IT
f42f c9 01                        ADCB #$01 *IS 0, THE            N MAKE IT '1'
f431 81 41                        CMPA #'A' ABORT?
f433 26 05                        BNE  L857D                      NO
f435 bd eb a5                     JSR  eba5(LB958)                PRINT CARRIAGE RETURN TO SCREEN
f438 20 bb                        BRA  f3f5(L8538)                RESTART EDIT PROCESS - CANCEL ALL CHANGES
f43a 81 4c              L857D     CMPA #'L' LIST?
f43c 26 0b                        BNE  L858C                      NO
f43e 8d 31              L8581     BSR  L85B4                      LIST THE LINE
f440 0f 98                        CLR  0098(VD8)                  RESET THE LIST FLAG TO 'NO LIST'
f442 bd eb a5                     JSR  eba5(LB958)                PRINT CARRIAGE RETURN
f445 20 c3                        BRA  f40a(L854D)                GO INTERPRET ANOTHER EDIT COMMAND
f447 32 62              L858A     LEAS $02,S PURGE RET            URN ADDRESS OFF OF THE STACK
f449 81 0d              L858C     CMPA #CR ENTER KEY?
f44b 26 0d                        BNE  L859D                      NO
f44d 8d 22                        BSR  L85B4                      ECHO THE LINE TO THE SCREEN
f44f bd eb a5           L8592     JSR  eba5(LB958)                PRINT CARRIAGE RETURN
f452 8e 00 f4                     LDX  #00f3(LINBUF)+1            * RESET BASIC'S INPUT POINTER
f455 9f 83                        STX  0083(CHARAD)               * TO THE LINE INPUT BUFFER
f457 7e df 4b                     JMP  df4b(LACA8)                GO PUT LINE BACK IN PROGRAM
f45a 81 45              L859D     CMPA #'E' EXIT?
f45c 27 f1                        BEQ  f44f(L8592)                YES - SAME AS ENTER EXCEPT NO ECHO
f45e 81 51                        CMPA #'Q' QUIT?
f460 26 06                        BNE  L85AB                      NO
f462 bd eb a5                     JSR  eba5(LB958)                PRINT CARRIAGE RETURN TO SCREEN
f465 7e df 22                     JMP  df22(LAC73)                GO TO COMMAND LEVEL - MAKE NO CHANGES
f468 8d 02              L85AB     BSR  L85AF                      INTERPRET THE REMAINING COMMANDS AS SUBROUTINES
f46a 20 ad                        BRA  f419(L855C)                GO INTERPRET ANOTHER EDIT COMMAND
f46c 81 20              L85AF     CMPA #SPACE SPACE BA            R?
f46e 26 10                        BNE  L85C3                      NO
f470 8c                 L85B3     FCB  008c(SKP2)                 SKIP TWO BYTES
                        * DISPLAY THE NEXT ACCB BYTES OF THE LINE IN THE BUFFER TO THE SCREEN
                        *
f471 c6 f9              L85B4     LDB  #00fa(LBUFMX)-1            250 BYTES MAX IN BUFFER
f473 a6 84              L85B6     LDA  ,X                         GET A CHARACTER FROM BUFFER
f475 27 08                        BEQ  L85C2                      EXIT IF IT'S A 0
f477 bd db 14                     JSR  db14(PUTCHR)               SEND CHAR TO CONSOLE OUT
f47a 30 01                        LEAX $01,X MOVE POIN            TER UP ONE
f47c 5a                           DECB DECREMENT CHARA            CTER COUNTER
f47d 26 f4                        BNE  f473(L85B6)                LOOP IF NOT DONE
f47f 39                 L85C2     RTS
f480 81 44              L85C3     CMPA #'D' DELETE?
f482 26 48                        BNE  L860F                      NO
f484 6d 84              L85C7     TST  ,X                         * CHECK FOR END OF LINE
f486 27 f7                        BEQ  f47f(L85C2)                * AND BRANCH IF SO
f488 8d 04                        BSR  L85D1                      REMOVE A CHARACTER
f48a 5a                           DECB DECREMENT REPEA            T PARAMETER
f48b 26 f7                        BNE  f484(L85C7)                BRANCH IF NOT DONE
f48d 39                           RTS
                        * REMOVE ONE CHARACTER FROM BUFFER
f48e 0a 97              L85D1     DEC  0097(VD7)                  DECREMENT LENGTH OF BUFFER
f490 31 1f                        LEAY $-01,X POINT Y             TO ONE BEFORE CURRENT BUFFER POINTER
f492 31 21              L85D5     LEAY $01,Y INCREMENT             TEMPORARY BUFFER POINTER
f494 a6 21                        LDA  $01,Y                      GET NEXT CHARACTER
f496 a7 a4                        STA  ,Y                         PUT IT IN CURRENT POSITION
f498 26 f8                        BNE  f492(L85D5)                BRANCH IF NOT END OF LINE
f49a 39                           RTS
f49b 81 49              L85DE     CMPA #'I' INSERT?
f49d 27 13                        BEQ  L85F5                      YES
f49f 81 58                        CMPA #'X' EXTEND?
f4a1 27 0d                        BEQ  L85F3                      YES
f4a3 81 48                        CMPA #'H' HACK?
f4a5 26 5c                        BNE  L8646                      NO
f4a7 6f 84                        CLR  ,X                         TURN CURRENT BUFFER POINTER INTO END OF LINE FLAG
f4a9 1f 10                        TFR  X,D                        PUT CURRENT BUFFER POINTER IN ACCD
f4ab 83 00 f5                     SUBD #00f3(LINBUF)+2 SUBTR      ACT INITIAL POINTER POSITION
f4ae d7 97                        STB  0097(VD7)                  SAVE NEW BUFFER LENGTH
f4b0 8d bf              L85F3     BSR  f471(L85B4)                DISPLAY THE LINE ON THE SCREEN
f4b2 bd f5 44           L85F5     JSR  L8687                      GET A KEYSTROKE
f4b5 81 0d                        CMPA #CR ENTER KEY?
f4b7 27 8e                        BEQ  f447(L858A)                YES - INTERPRET ANOTHER COMMAND - PRINT LINE
f4b9 81 1b                        CMPA #ESC ESCAPE?
f4bb 27 25                        BEQ  L8625                      YES - RETURN TO COMMAND LEVEL - DON'T PRINT LINE
f4bd 81 08                        CMPA #BS BACK SPACE?
f4bf 26 22                        BNE  L8626                      NO
f4c1 8c 00 f4                     CMPX #00f3(LINBUF)+1 COMPA      RE POINTER TO START OF BUFFER
f4c4 27 ec                        BEQ  f4b2(L85F5)                DO NOT ALLOW BS IF AT START
f4c6 8d 45                        BSR  L8650                      MOVE POINTER BACK ONE, BS TO SCREEN
f4c8 8d c4                        BSR  f48e(L85D1)                REMOVE ONE CHARACTER FROM BUFFER
f4ca 20 e6                        BRA  f4b2(L85F5)                GET INSERT SUB COMMAND
f4cc 81 43              L860F     CMPA #'C' CHANGE?
f4ce 26 cb                        BNE  f49b(L85DE)                NO
f4d0 6d 84              L8613     TST  ,X                         CHECK CURRENT BUFFER CHARACTER
f4d2 27 0e                        BEQ  L8625                      BRANCH IF END OF LINE
f4d4 bd f5 44                     JSR  L8687                      GET A KEYSTROKE
f4d7 25 02                        BLO  L861E                      BRANCH IF LEGITIMATE KEY
f4d9 20 f5                        BRA  f4d0(L8613)                TRY AGAIN IF ILLEGAL KEY
f4db a7 80              L861E     STA  ,X+                        INSERT NEW CHARACTER INTO BUFFER
f4dd 8d 37                        BSR  L8659                      SEND NEW CHARACTER TO SCREEN
f4df 5a                           DECB DECREMENT REPEA            T PARAMETER
f4e0 26 ee                        BNE  f4d0(L8613)                BRANCH IF NOT DONE
f4e2 39                 L8625     RTS
f4e3 d6 97              L8626     LDB  0097(VD7)                  GET LENGTH OF LINE
f4e5 c1 f9                        CMPB #00fa(LBUFMX)-1 COMPA      RE TO MAXIMUM LENGTH
f4e7 26 02                        BNE  L862E                      BRANCH IF NOT AT MAXIMUM
f4e9 20 c7                        BRA  f4b2(L85F5)                IGNORE INPUT IF LINE AT MAXIMUM LENGTH
f4eb 34 10              L862E     PSHS X SAVE CURRENT             BUFFER POINTER
f4ed 6d 80              L8630     TST  ,X+                        * SCAN THE LINE UNTIL END OF
f4ef 26 fc                        BNE  f4ed(L8630)                * LINE (0) IS FOUND
f4f1 e6 82              L8634     LDB  ,-X                        DECR TEMP LINE POINTER AND GET A CHARACTER
f4f3 e7 01                        STB  $01,X                      PUT CHARACTER BACK DOWN ONE SPOT
f4f5 ac e4                        CMPX ,S HAVE WE REAC            HED STARTING POINT?
f4f7 26 f8                        BNE  f4f1(L8634)                NO - KEEP GOING
f4f9 32 62                        LEAS $02,S PURGE BUF            FER POINTER FROM STACK
f4fb a7 80                        STA  ,X+                        INSERT NEW CHARACTER INTO THE LINE
f4fd 8d 17                        BSR  L8659                      SEND A CHARACTER TO CONSOLE OUT
f4ff 0c 97                        INC  0097(VD7)                  ADD ONE TO BUFFER LENGTH
f501 20 af                        BRA  f4b2(L85F5)                GET INSERT SUB COMMAND
f503 81 08              L8646     CMPA #BS BACKSPACE?
f505 26 12                        BNE  L865C                      NO
f507 8d 04              L864A     BSR  L8650                      MOVE POINTER BACK 1, SEND BS TO SCREEN
f509 5a                           DECB DECREMENT REPEA            T PARAMETER
f50a 26 fb                        BNE  f507(L864A)                LOOP UNTIL DONE
f50c 39                           RTS
f50d 8c 00 f4           L8650     CMPX #00f3(LINBUF)+1 COMPA      RE POINTER TO START OF BUFFER
f510 27 d0                        BEQ  f4e2(L8625)                DO NOT ALLOW BS IF AT START
f512 30 1f                        LEAX $-01,X MOVE POI            NTER BACK ONE
f514 86 08                        LDA  #0008(BS)                  BACK SPACE
f516 7e db 14           L8659     JMP  db14(PUTCHR)               SEND TO CONSOLE OUT
f519 81 4b              L865C     CMPA #'K' KILL?
f51b 27 05                        BEQ  L8665                      YES
f51d 80 53                        SUBA #'S' SEARCH?
f51f 27 01                        BEQ  L8665                      YES
f521 39                           RTS
f522 34 02              L8665     PSHS A SAVE KILL/SEA            RCH FLAG ON STACK
f524 8d 1e                        BSR  L8687                      * GET A KEYSTROKE (TARGET CHARACTER)
f526 34 02                        PSHS A * AND SAVE IT             ON STACK
f528 a6 84              L866B     LDA  ,X                         GET CURRENT BUFFER CHARACTER
f52a 27 16                        BEQ  L8685                      AND RETURN IF END OF LINE
f52c 6d 61                        TST  $01,S                      CHECK KILL/SEARCH FLAG
f52e 26 06                        BNE  L8679                      BRANCH IF KILL
f530 8d e4                        BSR  f516(L8659)                SEND A CHARACTER TO CONSOLE OUT
f532 30 01                        LEAX $01,X INCREMENT             BUFFER POINTER
f534 20 03                        BRA  L867C                      CHECK NEXT INPUT CHARACTER
f536 bd f4 8e           L8679     JSR  f48e(L85D1)                REMOVE ONE CHARACTER FROM BUFFER
f539 a6 84              L867C     LDA  ,X                         GET CURRENT INPUT CHARACTER
f53b a1 e4                        CMPA ,S COMPARE TO T            ARGET CHARACTER
f53d 26 e9                        BNE  f528(L866B)                BRANCH IF NO MATCH
f53f 5a                           DECB DECREMENT REPEA            T PARAMETER
f540 26 e6                        BNE  f528(L866B)                BRANCH IF NOT DONE
f542 35 a0              L8685     PULS Y,PC THE Y PULL             WILL CLEAN UP THE STACK FOR THE 2 PSHS A
                        *
                        * GET A KEYSTRKE
f544 bd db 00           L8687     JSR  db00(LA171)                CALL CONSOLE IN : DEV NBR=SCREEN
f547 81 7f                        CMPA #$7F GRAPHIC CH            ARACTER?
f549 24 f9                        BCC  f544(L8687)                YES - GET ANOTHER CHAR
f54b 81 5f                        CMPA #$5F SHIFT UP A            RROW (QUIT INSERT)
f54d 26 02                        BNE  L8694                      NO
f54f 86 1b                        LDA  #001b(ESC)                 REPLACE W/ESCAPE CODE
f551 81 0d              L8694     CMPA #CR ENTER KEY
f553 27 0e                        BEQ  L86A6                      YES
f555 81 1b                        CMPA #ESC ESCAPE?
f557 27 0a                        BEQ  L86A6                      YES
f559 81 08                        CMPA #BS BACKSPACE?
f55b 27 06                        BEQ  L86A6                      YES
f55d 81 20                        CMPA #SPACE SPACE
f55f 25 e3                        BLO  f544(L8687)                GET ANOTHER CHAR IF CONTROL CHAR
f561 1a 01                        ORCC #$01 SET CARRY
f563 39                 L86A6     RTS

                        * TRON
f564 86                 TRON      FCB  0086(SKP1LD)               SKIP ONE BYTE AND LDA #$4F

                        * TROFF
f565 4f                 TROFF     CLRA                            TROFF FLAG
f566 97 8c                        STA  008c(TRCFLG)               TRON/TROFF FLAG:0=TROFF, <> 0=TRON
f568 39                           RTS

                        * POS

f569 86 00              POS       LDA  #0                         GET DEVICE NUMBER
f56b d6 79                        LDB  0079(LPTPOS)               GET PRINT POSITION
f56d 1d                 LA5E8     SEX                             CONVERT ACCB TO 2 DIGIT SIGNED INTEGER
f56e 7e e7 78                     JMP  e778(GIVABF)               CONVERT ACCD TO FLOATING POINT


                        * VARPTR
f571 bd e4 f3           VARPT     JSR  e4f3(LB26A)                SYNTAX CHECK FOR '('
f574 dc 1f                        LDD  001f(ARYEND)               GET ADDR OF END OF ARRAYS
f576 34 06                        PSHS B,A                        SAVE IT ON STACK
f578 bd e5 db                     JSR  e5db(LB357)                GET VARIABLE DESCRIPTOR
f57b bd e4 f0                     JSR  e4f0(LB267)                SYNTAX CHECK FOR ')'
f57e 35 06                        PULS A,B                        GET END OF ARRAYS ADDR BACK
f580 1e 10                        EXG  X,D                        SWAP END OF ARRAYS AND VARIABLE DESCRIPTOR
f582 9c 1f                        CMPX 001f(ARYEND)               COMPARE TO NEW END OF ARRAYS
f584 26 51                        BNE  L8724                      'FC' ERROR IF VARIABLE WAS NOT DEFINED PRIOR TO CALLING VARPTR
f586 7e e7 78                     JMP  e778(GIVABF)               CONVERT VARIABLE DESCRIPTOR INTO A FP NUMBER

                        * MID$(OLDSTRING,POSITION,LENGTH)=REPLACEMENT
f589 9d 7c              L86D6     JSR  007c(GETNCH)               GET INPUT CHAR FROM BASIC
f58b bd e4 f3                     JSR  e4f3(LB26A)                SYNTAX CHECK FOR '('
f58e bd e5 db                     JSR  e5db(LB357)                * GET VARIABLE DESCRIPTOR ADDRESS AND
f591 34 10                        PSHS X                          * SAVE IT ON THE STACK
f593 ec 02                        LDD  $02,X                      POINT ACCD TO START OF OLDSTRING
f595 10 93 21                     CMPD 0021(FRETOP)               COMPARE TO START OF CLEARED SPACE
f598 23 04                        BLS  L86EB                      BRANCH IF <=
f59a 93 27                        SUBD 0027(MEMSIZ)               SUBTRACT OUT TOP OF CLEARED SPACE
f59c 23 12                        BLS  L86FD                      BRANCH IF STRING IN STRING SPACE
f59e e6 84              L86EB     LDB  ,X                         GET LENGTH OF OLDSTRING
f5a0 bd e7 f1                     JSR  e7f1(LB56D)                RESERVE ACCB BYTES IN STRING SPACE
f5a3 34 10                        PSHS X                          SAVE RESERVED SPACE STRING ADDRESS ON STACK
f5a5 ae 62                        LDX  $02,S                      POINT X TO OLDSTRING DESCRIPTOR
f5a7 bd e8 c7                     JSR  e8c7(LB643)                MOVE OLDSTRING INTO STRING SPACE
f5aa 35 50                        PULS X,U                        * GET OLDSTRING DESCRIPTOR ADDRESS AND RESERVED STRING
f5ac af 42                        STX  $02,U                      * ADDRESS AND SAVE RESERVED ADDRESS AS OLDSTRING ADDRESS
f5ae 34 40                        PSHS U                          SAVE OLDSTRING DESCRIPTOR ADDRESS
f5b0 bd e9 bc           L86FD     JSR  e9bc(LB738)                SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION
f5b3 34 04                        PSHS B                          SAVE POSITION PARAMETER ON STACK
f5b5 5d                           TSTB * CHECK POSITIO            N PARAMETER AND BRANCH
f5b6 27 1f                        BEQ  L8724                      * IF START OF STRING
f5b8 c6 ff                        LDB  #$FF                       DEFAULT REPLACEMENT LENGTH = $FF
f5ba 81 29                        CMPA #')'                       * CHECK FOR END OF MID$ STATEMENT AND
f5bc 27 03                        BEQ  L870E                      * BRANCH IF AT END OF STATEMENT
f5be bd e9 bc                     JSR  e9bc(LB738)                SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION
f5c1 34 04              L870E     PSHS B                          SAVE LENGTH PARAMETER ON STACK
f5c3 bd e4 f0                     JSR  e4f0(LB267)                SYNTAX CHECK FOR ')'
f5c6 c6 ae                        LDB  #00ae(TOK_EQUALS)          TOKEN FOR =
f5c8 bd e4 f8                     JSR  e4f8(LB26F)                SYNTAX CHECK FOR "='
f5cb 8d 2e                        BSR  L8748                      EVALUATE REPLACEMENT STRING
f5cd 1f 13                        TFR  X,U                        SAVE REPLACEMENT STRING ADDRESS IN U
f5cf ae 62                        LDX  $02,S                      POINT X TO OLOSTRING DESCRIPTOR ADDRESS
f5d1 a6 84                        LDA  ,X                         GET LENGTH OF OLDSTRING
f5d3 a0 61                        SUBA $01,S                      SUBTRACT POSITION PARAMETER
f5d5 24 03                        BCC  L8727                      INSERT REPLACEMENT STRING INTO OLDSTRING
f5d7 7e e6 ce           L8724     JMP  e6ce(LB44A)                'FC' ERROR IF POSITION > LENGTH OF OLDSTRING
f5da 4c                 L8727     INCA                            * NOW ACCA = NUMBER OF CHARACTERS TO THE RIGHT
                        *                             * (INCLUSIVE) OF THE POSITION PARAMETER
f5db a1 e4                        CMPA ,S
f5dd 24 02                        BCC  L872E                      BRANCH IF NEW STRING WILL FIT IN OLDSTRING
f5df a7 e4                        STA  ,S                         IF NOT, USE AS MUCH OF LENGTH PARAMETER AS WILL FIT
f5e1 a6 61              L872E     LDA  $01,S                      GET POSITION PARAMETER
f5e3 1e 89                        EXG  A,B                        ACCA=LENGTH OF REPL STRING, ACCB=POSITION PARAMETER
f5e5 ae 02                        LDX  $02,X                      POINT X TO OLDSTRING ADDRESS
f5e7 5a                           DECB                            * BASIC'S POSITION PARAMETER STARTS AT 1; THIS ROUTINE
                        *                             * WANTS IT TO START AT ZERO
f5e8 3a                           ABX                             POINT X TO POSITION IN OLDSTRING WHERE THE REPLACEMENT WILL GO
f5e9 4d                           TSTA                            * IF THE LENGTH OF THE REPLACEMENT STRING IS ZERO
f5ea 27 0d                        BEQ  L8746                      * THEN RETURN
f5ec a1 e4                        CMPA ,S
f5ee 23 02                        BLS  L873F                      ADJUSTED LENGTH PARAMETER, THEN BRANCH
f5f0 a6 e4                        LDA  ,S                         OTHERWISE USE AS MUCH ROOM AS IS AVAILABLE
f5f2 1f 89              L873F     TFR  A,B                        SAVE NUMBER OF BYTES TO MOVE IN ACCB
f5f4 1e 31                        EXG  U,X                        SWAP SOURCE AND DESTINATION POINTERS
f5f6 bd dc ae                     JSR  dcae(LA59A)                MOVE (B) BYTES FROM (X) TO (U)
f5f9 35 96              L8746     PULS A,B,X,PC
f5fb bd e3 df           L8748     JSR  e3df(LB156)                EVALUATE EXPRESSION
f5fe 7e e8 d8                     JMP  e8d8(LB654)                *'TM' ERROR IF NUMERIC; RETURN WITH X POINTING
                        *                             *TO STRING, ACCB = LENGTH

                        * STRING
f601 bd e4 f3           STRING    JSR  e4f3(LB26A)                SYNTAX CHECK FOR '('
f604 bd e9 8f                     JSR  e98f(LB70B)                EVALUATE EXPRESSION; ERROR IF > 255
f607 34 04                        PSHS B                          SAVE LENGTH OF STRING
f609 bd e4 f6                     JSR  e4f6(LB26D)                SYNTAX CHECK FOR COMMA
f60c bd e3 df                     JSR  e3df(LB156)                EVALUATE EXPRESSION
f60f bd e4 f0                     JSR  e4f0(LB267)                SYNTAX CHECK FOR ')'
f612 96 06                        LDA  0006(VALTYP)               GET VARIABLE TYPE
f614 26 05                        BNE  L8768                      BRANCH IF STRING
f616 bd e9 92                     JSR  e992(LB70E)                CONVERT FPA0 INTO AN INTEGER IN ACCB
f619 20 03                        BRA  L876B                      SAVE THE STRING IN STRING SPACE
f61b bd e9 28           L8768     JSR  e928(LB6A4)                GET FIRST BYTE OF STRING
f61e 34 04              L876B     PSHS B                          SAVE FIRST BYTE OF EXPRESSION
f620 e6 61                        LDB  $01,S                      GET LENGTH OF STRING
f622 bd e7 93                     JSR  e793(LB50F)                RESERVE ACCB BYTES IN STRING SPACE
f625 35 06                        PULS A,B                        GET LENGTH OF STRING AND CHARACTER
f627 27 05                        BEQ  L877B                      BRANCH IF NULL STRING
f629 a7 80              L8776     STA  ,X+                        SAVE A CHARACTER IN STRING SPACE
f62b 5a                           DECB                            DECREMENT LENGTH
f62c 26 fb                        BNE  f629(L8776)                BRANCH IF NOT DONE
f62e 7e e9 1f           L877B     JMP  e91f(LB69B)                PUT STRING DESCRIPTOR ONTO STRING STACK

                        * INSTR
f631 bd e4 f3           INSTR     JSR  e4f3(LB26A)                SYNTAX CHECK FOR '('
f634 bd e3 df                     JSR  e3df(LB156)                EVALUATE EXPRESSION
f637 c6 01                        LDB  #$01                       DEFAULT POSITION = 1 (SEARCH START)
f639 34 04                        PSHS B                          SAVE START
f63b 96 06                        LDA  0006(VALTYP)               GET VARIABLE TYPE
f63d 26 10                        BNE  L879C                      BRANCH IF STRING
f63f bd e9 92                     JSR  e992(LB70E)                CONVERT FPA0 TO INTEGER IN ACCB
f642 e7 e4                        STB  ,S                         SAVE START SEARCH VALUE
f644 27 91                        BEQ  f5d7(L8724)                BRANCH IF START SEARCH AT ZERO
f646 bd e4 f6                     JSR  e4f6(LB26D)                SYNTAX CHECK FOR COMMA
f649 bd e3 df                     JSR  e3df(LB156)                EVALUATE EXPRESSION - SEARCH STRING
f64c bd e3 cf                     JSR  e3cf(LB146)                'TM' ERROR IF NUMERIC
f64f 9e 52              L879C     LDX  0050(FPA0)+2               SEARCH STRING DESCRIPTOR ADDRESS
f651 34 10                        PSHS X                          SAVE ON THE STACK
f653 bd e4 f6                     JSR  e4f6(LB26D)                SYNTAX CHECK FOR COMMA
f656 bd f5 fb                     JSR  f5fb(L8748)                EVALUATE TARGET STRING EXPRESSION
f659 34 14                        PSHS X,B                        SAVE ADDRESS AND LENGTH ON STACK
f65b bd e4 f0                     JSR  e4f0(LB267)                SYNTAX CHECK FOR ')'
f65e ae 63                        LDX  $03,S                      * LOAD X WITH SEARCH STRING DESCRIPTOR ADDRESS
f660 bd e8 dd                     JSR  e8dd(LB659)                * AND GET THE LENGTH ANDADDRESS OF SEARCH STRING
f663 34 04                        PSHS B                          SAVE LENGTH ON STACK
                        *
                        * AT THIS POINT THE STACK HAS THE FOLLOWING INFORMATION
                        * ON IT: 0,S-SEARCH LENGTH; 1,S-TARGET LENGTH; 2 3,S-TARGET
                        * ADDRESS; 4 5,S-SEARCH DESCRIPTOR ADDRESS; 6,S-SEARCH POSITION
f665 e1 66                        CMPB $06,S                      COMPARE LENGTH OF SEARCH STRING TO START
f667 25 23                        BLO  L87D9                      POSITION; RETURN 0 IF LENGTH < START
f669 a6 61                        LDA  $01,S                      GET LENGTH OF TARGET STRING
f66b 27 1c                        BEQ  L87D6                      BRANCH IF TARGET STRING = NULL
f66d e6 66                        LDB  $06,S                      GET START POSITION
f66f 5a                           DECB                            MOVE BACK ONE
f670 3a                           ABX  POINT X TO POSI            TION IN SEARCH STRING WHERE SEARCHING WILL START
f671 31 84              L87BE     LEAY ,X                         POINT Y TO SEARCH POSITION
f673 ee 62                        LDU  $02,S                      POINT U TO START OF TARGET
f675 e6 61                        LDB  $01,S                      LOAD ACCB WITH LENGTH OF TARGET
f677 a6 e4                        LDA  ,S                         LOAD ACCA WITH LENGTH OF SEARCH
f679 a0 66                        SUBA $06,S                      SUBTRACT SEARCH POSITION FROM SEARCH LENGTH
f67b 4c                           INCA                            ADD ONE
f67c a1 61                        CMPA $01,S                      COMPARE TO TARGET LENGTH
f67e 25 0c                        BLO  L87D9                      RETURN 0 IF TARGET LENGTH > WHAT'S LEFT OF SEARCH STRING
f680 a6 80              L87CD     LDA  ,X+                        GET A CHARACTER FROM SEARCH STRING
f682 a1 c0                        CMPA ,U+                        COMPARE IT TO TARGET STRING
f684 26 0c                        BNE  L87DF                      BRANCH IF NO MATCH
f686 5a                           DECB                            DECREMENT TARGET LENGTH
f687 26 f7                        BNE  f680(L87CD)                CHECK ANOTHER CHARACTER
f689 e6 66              L87D6     LDB  $06,S                      GET MATCH POSITION
f68b 21                 L87D8     FCB  0021(SKP1)                 SKIP NEXT BYTE
f68c 5f                 L87D9     CLRB                            MATCH ADDRESS = 0
f68d 32 67                        LEAS $07,S                      CLEAN UP THE STACK
f68f 7e e7 77                     JMP  e777(LB4F3)                CONVERT ACCB TO FP NUMBER
f692 6c 66              L87DF     INC  $06,S                      INCREMENT SEARCH POSITION
f694 30 21                        LEAX $01,Y                      MOVE X TO NEXT SEARCH POSITION
f696 20 d9                        BRA  f671(L87BE)                KEEP LOOKING FOR A MATCH

                        * EXTENDED BASIC RVEC19 HOOK CODE
f698 81 26              XVEC19    CMPA #'&'                       *
f69a 26 5c                        BNE  L8845                      * RETURN IF NOT HEX OR OCTAL VARIABLE
f69c 32 62                        LEAS $02,S                      PURGE RETURN ADDRESS FROM STACK
                        * PROCESS A VARIABLE PRECEEDED BY A '&' (&H,&O)
f69e 0f 52              L87EB     CLR  0050(FPA0)+2               * CLEAR BOTTOM TWO
f6a0 0f 53                        CLR  0050(FPA0)+3               * BYTES OF FPA0
f6a2 8e 00 52                     LDX  #0050(FPA0)+2              BYTES 2,3 OF FPA0 = (TEMPORARY ACCUMULATOR)
f6a5 9d 7c                        JSR  007c(GETNCH)               GET A CHARACTER FROM BASIC
f6a7 81 4f                        CMPA #'O'
f6a9 27 12                        BEQ  L880A                      YES
f6ab 81 48                        CMPA #'H'
f6ad 27 23                        BEQ  L881F                      YES
f6af 9d 82                        JSR  0082(GETCCH)               GET CURRENT INPUT CHARACTER
f6b1 20 0c                        BRA  L880C                      DEFAULT TO OCTAL (&O)
f6b3 81 38              L8800     CMPA #'8'
f6b5 10 22 ee 47                  LBHI e500(LB277)
f6b9 c6 03                        LDB  #$03                       BASE 8 MULTIPLIER
f6bb 8d 2a                        BSR  L8834                      ADD DIGIT TO TEMPORARY ACCUMULATOR
                        * EVALUATE AN &O VARIABLE
f6bd 9d 7c              L880A     JSR  007c(GETNCH)               GET A CHARACTER FROM BASIC
f6bf 25 f2              L880C     BLO  f6b3(L8800)                BRANCH IF NUMERIC
f6c1 0f 50              L880E     CLR  0050(FPA0)                 * CLEAR 2 HIGH ORDER
f6c3 0f 51                        CLR  0050(FPA0)+1               * BYTES OF FPA0
f6c5 0f 06                        CLR  0006(VALTYP)               SET VARXABLE TYPE TO NUMERIC
f6c7 0f 63                        CLR  0063(FPSBYT)               ZERO OUT SUB BYTE OF FPA0
f6c9 0f 54                        CLR  0054(FP0SGN)               ZERO OUT MANTISSA SIGN OF FPA0
f6cb c6 a0                        LDB  #$A0                       * SET EXPONENT OF FPA0
f6cd d7 4f                        STB  004f(FP0EXP)               *
f6cf 7e ec 65                     JMP  ec65(LBA1C)                GO NORMALIZE FPA0
                        * EVALUATE AN &H VARIABLE
f6d2 9d 7c              L881F     JSR  007c(GETNCH)               GET A CHARACTER FROM BASIC
f6d4 25 0b                        BLO  L882E                      BRANCH IF NUMERIC
f6d6 bd e6 26                     JSR  e626(LB3A2)                SET CARRY IF NOT ALPHA
f6d9 25 e6                        BLO  f6c1(L880E)                BRANCH IF NOT ALPHA OR NUMERIC
f6db 81 47                        CMPA #'G'                       CHECK FOR LETTERS A-F
f6dd 24 e2                        BCC  f6c1(L880E)                BRANCH IF >= G (ILLEGAL HEX LETTER)
f6df 80 07                        SUBA #7                         SUBTRACT ASCII DIFFERENCE BETWEEN A AND 9
f6e1 c6 04              L882E     LDB  #$04                       BASE 16 DIGIT MULTIPLIER = 2**4
f6e3 8d 02                        BSR  L8834                      ADD DIGIT TO TEMPORARY ACCUMULATOR
f6e5 20 eb                        BRA  f6d2(L881F)                KEEP EVALUATING VARIABLE
f6e7 68 01              L8834     ASL  $01,X                      * MULTIPLY TEMPORARY
f6e9 69 84                        ROL  ,X                         * ACCUMULATOR BY TWO
f6eb 10 25 f5 ec                  LBCS ecdb(LBA92)                'OV' OVERFLOW ERROR
f6ef 5a                           DECB                            DECREMENT SHIFT COUNTER
f6f0 26 f5                        BNE  f6e7(L8834)                MULTIPLY TEMPORARY ACCUMULATOR AGAIN
f6f2 80 30                        SUBA #'0'                       MASK OFF ASCII
f6f4 ab 01                        ADDA $01,X                      * ADD DIGIT TO TEMPORARY
f6f6 a7 01                        STA  $01,X                      * ACCUMULATOR AND SAVE IT
f6f8 39                 L8845     RTS

f6f9 35 40              XVEC15    PULS U                          PULL RETURN ADDRESS AND SAVE IN U REGISTER
f6fb 0f 06                        CLR  0006(VALTYP)               SET VARIABLE TYPE TO NUMERIC
f6fd 9e 83                        LDX  0083(CHARAD)               CURRENT INPUT POINTER TO X
f6ff 9d 7c                        JSR  007c(GETNCH)               GET CHARACTER FROM BASIC
f701 81 26                        CMPA #'&'                       HEX AND OCTAL VARIABLES ARE PRECEEDED BY &
f703 27 99                        BEQ  f69e(L87EB)                PROCESS A '&' VARIABLE
f705 81 b0                        CMPA #00b0(TOK_FN)              TOKEN FOR FN
f707 27 5e                        BEQ  L88B4                      PROCESS FN CALL
f709 81 ff                        CMPA #$FF                       CHECK FOR SECONDARY TOKEN
f70b 26 08                        BNE  L8862                      NOT SECONDARY
f70d 9d 7c                        JSR  007c(GETNCH)               GET CHARACTER FROM BASIC
f70f 81 83                        CMPA #0083(TOK_USR)             TOKEN FOR USR
f711 10 27 00 ab                  LBEQ L892C                      PROCESS USR CALL
f715 9f 83              L8862     STX  0083(CHARAD)               RESTORE BASIC'S INPUT POINTER
f717 6e c4                        JMP  ,U                         RETURN TO CALLING ROUTINE
f719 9e 68              L8866     LDX  0068(CURLIN)               GET CURRENT LINE NUMBER
f71b 30 01                        LEAX $01,X                      IN DIRECT MODE?
f71d 26 d9                        BNE  f6f8(L8845)                RETURN IF NOT IN DIRECT MODE
f71f c6 16                        LDB  #2*11                      'ILLEGAL DIRECT STATEMENT' ERROR
f721 7e df 03           L886E     JMP  df03(LAC46)                PROCESS ERROR

f724 ae 9f 00 83        DEF       LDX  [CHARAD]                   GET TWO INPUT CHARS
f728 8c ff 83                     CMPX #ff83(TOK_FF_USR)          TOKEN FOR USR
f72b 10 27 00 74                  LBEQ L890F                      BRANCH IF DEF USR
f72f 8d 23                        BSR  L88A1                      GET DESCRIPTOR ADDRESS FOR FN VARIABLE NAME
f731 8d e6                        BSR  f719(L8866)                DON'T ALLOW DEF FN IF IN DIRECT MODE
f733 bd e4 f3                     JSR  e4f3(LB26A)                SYNTAX CHECK FOR '('
f736 c6 80                        LDB  #$80                       * GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE
f738 d7 08                        STB  0008(ARYDIS)               * AND SAVE IT IN THE ARRAY DISABLE FLAG
f73a bd e5 db                     JSR  e5db(LB357)                GET VARIABLE DESCRIPTOR
f73d 8d 25                        BSR  L88B1                      'TM' ERROR IF STRING
f73f bd e4 f0                     JSR  e4f0(LB267)                SYNTAX CHECK FOR ')'
f742 c6 ae                        LDB  #00ae(TOK_EQUALS)          TOKEN FOR '='
f744 bd e4 f8                     JSR  e4f8(LB26F)                DO A SYNTAX CHECK FOR =
f747 9e 4b                        LDX  004b(V4B)                  GET THE ADDRESS OF THE FN NAME DESCRIPTOR
f749 dc 83                        LDD  0083(CHARAD)               * GET THE CURRENT INPUT POINTER ADDRESS AND
f74b ed 84                        STD  ,X                         * SAVE IT IN FIRST 2 BYTES OF THE DESCRIPTOR
f74d dc 39                        LDD  0039(VARPTR)               = GET THE DESCRIPTOR ADDRESS OF THE ARGUMENT
f74f ed 02                        STD  $02,X                      = VARIABLE AND SAVE IT IN THE DESCRIPTOR OF THE FN NAME
f751 7e e1 8d                     JMP  e18d(DATA)                 MOVE INPUT POINTER TO END OF LINE OR SUBLINE
f754 c6 b0              L88A1     LDB  #00b0(TOK_FN)              TOKEN FOR FN
f756 bd e4 f8                     JSR  e4f8(LB26F)                DO A SYNTAX CHECK FOR FN
f759 c6 80                        LDB  #$80                       * GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE FLAG
f75b d7 08                        STB  0008(ARYDIS)               * AND SAVE IT IN ARRAY VARIABLE FLAG
f75d 8a 80                        ORA  #$80                       SET BIT 7 OF CURRENT INPUT CHARACTER TO INDICATE AN FN VARIABLE
f75f bd e5 e0                     JSR  e5e0(LB35C)                * GET THE DESCRIPTOR ADDRESS OF THIS
f762 9f 4b                        STX  004b(V4B)                  * VARIABLE AND SAVE IT IN V4B
f764 7e e3 cc           L88B1     JMP  e3cc(LB143)                'TM' ERROR IF STRING VARIABLE
                        * EVALUATE AN FN CALL
f767 8d eb              L88B4     BSR  f754(L88A1)                * GET THE DESCRIPTOR OF THE FN NAME
f769 34 10                        PSHS X                          * VARIABLE AND SAVE IT ON THE STACK
f76b bd e4 eb                     JSR  e4eb(LB262)                SYNTAX CHECK FOR '(' & EVALUATE EXPR
f76e 8d f4                        BSR  f764(L88B1)                'TM' ERROR IF STRING VARIABLE
f770 35 40                        PULS U                          POINT U TO FN NAME DESCRIPTOR
f772 c6 32                        LDB  #2*25                      'UNDEFINED FUNCTION CALL' ERROR
f774 ae 42                        LDX  $02,U                      POINT X TO ARGUMENT VARIABLE DESCRIPTOR
f776 27 a9                        BEQ  f721(L886E)                BRANCH TO ERROR HANDLER
f778 10 9e 83                     LDY  0083(CHARAD)               SAVE CURRENT INPUT POINTER IN Y
f77b ee c4                        LDU  ,U                         * POINT U TO START OF FN FORMULA AND
f77d df 83                        STU  0083(CHARAD)               * SAVE IT IN INPUT POINTER
f77f a6 04                        LDA  $04,X                      = GET FP VALUE OF
f781 34 02                        PSHS A                          = ARGUMENT VARIABLE, CURRENT INPUT
f783 ec 84                        LDD  ,X                         = POINTER, AND ADDRESS OF START
f785 ee 02                        LDU  $02,X                      = OF FN FORMULA AND SAVE
f787 34 76                        PSHS U,Y,X,B,A                  = THEM ON THE STACK
f789 bd ee 7e                     JSR  ee7e(LBC35)                PACK FPA0 AND SAVE IT IN (X)
f78c bd e3 ca           L88D9     JSR  e3ca(LB141)                EVALUATE FN EXPRESSION
f78f 35 76                        PULS A,B,X,Y,U                  RESTORE REGISTERS
f791 ed 84                        STD  ,X                         * GET THE FP
f793 ef 02                        STU  $02,X                      * VALUE OF THE ARGUMENT
f795 35 02                        PULS A                          * VARIABLE OFF OF THE
f797 a7 04                        STA  $04,X                      * STACK AND RE-SAVE IT
f799 9d 82                        JSR  0082(GETCCH)               GET FINAL CHARACTER OF THE FN FORMULA
f79b 10 26 ed 61                  LBNE e500(LB277)                'SYNTAX' ERROR IF NOT END OF LINE
f79f 10 9f 83                     STY  0083(CHARAD)               RESTORE INPUT POINTER
f7a2 39                 L88EF     RTS



                        * DEF USR
f7a3 9d 7c              L890F     JSR  007c(GETNCH)               SKIP PAST SECOND BYTE OF DEF USR TOKEN
f7a5 8d 09                        BSR  L891C                      GET FN NUMBER
f7a7 34 10                        PSHS X                          SAVE FN EXEC ADDRESS STORAGE LOC
f7a9 8d 2d                        BSR  L8944                      CALCULATE EXEC ADDRESS
f7ab 35 40                        PULS U                          GET FN EXEC ADDRESS STORAGE LOC
f7ad af c4                        STX  ,U                         SAVE EXEC ADDRESS
f7af 39                           RTS
f7b0 5f                 L891C     CLRB                            DEFAULT TO USR0 IF NO ARGUMENT
f7b1 9d 7c                        JSR  007c(GETNCH)               GET A CHARACTER FROM BASIC
f7b3 24 06                        BCC  L8927                      BRANCH IF NOT NUMERIC
f7b5 80 30                        SUBA #'0'                       MASK OFF ASCII
f7b7 1f 89                        TFR  A,B                        SAVE USR NUMBER IN ACCB
f7b9 9d 7c                        JSR  007c(GETNCH)               GET A CHARACTER FROM BASIC
f7bb 9e 8d              L8927     LDX  008d(USRADR)               GET ADDRESS OF STORAGE LOCs FOR USR ADDRESS
f7bd 58                           ASLB                            X2 - 2 BYTES/USR ADDRESS
f7be 3a                           ABX                             ADD OFFSET TO START ADDRESS OF STORAGE LOCs
f7bf 39                           RTS
                        * PROCESS A USR CALL
f7c0 8d ee              L892C     BSR  f7b0(L891C)                GET STORAGE LOC OF EXEC ADDRESS FOR USR N
f7c2 ae 84                        LDX  ,X                         * GET EXEC ADDRESS AND
f7c4 34 10                        PSHS X                          * PUSH IT ONTO STACK
f7c6 bd e4 eb                     JSR  e4eb(LB262)                SYNTAX CHECK FOR '(' & EVALUATE EXPR
f7c9 8e 00 4f                     LDX  #004f(FP0EXP)              POINT X TO FPA0
f7cc 96 06                        LDA  0006(VALTYP)               GET VARIABLE TYPE
f7ce 27 07                        BEQ  L8943                      BRANCH IF NUMERIC, STRING IF <> 0
f7d0 bd e8 db                     JSR  e8db(LB657)                GET LENGTH & ADDRESS OF STRING VARIABLE
f7d3 9e 52                        LDX  0050(FPA0)+2               GET POINTER TO STRING DESCRIPTOR
f7d5 96 06                        LDA  0006(VALTYP)               GET VARIABLE TYPE
f7d7 39                 L8943     RTS                             JUMP TO USR ROUTINE (PSHS X ABOVE)
f7d8 c6 ae              L8944     LDB  #00ae(TOK_EQUALS)          TOKEN FOR '='
f7da bd e4 f8                     JSR  e4f8(LB26F)                DO A SYNTAX CHECK FOR =
f7dd 7e e9 c1                     JMP  e9c1(LB73D)                EVALUATE EXPRESSION, RETURN VALUE IN X



                        * DEL
f7e0 10 27 ee ea        DEL       LBEQ e6ce(LB44A)                FC' ERROR IF NO ARGUMENT
f7e4 bd e2 14                     JSR  e214(LAF67)                CONVERT A DECIMAL BASiC NUMBER TO BINARY
f7e7 bd df a2                     JSR  dfa2(LAD01)                FIND RAM ADDRESS OF START OF A BASIC LINE
f7ea 9f 93                        STX  0093(VD3)                  SAVE RAM ADDRESS OF STARTING LINE NUMBER
f7ec 9d 82                        JSR  0082(GETCCH)               GET CURRENT INPUT CHARACTER
f7ee 27 10                        BEQ  L8990                      BRANCH IF END OF LINE
f7f0 81 a7                        CMPA #00a7(TOK_MINUS)           TOKEN FOR '-'
f7f2 26 3b                        BNE  L89BF                      TERMINATE COMMAND IF LINE NUMBER NOT FOLLOWED BY '-'
f7f4 9d 7c                        JSR  007c(GETNCH)               GET A CHARACTER FROM BASIC
f7f6 27 04                        BEQ  L898C                      IF END OF LINE, USE DEFAULT ENDING LINE NUMBER
f7f8 8d 24                        BSR  L89AE                      * CONVERT ENDING LINE NUMBER TO BINARY
f7fa 20 04                        BRA  L8990                      * AND SAVE IT IN BINVAL
f7fc 86 ff              L898C     LDA  #$FF                       = USE $FFXX AS DEFAULT ENDING
f7fe 97 2b                        STA  002b(BINVAL)               = LINE NUMBER - SAVE IT IN BINVAL
f800 de 93              L8990     LDU  0093(VD3)                  POINT U TO STARTING LINE NUMBER ADDRESS
f802 8c                 L8992     FCB  008c(SKP2)                 SKIP TWO BYTES
f803 ee c4              L8993     LDU  ,U                         POINT U TO START OF NEXT LINE
f805 ec c4                        LDD  ,U                         CHECK FOR END OF PROGRAM
f807 27 06                        BEQ  L899F                      BRANCH IF END OF PROGRAM
f809 ec 42                        LDD  $02,U                      LOAD ACCD WITH THIS LINE'S NUMBER
f80b 93 2b                        SUBD 002b(BINVAL)               SUBTRACT ENDING LINE NUMBER ADDRESS
f80d 23 f4                        BLS  f803(L8993)                BRANCH IF = < ENDING LINE NUMBER
f80f 9e 93              L899F     LDX  0093(VD3)                  GET STARTING LINE NUMBER
f811 8d 15                        BSR  L89B8                      MOVE (U) TO (X) UNTIL END OF PROGRAM
f813 bd df c2                     JSR  dfc2(LAD21)                RESET BASIC'S INPUT POINTER AND ERASE VARIABLES
f816 9e 93                        LDX  0093(VD3)                  GET STARTING LINE NUMBER ADDRESS
f818 bd df 92                     JSR  df92(LACF1)                RECOMPUTE START OF NEXT LINE ADDRESSES
f81b 7e df 22                     JMP  df22(LAC73)                JUMP TO BASIC'S MAIN COMMAND LOOP
f81e bd e2 14           L89AE     JSR  e214(LAF67)                GO GET LINE NUMBER CONVERTED TO BINARY
f821 7e dc b7                     JMP  dcb7(LA5C7)                MAKE SURE THERE'S NO MORE ON THIS LINE
f824 a6 c0              L89B4     LDA  ,U+                        GET A BYTE FROM (U)
f826 a7 80                        STA  ,X+                        MOVE THE BYTE TO (X)
f828 11 93 1b           L89B8     CMPU 001b(VARTAB)               COMPARE TO END OF BASIC
f82b 26 f7                        BNE  f824(L89B4)                BRANCH IF NOT AT END
f82d 9f 1b                        STX  001b(VARTAB)               SAVE (X) AS NEW END OF BASIC
f82f 39                 L89BF     RTS


f830 bd f7 19           L89C0     JSR  f719(L8866)                'BS' ERROR IF IN DIRECT MODE
f833 9d 7c                        JSR  007c(GETNCH)               GET A CHAR FROM BASIC
f835 81 22              L89D2     CMPA #'"'                       CHECK FOR PROMPT STRING
f837 26 0b                        BNE  L89E1                      BRANCH IF NO PROMPT STRING
f839 bd e4 cd                     JSR  e4cd(LB244)                STRIP OFF PROMPT STRING & PUT IT ON STRING STACK
f83c c6 3b                        LDB  #';'                       *
f83e bd e4 f8                     JSR  e4f8(LB26F)                * DO A SYNTAX CHECK FOR;
f841 bd eb e8                     JSR  ebe8(LB99F)                REMOVE PROMPT STRING FROM STRING STACK & SEND TO CONSOLE OUT
f844 32 7e              L89E1     LEAS $-02,S                     RESERVE TWO STORAGE SLOTS ON STACK
f846 bd e2 c9                     JSR  e2c9(LB035)                INPUT A LINE FROM CURRENT INPUT DEVICE
f849 32 62                        LEAS $02,S                      CLEAN UP THE STACK
f84b bd e5 db                     JSR  e5db(LB357)                SEARCH FOR A VARIABLE
f84e 9f 3b                        STX  003b(VARDES)               SAVE POINTER TO VARIABLE DESCRIPTOR
f850 bd e3 cf                     JSR  e3cf(LB146)                'TM' ERROR IF VARIABLE TYPE = NUMERIC
f853 8e 00 f3                     LDX  #00f3(LINBUF)              POINT X TO THE STRING BUFFER WHERE THE INPUT STRING WAS STORED
f856 4f                           CLRA                            TERMINATOR CHARACTER 0 (END OF LINE)
f857 bd e7 a0                     JSR  e7a0(LB51A)                PARSE THE INPUT STRING AND STORE IT IN THE STRING SPACE
f85a 7e e2 51                     JMP  e251(LAFA4)                REMOVE DESCRIPTOR FROM STRING STACK
f85d bd e2 14           L89FC     JSR  e214(LAF67)                STRIP A DECIMAL NUMBER FROM BASIC INPUT LINE
f860 9e 2b                        LDX  002b(BINVAL)               GET BINARY VALUE
f862 39                           RTS
f863 9e 91              L8A02     LDX  0091(VD1)                  GET CURRENT OLD NUMBER BEING RENUMBERED
f865 9f 2b              L8A04     STX  002b(BINVAL)               SAVE THE LINE NUMBER BEING SEARCHED FOR
f867 7e df a2                     JMP  dfa2(LAD01)                GO FIND THE LINE NUMBER IN BASIC PROGRAM

                        * RENUM
f86a bd df c7           RENUM     JSR  dfc7(LAD26)                ERASE VARIABLES
f86d cc 00 0a                     LDD  #10                        DEFAULT LINE NUMBER INTERVAL
f870 dd 95                        STD  0095(VD5)                  SAVE DEFAULT RENUMBER START LINE NUMBER
f872 dd 8f                        STD  008f(VCF)                  SAVE DEFAULT INTERVAL
f874 5f                           CLRB                            NOW ACCD = 0
f875 dd 91                        STD  0091(VD1)                  DEFAULT LINE NUMBER OF WHERE TO START RENUMBERING
f877 9d 82                        JSR  0082(GETCCH)               GET CURRENT INPUT CHARACTER
f879 24 06                        BCC  L8A20                      BRANCH IF NOT NUMERIC
f87b 8d e0                        BSR  f85d(L89FC)                CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
f87d 9f 95                        STX  0095(VD5)                  SAVE LINE NUMBER WHERE RENUMBERING STARTS
f87f 9d 82                        JSR  0082(GETCCH)               GET CURRENT INPUT CHARACTER
f881 27 1b              L8A20     BEQ  L8A3D                      BRANCH IF END OF LINE
f883 bd e4 f6                     JSR  e4f6(LB26D)                SYNTAX CHECK FOR COMMA
f886 24 06                        BCC  L8A2D                      BRANCH IF NEXT CHARACTER NOT NUMERIC
f888 8d d3                        BSR  f85d(L89FC)                CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
f88a 9f 91                        STX  0091(VD1)                  SAVE NEW RENUMBER LINE
f88c 9d 82                        JSR  0082(GETCCH)               GET CURRENT INPUT CHARACTER
f88e 27 0e              L8A2D     BEQ  L8A3D                      BRANCH IF END OF LINE
f890 bd e4 f6                     JSR  e4f6(LB26D)                SYNTAX CHECK FOR COMMA
f893 24 06                        BCC  L8A3A                      BRANCH IF NEXT CHARACTER NOT NUMERIC
f895 8d c6                        BSR  f85d(L89FC)                CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
f897 9f 8f                        STX  008f(VCF)                  SAVE NEW INTERVAL
f899 27 49                        BEQ  L8A83                      'FC' ERROR
f89b bd dc b7           L8A3A     JSR  dcb7(LA5C7)                CHECK FOR MORE CHARACTERS ON LINE - 'SYNTAX' ERROR IF ANY
f89e 8d c3              L8A3D     BSR  f863(L8A02)                GO GET ADDRESS OF OLD NUMBER BEING RENUMBERED
f8a0 9f 93                        STX  0093(VD3)                  SAVE ADDRESS
f8a2 9e 95                        LDX  0095(VD5)                  GET NEXT RENUMBERED LINE NUMBER TO USE
f8a4 8d bf                        BSR  f865(L8A04)                FIND THE LINE NUMBER IN THE BASIC PROGRAM
f8a6 9c 93                        CMPX 0093(VD3)                  COMPARE TO ADDRESS OF OLD LINE NUMBER
f8a8 25 3a                        BLO  L8A83                      'FC' ERROR IF NEW ADDRESS < OLD ADDRESS
f8aa 8d 1c                        BSR  L8A67                      MAKE SURE RENUMBERED LINE NUMBERS WILL BE IN RANGE
f8ac bd f9 3e                     JSR  L8ADD                      CONVERT ASCII LINE NUMBERS TO 'EXPANDED' BINARY
f8af bd df 90                     JSR  df90(LACEF)                RECALCULATE NEXT LINE RAM ADDRESSES
f8b2 8d af                        BSR  f863(L8A02)                GET RAM ADDRESS OF FIRST LINE TO BE RENUMBERED
f8b4 9f 93                        STX  0093(VD3)                  SAVE IT
f8b6 8d 3a                        BSR  L8A91                      MAKE SURE LINE NUMBERS EXIST
f8b8 8d 0f                        BSR  L8A68                      INSERT NEW LINE NUMBERS IN LINE HEADERS
f8ba 8d 36                        BSR  L8A91                      INSERT NEW LINE NUMBERS IN PROGRAM STATEMENTS
f8bc bd f9 d9                     JSR  L8B7B                      CONVERT PACKED BINARY LINE NUMBERS TO ASCII
f8bf bd df c7                     JSR  dfc7(LAD26)                ERASE VARIABLES
f8c2 bd df 90                     JSR  df90(LACEF)                RECALCULATE NEXT LINE RAM ADDRESS
f8c5 7e df 22                     JMP  df22(LAC73)                GO BACK TO BASIC'S MAIN LOOP
f8c8 86                 L8A67     FCB  0086(SKP1LD)               SKIP ONE BYTE - LDA #$4F
f8c9 4f                 L8A68     CLRA                            NEW LINE NUMBER FLAG - 0; INSERT NEW LINE NUMBERS
f8ca 97 98                        STA  0098(VD8)                  SAVE NEW LINE NUMBER FLAG; 0 = INSERT NEW NUMBERS
f8cc 9e 93                        LDX  0093(VD3)                  GET ADDRESS OF OLD LINE NUMBER BEING RENUMBERED
f8ce dc 95                        LDD  0095(VD5)                  GET THE CURRENT RENUMBERED LINE NUMBER
f8d0 8d 15                        BSR  L8A86                      RETURN IF END OF PROGRAM
f8d2 0d 98              L8A71     TST  0098(VD8)                  CHECK NEW LINE NUMBER FLAG
f8d4 26 02                        BNE  L8A77                      BRANCH IF NOT INSERTING NEW LINE NUMBERS
f8d6 ed 02                        STD  $02,X                      STORE THE NEW LINE NUMBER IN THE BASIC PROGRAM
f8d8 ae 84              L8A77     LDX  ,X                         POINT X TO THE NEXT LINE IN BASIC
f8da 8d 0b                        BSR  L8A86                      RETURN IF END OF PROGRAM
f8dc d3 8f                        ADDD 008f(VCF)                  ADD INTERVAL TO CURRENT RENUMBERED LINE NUMBER
f8de 25 04                        BLO  L8A83                      'FC' ERROR IF LINE NUMBER > $FFFF
f8e0 81 fa                        CMPA #00fa(MAXLIN)              LARGEST LINE NUMBER = $F9FF
f8e2 25 ee                        BLO  f8d2(L8A71)                BRANCH IF LEGAL LINE NUMBER
f8e4 7e e6 ce           L8A83     JMP  e6ce(LB44A)                'FC' ERROR IF LINE NUMBER MS BYTE > $F9
                        * TEST THE TWO BYTES POINTED TO BY (X).
                        * NORMAL RETURN IF <> 0. IF = 0 (END OF
                        * PROGRAM) RETURN IS PULLED OFF STACK AND
                        * YOU RETURN TO PREVIOUS SUBROUTINE CALL.
f8e7 34 06              L8A86     PSHS B,A                        SAVE ACCD
f8e9 ec 84                        LDD  ,X                         TEST THE 2 BYTES POINTED TO BY X
f8eb 35 06                        PULS A,B                        RESTORE ACCD
f8ed 26 02                        BNE  L8A90                      BRANCH IF NOT END OF PROGRAM
f8ef 32 62                        LEAS $02,S                      PURGE RETURN ADDRESS FROM STACK
f8f1 39                 L8A90     RTS
f8f2 9e 19              L8A91     LDX  0019(TXTTAB)               GET START OF BASIC PROGRAM
f8f4 30 1f                        LEAX $-01,X                     MOVE POINTER BACK ONE
f8f6 30 01              L8A95     LEAX $01,X                      MOVE POINTER UP ONE
f8f8 8d ed                        BSR  f8e7(L8A86)                RETURN IF END OF PROGRAM
f8fa 30 03              L8A99     LEAX $03,X                      SKIP OVER NEXT LINE ADDRESS AND LINE NUMBER
f8fc 30 01              L8A9B     LEAX $01,X                      MOVE POINTER TO NEXT CHARACTER
f8fe a6 84                        LDA  ,X                         CHECK CURRENT CHARACTER
f900 27 f4                        BEQ  f8f6(L8A95)                BRANCH IF END OF LINE
f902 9f 0f                        STX  000f(TEMPTR)               SAVE CURRENT POINTER
f904 4a                           DECA                            =
f905 27 0c                        BEQ  L8AB2                      =BRANCH IF START OF PACKED NUMERIC LINE
f907 4a                           DECA                            *
f908 27 2a                        BEQ  L8AD3                      *BRANCH IF LINE NUMBER EXISTS
f90a 4a                           DECA                            =
f90b 26 ef                        BNE  f8fc(L8A9B)                =MOVE TO NEXT CHARACTER IF > 3
f90d 86 03              L8AAC     LDA  #$03                       * SET 1ST BYTE = 3 TO INDICATE LINE
f90f a7 80                        STA  ,X+                        * NUMBER DOESN'T CURRENTLY EXIST
f911 20 e7                        BRA  f8fa(L8A99)                GO GET ANOTHER CHARACTER
f913 ec 01              L8AB2     LDD  $01,X                      GET MS BYTE OF LINE NUMBER
f915 6a 02                        DEC  $02,X                      DECREMENT ZERO CHECK BYTE
f917 27 01                        BEQ  L8AB9                      BRANCH IF MS BYTE <> 0
f919 4f                           CLRA                            CLEAR MS BYTE
f91a e6 03              L8AB9     LDB  $03,X                      GET LS BYTE OF LINE NUMBER
f91c 6a 04                        DEC  $04,X                      DECREMENT ZERO CHECK FLAG
f91e 27 01                        BEQ  L8AC0                      BRANCH IF IS BYTE <> 0
f920 5f                           CLRB                            CLEAR LS BYTE
f921 ed 01              L8AC0     STD  $01,X                      SAVE BINARY LINE NUMBER
f923 dd 2b                        STD  002b(BINVAL)               SAVE TRIAL LINE NUMBER
f925 bd df a2                     JSR  dfa2(LAD01)                FIND RAM ADDRESS OF A BASIC LINE NUMBER
f928 9e 0f              L8AC7     LDX  000f(TEMPTR)               GET BACK POINTER TO START OF PACKED LINE NUMBER
f92a 25 e1                        BLO  f90d(L8AAC)                BRANCH IF NO LINE NUMBER MATCH FOUND
f92c dc 47                        LDD  0047(V47)                  GET START ADDRESS OF LINE NUMBER
f92e 6c 80                        INC  ,X+                        * SET 1ST BYTE = 2, TO INDICATE LINE NUMBER EXISTS IF CHECKING FOR
                        *              * EXISTENCE OF LINE NUMBER, SET IT = 1 IF INSERTING LINE NUMBERS

f930 ed 84                        STD  ,X                         SAVE RAM ADDRESS OF CORRECT LINE NUMBER
f932 20 c6                        BRA  f8fa(L8A99)                GO GET ANOTHER CHARACTER
f934 6f 84              L8AD3     CLR  ,X                         CLEAR CARRY FLAG AND 1ST BYTE
f936 ae 01                        LDX  $01,X                      POINT X TO RAM ADDRESS OF CORRECT LINE NUMBER
f938 ae 02                        LDX  $02,X                      PUT CORRECT LINE NUMBER INTO (X)
f93a 9f 47                        STX  0047(V47)                  SAVE IT TEMPORARILY
f93c 20 ea                        BRA  f928(L8AC7)                GO INSERT IT INTO BASIC LINE
f93e 9e 19              L8ADD     LDX  0019(TXTTAB)               GET BEGINNING OF BASIC PROGRAM
f940 20 04                        BRA  L8AE5
f942 9e 83              L8AE1     LDX  0083(CHARAD)               *GET CURRENT INPUT POINTER
f944 30 01                        LEAX $01,X                      *AND BUMP IT ONE
f946 8d 9f              L8AE5     BSR  f8e7(L8A86)                RETURN IF END OF PROGRAM
f948 30 02                        LEAX $02,X                      SKIP PAST NEXT LINE ADDRESS
f94a 30 01              L8AE9     LEAX $01,X                      ADVANCE POINTER BY ONE
f94c 9f 83              L8AEB     STX  0083(CHARAD)               SAVE NEW BASIC INPUT POINTER
f94e 9d 7c              L8AED     JSR  007c(GETNCH)               GET NEXT CHARACTER FROM BASIC
f950 4d                 L8AEF     TSTA                            CHECK THE CHARACTER
f951 27 ef                        BEQ  f942(L8AE1)                BRANCH IF END OF LINE
f953 2a f9                        BPL  f94e(L8AED)                BRANCH IF NOT A TOKEN
f955 9e 83                        LDX  0083(CHARAD)               GET CURRENT INPUT POINTER
f957 81 ff                        CMPA #$FF                       IS THIS A SECONDARY TOKEN?
f959 27 ef                        BEQ  f94a(L8AE9)                YES - IGNORE IT
f95b 81 a2                        CMPA #00a2(TOK_THEN)            TOKEN FOR THEN?
f95d 27 12                        BEQ  L8B13                      YES
f95f 81 84                        CMPA #0084(TOK_ELSE)            TOKEN FOR ELSE?
f961 27 0e                        BEQ  L8B13                      YES
f963 81 81                        CMPA #0081(TOK_GO)              TOKEN FOR GO?
f965 26 e7                        BNE  f94e(L8AED)                NO
f967 9d 7c                        JSR  007c(GETNCH)               GET A CHARACTER FROM BASIC
f969 81 a0                        CMPA #00a0(TOK_TO)              TOKEN FOR TO?
f96b 27 04                        BEQ  L8B13                      YES
f96d 81 a1                        CMPA #00a1(TOK_SUB)             TOKEN FOR SUB?
f96f 26 db                        BNE  f94c(L8AEB)                NO
f971 9d 7c              L8B13     JSR  007c(GETNCH)               GET A CHARACTER FROM BASIC
f973 25 04                        BLO  L8B1B                      BRANCH IF NUMERIC
f975 9d 82              L8B17     JSR  0082(GETCCH)               GET CURRENT BASIC INPUT CHARRACTER
f977 20 d7                        BRA  f950(L8AEF)                KEEP CHECKING THE LINE
f979 9e 83              L8B1B     LDX  0083(CHARAD)               GET CURRENT INPUT ADDRESS
f97b 34 10                        PSHS X                          SAVE IT ON THE STACK
f97d bd e2 14                     JSR  e214(LAF67)                CONVERT DECIMAL BASIC NUMBER TO BINARY
f980 9e 83                        LDX  0083(CHARAD)               GET CURRENT INPUT POINTER
f982 a6 82              L8B24     LDA  ,-X                        GET PREVIOUS INPUT CHARACTER
f984 bd fc e9                     JSR  L90AA                      CLEAR CARRY IF NUMERIC INPUT VALUE
f987 25 f9                        BLO  f982(L8B24)                BRANCH IF NON-NUMERIC
f989 30 01                        LEAX $01,X                      MOVE POINTER UP ONE
f98b 1f 10                        TFR  X,D                        NOW ACCD POINTS TO ONE PAST END OF LINE NUMBER
f98d e0 61                        SUBB $01,S                      SUBTRACT PRE-NUMERIC POINTER LS BYTE
f98f c0 05                        SUBB #$05                       MAKE SURE THERE ARE AT LEAST 5 CHARACTERS IN THE NUMERIC LINE
                        *
f991 27 20                        BEQ  L8B55                      BRANCH IF EXACTLY 5
f993 25 0a                        BLO  L8B41                      BRANCH IF < 5
f995 33 84                        LEAU ,X                         TRANSFER X TO U
f997 50                           NEGB                            NEGATE B
f998 30 85                        LEAX B,X                        MOVE X BACK B BYTES
f99a bd f8 28                     JSR  f828(L89B8)                *MOVE BYTES FROM (U) TO (X) UNTIL
                        *         *U   = END OF BASIC; (I) = NEW END OF BASIC
f99d 20 14                        BRA  L8B55
                        * FORCE FIVE BYTES OF SPACE FOR THE LINE NUMBER
f99f 9f 47              L8B41     STX  0047(V47)                  SAVE END OF NUMERIC VALUE
f9a1 9e 1b                        LDX  001b(VARTAB)               GET END OF BASIC PROGRAM
f9a3 9f 43                        STX  0043(V43)                  SAVE IT
f9a5 50                           NEGB                            NEGATE B
f9a6 30 85                        LEAX B,X                        ADD IT TO END OF NUMERIC POiNTER
f9a8 9f 41                        STX  0041(V41)                  SAVE POINTER
f9aa 9f 1b                        STX  001b(VARTAB)               STORE END OF BASIC PROGRAM
f9ac bd de db                     JSR  dedb(LAC1E)                ACCD = TOP OF ARRAYS - CHECK FOR ENOUGH ROOM
f9af 9e 45                        LDX  0045(V45)                  * GET AND SAVE THE
f9b1 9f 83                        STX  0083(CHARAD)               * NEW CURRENT INPUT POINTER
f9b3 35 10              L8B55     PULS X                          RESTORE POINTER TO START OF NUMERIC VALUE
f9b5 86 01                        LDA  #$01                       NEW LINE NUMBER FLAG
f9b7 a7 84                        STA  ,X                         * SAVE NEW LINE FLAG
f9b9 a7 02                        STA  $02,X                      *
f9bb a7 04                        STA  $04,X                      *
f9bd d6 2b                        LDB  002b(BINVAL)               GET MS BYTE OF BINARY LINE NUMBER
f9bf 26 04                        BNE  L8B67                      BRANCH IF IT IS NOT ZERO
f9c1 c6 01                        LDB  #$01                       SAVE A 1 IF BYTE IS 0; OTHERWISE, BASIC WILL
                        *              THINK IT IS THE END OF A LINE
f9c3 6c 02                        INC  $02,X                      IF 2,X = 2, THEN PREVIOUS BYTE WAS A ZERO
f9c5 e7 01              L8B67     STB  $01,X                      SAVE MS BYTE OF BINARY LINE NUMBER
f9c7 d6 2c                        LDB  002b(BINVAL)+1             GET IS BYTE OF BINARY LINE NUMBER
f9c9 26 04                        BNE  L8B71                      BRANCH IF NOT A ZERO BYTE
f9cb c6 01                        LDB  #$01                       SAVE A 1 IF BYTE IS A 0
f9cd 6c 04                        INC  $04,X                      IF 4,X = 2, THEN PREVIOUS BYTE WAS A 0
f9cf e7 03              L8B71     STB  $03,X                      SAVE LS BYTE OF BINARY LINE NUMBER
f9d1 9d 82                        JSR  0082(GETCCH)               GET CURRENT INPUT CHARACTER
f9d3 81 2c                        CMPA #','                       IS IT A COMMA?
f9d5 27 9a                        BEQ  f971(L8B13)                YES - PROCESS ANOTHER NUMERIC VALUE
f9d7 20 9c                        BRA  f975(L8B17)                NO - GO GET AND PROCESS AN INPUT CHARACTER
f9d9 9e 19              L8B7B     LDX  0019(TXTTAB)               POINT X TO START OF BASIC PROGRAM
f9db 30 1f                        LEAX $-01,X                     MOVE POINTER BACK ONE
f9dd 30 01              L8B7F     LEAX $01,X                      MOVE POINTER UP ONE
f9df ec 02                        LDD  $02,X                      GET ADDRESS OF NEXT LINE
f9e1 dd 68                        STD  0068(CURLIN)               SAVE IT IN CURLIN
f9e3 bd f8 e7                     JSR  f8e7(L8A86)                RETURN IF END OF PROGRAM
f9e6 30 03                        LEAX $03,X                      SKIP OVER ADDRESS OF NEXT LINE AND 1ST BYTE OF LINE NUMBER
f9e8 30 01              L8B8A     LEAX $01,X                      MOVE POINTER UP ONE
f9ea a6 84              L8B8C     LDA  ,X                         GET CURRENT CHARACTER
f9ec 27 ef                        BEQ  f9dd(L8B7F)                BRANCH IF END OF LINE
f9ee 4a                           DECA                            INPUT CHARACTER = 1? - VALID LINE NUMBER
f9ef 27 1b                        BEQ  L8BAE                      YES
f9f1 80 02                        SUBA #$02                       INPUT CHARACTER 3? - UL LINE NUMBER
f9f3 26 f3                        BNE  f9e8(L8B8A)                NO
f9f5 34 10                        PSHS X                          SAVE CURRENT POSITION OF INPUT POINTER
f9f7 8e fa 36                     LDX  #L8BD9-1                   POINT X TO 'UL' MESSAGE
f9fa bd eb e5                     JSR  ebe5(LB99C)                PRINT STRING TO THE SCREEN
f9fd ae e4                        LDX  ,S                         GET INPUT POINTER
f9ff ec 01                        LDD  $01,X                      GET THE UNDEFINED LINE NUMBER
fa01 bd f0 15                     JSR  f015(LBDCC)                CONVERT NUMBER IN ACCD TO DECIMAL AND DISPLAY IT
fa04 bd f0 0e                     JSR  f00e(LBDC5)                PRINT 'IN XXXX' XXXX = CURRENT LINE NUMBER
fa07 bd eb a5                     JSR  eba5(LB958)                SEND A CR TO CONSOLE OUT
fa0a 35 10                        PULS X                          GET INPUT POINTER BACK
fa0c 34 10              L8BAE     PSHS X                          SAVE CURRENT POSITION OF INPUT POINTER
fa0e ec 01                        LDD  $01,X                      LOAD ACCD WITH BINARY VALUE OF LINE NUMBER
fa10 dd 52                        STD  0050(FPA0)+2               SAVE IN BOTTOM 2 BYTES OF FPA0
fa12 bd f6 c1                     JSR  f6c1(L880E)                ADJUST REST OF FPA0 AS AN INTEGER
fa15 bd f0 22                     JSR  f022(LBDD9)                CONVERT FPA0 TO ASCII, STORE IN LINE NUMBER
fa18 35 40                        PULS U                          LOAD U WITH PREVIOUS ADDRESS OF INPUT POINTER
fa1a c6 05                        LDB  #$05                       EACH EXPANDED LINE NUMBER USES 5 BYTES
fa1c 30 01              L8BBE     LEAX $01,X                      MOVE POINTER FORWARD ONE
fa1e a6 84                        LDA  ,X                         GET AN ASCII BYTE
fa20 27 05                        BEQ  L8BC9                      BRANCH IF END OF NUMBER
fa22 5a                           DECB                            DECREMENT BYTE COUNTER
fa23 a7 c0                        STA  ,U+                        STORE ASCII NUMBER IN BASIC LINE
fa25 20 f5                        BRA  fa1c(L8BBE)                CHECK FOR ANOTHER DIGIT
fa27 30 c4              L8BC9     LEAX ,U                         TRANSFER NEW LINE POINTER TO (X)
fa29 5d                           TSTB DOES THE NEW LI            NE NUMBER REQUIRE 5 BYTES?
fa2a 27 be                        BEQ  f9ea(L8B8C)                YES - GO GET ANOTHER INPUT CHARACTER
fa2c 31 c4                        LEAY ,U                         SAVE NEW LINE POINTER IN Y
fa2e 33 c5                        LEAU B,U                        POINT U TO END OF 5 BYTE PACKED LINE NUMBER BLOCK
fa30 bd f8 28                     JSR  f828(L89B8)                MOVE BYTES FROM (U) TO (X) UNTIL END OF PROGRAM
fa33 30 a4                        LEAX ,Y                         LOAD (X) WITH NEW LINE POINTER
fa35 20 b3                        BRA  f9ea(L8B8C)                GO GET ANOTHER INPUT CHARACTER

fa37 55 4c 20           L8BD9     FCC  "UL "                      UNKNOWN LINE NUMBER MESSAGE
fa3a 00                           FCB  0


fa3b bd e9 c4           HEXDOL    JSR  e9c4(LB740)                CONVERT FPA0 INTO A POSITIVE 2 BYTE INTEGER
fa3e 8e 01 f0                     LDX  #01ee(STRBUF)+2            POINT TO TEMPORARY BUFFER
fa41 c6 04                        LDB  #$04                       CONVERT 4 NIBBLES
fa43 34 04              L8BE5     PSHS B                          SAVE NIBBLE COUNTER
fa45 5f                           CLRB                            CLEAR CARRY FLAG
fa46 86 04                        LDA  #$04                       4 SHIFTS
fa48 08 53              L8BEA     ASL  0050(FPA0)+3               * SHIFT BOTTOM TWO BYTES OF
fa4a 09 52                        ROL  0050(FPA0)+2               * FPA0 LEFT ONE BIT (X2)
fa4c 59                           ROLB                            IF OVERFLOW, ACCB <> 0
fa4d 4a                           DECA                            * DECREMENT SHIFT COUNTER AND
fa4e 26 f8                        BNE  fa48(L8BEA)                * BRANCH IF NOT DONE
fa50 5d                           TSTB CHECK FOR OVERF            LOW
fa51 26 0a                        BNE  L8BFF                      BRANCH IF OVERFLOW
fa53 a6 e4                        LDA  ,S                         * GET NIBBLE COUNTER,
fa55 4a                           DECA                            * DECREMENT IT AND
fa56 27 05                        BEQ  L8BFF                      * BRANCH IF DONE
fa58 8c 01 f0                     CMPX #01ee(STRBUF)+2            DO NOT DO A CONVERSION UNTIL A NON-ZERO
fa5b 27 0c                        BEQ  L8C0B                      BYTE IS FOUND - LEADING ZERO SUPPRESSION
fa5d cb 30              L8BFF     ADDB #'0'                       ADD IN ASCII ZERO
fa5f c1 39                        CMPB #'9'                       COMPARE TO ASCII 9
fa61 23 02                        BLS  L8C07                      BRANCH IF < 9
fa63 cb 07                        ADDB #7                         ADD ASCII OFFSET IF HEX LETTER
fa65 e7 80              L8C07     STB  ,X+                        STORE HEX VALUE AND ADVANCE POINTER
fa67 6f 84                        CLR  ,X                         CLEAR NEXT BYTE - END OF STRING FLAG
fa69 35 04              L8C0B     PULS B                          * GET NIBBLE COUNTER,
fa6b 5a                           DECB                            * DECREMENT IT AND
fa6c 26 d5                        BNE  fa43(L8BE5)                * BRANCH IF NOT DONE
fa6e 32 62                        LEAS $02,S                      PURGE RETURN ADDRESS OFF OF STACK
fa70 8e 01 ef                     LDX  #01ee(STRBUF)+1            RESET POINTER
fa73 7e e7 9c                     JMP  e79c(LB518)                SAVE STRING ON STRING STACK
                        * PROCESS EXCLAMATION POINT
fa76 86 01              L8E37     LDA  #$01                       * SET SPACES
fa78 97 99                        STA  0099(VD9)                  * COUNTER = 1
                        * PROCESS STRING ITEM - LIST
fa7a 5a                 L8E3B     DECB                            DECREMENT FORMAT STRING LENGTH COUNTER
fa7b bd fc 17                     JSR  L8FD8                      SEND A '+' TO CONSOLE OUT IF VDA <>0
fa7e 9d 82                        JSR  0082(GETCCH)               GET CURRENT INPUT CHARACTER
fa80 10 27 00 93                  LBEQ L8ED8                      EXIT PRINT USING IF END OF LINE
fa84 d7 93                        STB  0093(VD3)                  SAVE REMAINDER FORMAT STRING LENGTH
fa86 bd e3 df                     JSR  e3df(LB156)                EVALUATE EXPRESSION
fa89 bd e3 cf                     JSR  e3cf(LB146)                'TM' ERROR IF NUMERIC VARIABLE
fa8c 9e 52                        LDX  0050(FPA0)+2               * GET ITEM - LIST DESCRIPTOR ADDRESS
fa8e 9f 4d                        STX  004d(V4D)                  * AND SAVE IT IN V4D
fa90 d6 99                        LDB  0099(VD9)                  GET SPACES COUNTER
fa92 bd e9 31                     JSR  e931(LB6AD)                PUT ACCB BYTES INTO STRING SPACE & PUT DESCRIPTOR ON STRING STACK
fa95 bd eb e8                     JSR  ebe8(LB99F)                PRINT THE FORMATTED STRING TO CONSOLE OUT
                        * PAD FORMAT STRING WITH SPACES IF ITEM - LIST STRING < FORMAT STRING LENGTH
fa98 9e 52                        LDX  0050(FPA0)+2               POINT X TO FORMATTED STRING DESCRIPTOR ADDRESS
fa9a d6 99                        LDB  0099(VD9)                  GET SPACES COUNTER
fa9c e0 84                        SUBB ,X                         SUBTRACT LENGTH OF FORMATTED STRING
fa9e 5a                 L8E5F     DECB                            DECREMENT DIFFERENCE
fa9f 10 2b 01 4f                  LBMI L8FB3                      GO INTERPRET ANOTHER ITEM - LIST
faa3 bd eb f5                     JSR  ebf5(LB9AC)                PAD FORMAT STRING WITH A SPACE
faa6 20 f6                        BRA  fa9e(L8E5F)                KEEP PADDING
                        * PERCENT SIGN - PROCESS A %SPACES% COMMAND
faa8 d7 93              L8E69     STB  0093(VD3)                  * SAVE THE CURRENT FORMAT STRING
faaa 9f 0f                        STX  000f(TEMPTR)               * COUNTER AND POINTER
faac 86 02                        LDA  #$02                       INITIAL SPACES COUNTER = 2
faae 97 99                        STA  0099(VD9)                  SAVE IN SPACES COUNTER
fab0 a6 84              L8E71     LDA  ,X                         GET A CHARACTER FROM FORMAT STRING
fab2 81 25                        CMPA #'%'                       COMPARE TO TERMINATOR CHARACTER
fab4 27 c4                        BEQ  fa7a(L8E3B)                BRANCH IF END OF SPACES COMMAND
fab6 81 20                        CMPA #' '                       BLANK
fab8 26 07                        BNE  L8E82                      BRANCH IF ILLEGAL CHARACTER
faba 0c 99                        INC  0099(VD9)                  ADD ONE TO SPACES COUNTER
fabc 30 01                        LEAX $01,X                      MOVE FORMAT POINTER UP ONE
fabe 5a                           DECB                            DECREMENT LENGTH COUNTER
fabf 26 ef                        BNE  fab0(L8E71)                BRANCH IF NOT END OF FORMAT STRING
fac1 9e 0f              L8E82     LDX  000f(TEMPTR)               * RESTORE CURRENT FORMAT STRING COUNTER
fac3 d6 93                        LDB  0093(VD3)                  * AND POINTER TO POSITION BEFORE SPACES COMMAND
fac5 86 25                        LDA  #'%'                       SEND A '%' TO CONSOLE OUT AS A DEBUGGING AID
                        * ERROR PROCESSOR - ILLEGAL CHARACTER OR BAD SYNTAX IN FORMAT STRING
fac7 bd fc 17           L8E88     JSR  L8FD8                      SEND A '+' TO CONSOLE OUT IF VDA <> 0
faca bd db 14                     JSR  db14(PUTCHR)               SEND CHARACTER TO CONSOLE OUT
facd 20 29                        BRA  L8EB9                      GET NEXT CHARACTER IN FORMAT STRING

                        * PRINT RAM HOOK
facf 81 b1              XVEC9     CMPA #00b1(TOK_USING)           USING TOKEN
fad1 27 01                        BEQ  L8E95                      BRANCH IF PRINT USING
fad3 39                           RTS

                        * PRINT USING
                        * VDA IS USED AS A STATUS BYTE: BIT 6 = COMMA FORCE
                        * BIT 5=LEADING ASTERISK FORCE; BIT 4 = FLOATING $ FORCE
                        * BIT 3 = PRE SIGN FORCE; BIT 2 = POST SIGN FORCE; BIT 0 = EXPONENTIAL FORCE
fad4 32 62              L8E95     LEAS $02,S                      PURGE RETURN ADDRESS OFF THE STACK
fad6 bd e3 e1                     JSR  e3e1(LB158)                EVALUATE FORMAT STRING
fad9 bd e3 cf                     JSR  e3cf(LB146)                'TM' ERROR IF VARIABLE TYPE = NUMERIC
fadc c6 3b                        LDB  #';'                       CHECK FOR ITEM LIST SEPARATOR
fade bd e4 f8                     JSR  e4f8(LB26F)                SYNTAX CHECK FOR ;
fae1 9e 52                        LDX  0050(FPA0)+2               * GET FORMAT STRING DESCRIPTOR ADDRESS
fae3 9f 95                        STX  0095(VD5)                  * AND SAVE IT IN VD5
fae5 20 06                        BRA  L8EAE                      GO PROCESS FORMAT STRING
fae7 96 97              L8EA8     LDA  0097(VD7)                  *CHECK NEXT PRINT ITEM FLAG AND
fae9 27 08                        BEQ  L8EB4                      *'FC' ERROR IF NO FURTHER PRINT ITEMS
faeb 9e 95                        LDX  0095(VD5)                  RESET FORMAT STRING POINTER TO START OF STRING
faed 0f 97              L8EAE     CLR  0097(VD7)                  RESET NEXT PRINT ITEM FLAG
faef e6 84                        LDB  ,X                         GET LENGTH OF FORMAT STRING
faf1 26 03                        BNE  L8EB7                      INTERPRET FORMAT STRING IF LENGTH > 0
faf3 7e e6 ce           L8EB4     JMP  e6ce(LB44A)                'FC' ERROR IF FORMAT STRING = NULL
faf6 ae 02              L8EB7     LDX  $02,X                      POINT X TO START OF FORMAT STRING
                        * INTERPRET THE FORMAT STRING
faf8 0f 9a              L8EB9     CLR  009a(VDA)                  CLEAR THE STATUS BYTE
fafa 0f 99              L8EBB     CLR  0099(VD9)                  CLEAR LEFT DIGIT COUNTER
fafc a6 80                        LDA  ,X+                        GET A CHARACTER FROM FORMAT STRING
fafe 81 21                        CMPA #'!'                       EXCLAMATION POINT?
fb00 10 27 ff 72                  LBEQ fa76(L8E37)                YES - STRING TYPE FORMAT
fb04 81 23                        CMPA #'#'                       NUMBER SIGN? (DIGIT LOCATOR)
fb06 27 5b                        BEQ  L8F24                      YES - NUMERIC TYPE FORMAT
fb08 5a                           DECB                            DECREMENT FORMAT STRING LENGTH
fb09 26 16                        BNE  L8EE2                      BRANCH IF NOT DONE
fb0b bd fc 17                     JSR  L8FD8                      SEND A '+' TO CONSOLE OUT IF VDA <> 0
fb0e bd db 14                     JSR  db14(PUTCHR)               SEND CHARACTER TO CONSOLE OUT
fb11 9d 82              L8ED2     JSR  0082(GETCCH)               GET CURRENT CHARACTER FROM BASIC
fb13 26 d2                        BNE  fae7(L8EA8)                BRANCH IF NOT END OF LINE
fb15 96 97                        LDA  0097(VD7)                  GET NEXT PRINT ITEM FLAG
fb17 26 03              L8ED8     BNE  L8EDD                      BRANCH IF MORE PRINT ITEMS
fb19 bd eb a5                     JSR  eba5(LB958)                SEND A CARRIAGE RETURN TO CONSOLE OUT
fb1c 9e 95              L8EDD     LDX  0095(VD5)                  POINT X TO FORMAT STRING DESCRIPTOR
fb1e 7e e8 dd                     JMP  e8dd(LB659)                RETURN ADDRESS AND LENGTH OF FORMAT STRING - EXIT PRINT USING
fb21 81 2b              L8EE2     CMPA #'+'                       CHECK FOR '+' (PRE-SIGN FORCE)
fb23 26 09                        BNE  L8EEF                      NO PLUS
fb25 bd fc 17                     JSR  L8FD8                      SEND A '+' TO CONSOLE OUT IF VDA <> 0
fb28 86 08                        LDA  #$08                       * LOAD THE STATUS BYTE WITH 8;
fb2a 97 9a                        STA  009a(VDA)                  * PRE-SIGN FORCE FLAG
fb2c 20 cc                        BRA  fafa(L8EBB)                INTERPRET THE REST OF THE FORMAT STRING
fb2e 81 2e              L8EEF     CMPA #'.'                       DECIMAL POINT?
fb30 27 4e                        BEQ  L8F41                      YES
fb32 81 25                        CMPA #'%'                       PERCENT SIGN?
fb34 10 27 ff 70                  LBEQ faa8(L8E69)                YES
fb38 a1 84                        CMPA ,X                         COMPARE THE PRESENT FORMAT STRING INPUT
                        *              CHARACTER TO THE NEXT ONE IN THE STRING
fb3a 26 8b              L8EFB     BNE  fac7(L8E88)                NO MATCH - ILLEGAL CHARACTER
                        * TWO CONSECUTIVE EQUAL CHARACTERS IN FORMAT STRING
fb3c 81 24                        CMPA #'$'                       DOLLAR SIGN?
fb3e 27 19                        BEQ  L8F1A                      YES - MAKE THE DOLLAR SIGN FLOAT
fb40 81 2a                        CMPA #'*'                       ASTERISK?
fb42 26 f6                        BNE  fb3a(L8EFB)                NO - ILLEGAL CHARACTER
fb44 96 9a                        LDA  009a(VDA)                  * GRAB THE STATUS BYTE AND BET BIT 5
fb46 8a 20                        ORA  #$20                       * TO INDICATE THAT THE OUTPUT WILL
fb48 97 9a                        STA  009a(VDA)                  * BE LEFT PADDED WITH ASTERISKS
fb4a c1 02                        CMPB #2                         * CHECK TO SEE IF THE $$ ARE THE LAST TWO
fb4c 25 11                        BLO  L8F20                      * CHARACTERS IN THE FORMAT STRING AND BRANCH IF SO
fb4e a6 01                        LDA  $01,X                      GET THE NEXT CHARACTER AFTER **
fb50 81 24                        CMPA #'$'                       CHECK FOR **$
fb52 26 0b                        BNE  L8F20                      CHECK FOR MORE CHARACTERS
fb54 5a                           DECB                            DECREMENT STRING LENGTH COUNTER
fb55 30 01                        LEAX $01,X                      MOVE FORMAT STRING POINTER UP ONE
fb57 0c 99                        INC  0099(VD9)                  ADD ONE TO LEFT DIGIT COUNTER - FOR ASTERISK PAD AND
                        *              FLOATING DOLLAR SIGN COMBINATION
fb59 96 9a              L8F1A     LDA  009a(VDA)                  * GET THE STATUS BYTE AND SET
fb5b 8a 10                        ORA  #$10                       * BIT 4 TO INDICATE A
fb5d 97 9a                        STA  009a(VDA)                  * FLOATING DOLLAR SIGN
fb5f 30 01              L8F20     LEAX $01,X                      MOVE FORMAT STRING POINTER UP ONE
fb61 0c 99                        INC  0099(VD9)                  ADD ONE TO LEFT DIGIT (FLOATING $ OR ASTERISK PAD)
                        * PROCESS CHARACTERS TO THE LEFT OF THE DECIMAL POINT IN THE FORMAT STRING
fb63 0f 98              L8F24     CLR  0098(VD8)                  CLEAR THE RIGHT DIGIT COUNTER
fb65 0c 99              L8F26     INC  0099(VD9)                  ADD ONE TO LEFT DIGIT COUNTER
fb67 5a                           DECB                            DECREMENT FORMAT STRING LENGTH COUNTER
fb68 27 49                        BEQ  L8F74                      BRANCH IF END OF FORMAT STRING
fb6a a6 80                        LDA  ,X+                        GET THE NEXT FORMAT CHARACTER
fb6c 81 2e                        CMPA #'.'                       DECIMAL POINT?
fb6e 27 1e                        BEQ  L8F4F                      YES
fb70 81 23                        CMPA #'#'                       NUMBER SIGN?
fb72 27 f1                        BEQ  fb65(L8F26)                YES
fb74 81 2c                        CMPA #','                       COMMA?
fb76 26 21                        BNE  L8F5A                      NO
fb78 96 9a                        LDA  009a(VDA)                  * GET THE STATUS BYTE
fb7a 8a 40                        ORA  #$40                       * AND SET BIT 6 WHICH IS THE
fb7c 97 9a                        STA  009a(VDA)                  * COMMA SEPARATOR FLAG
fb7e 20 e5                        BRA  fb65(L8F26)                PROCESS MORE CHARACTERS TO LEFT OF DECIMAL POINT
                        * PROCESS DECIMAL POINT IF NO DIGITS TO LEFT OF IT
fb80 a6 84              L8F41     LDA  ,X                         GET NEXT FORMAT CHARACTER
fb82 81 23                        CMPA #'#'                       IS IT A NUMBER SIGN?
fb84 10 26 ff 3f                  LBNE fac7(L8E88)                NO
fb88 86 01                        LDA  #1                         * SET THE RIGHT DIGIT COUNTER TO 1 -
fb8a 97 98                        STA  0098(VD8)                  * ALLOW ONE SPOT FOR DECIMAL POINT
fb8c 30 01                        LEAX $01,X                      MOVE FORMAT POINTER UP ONE
                        * PROCESS DIGITS TO RIGHT OF DECIMAL POINT
fb8e 0c 98              L8F4F     INC  0098(VD8)                  ADD ONE TO RIGHT DIGIT COUNTER
fb90 5a                           DECB                            DECREMENT FORMAT LENGTH COUNTER
fb91 27 20                        BEQ  L8F74                      BRANCH IF END OF FORMAT STRING
fb93 a6 80                        LDA  ,X+                        GET A CHARACTER FROM FORMAT STRING
fb95 81 23                        CMPA #'#'                       IS IT NUMBER SIGN?
fb97 27 f5                        BEQ  fb8e(L8F4F)                YES - KEEP CHECKING
                        * CHECK FOR EXPONENTIAL FORCE
fb99 81 5e              L8F5A     CMPA #$5E                       CHECK FOR UP ARROW
fb9b 26 16                        BNE  L8F74                      NO UP ARROW
fb9d a1 84                        CMPA ,X                         IS THE NEXT CHARACTER AN UP ARROW?
fb9f 26 12                        BNE  L8F74                      NO
fba1 a1 01                        CMPA $01,X                      AND THE NEXT CHARACTER?
fba3 26 0e                        BNE  L8F74                      NO
fba5 a1 02                        CMPA $02,X                      HOW ABOUT THE 4TH CHARACTER?
fba7 26 0a                        BNE  L8F74                      NO, ALSO
fba9 c1 04                        CMPB #4                         * CHECK TO SEE IF THE 4 UP ARROWS ARE IN THE
fbab 25 06                        BLO  L8F74                      * FORMAT STRING AND BRANCH IF NOT
fbad c0 04                        SUBB #4                         * MOVE POINTER UP 4 AND SUBTRACT
fbaf 30 04                        LEAX $04,X                      * FOUR FROM LENGTH
fbb1 0c 9a                        INC  VDA INCREMENT S            TATUS BYTE - EXPONENTIAL FORM

                        * CHECK FOR A PRE OR POST - SIGN FORCE AT END OF FORMAT STRING
fbb3 30 1f              L8F74     LEAX $-01,X                     MOVE POINTER BACK ONE
fbb5 0c 99                        INC  0099(VD9)                  ADD ONE TO LEFT DIGIT COUNTER FOR PRE-SIGN FORCE
fbb7 96 9a                        LDA  009a(VDA)                  * PRE-SIGN
fbb9 85 08                        BITA #$08                       * FORCE AND
fbbb 26 18                        BNE  L8F96                      * BRANCH IF SET
fbbd 0a 99                        DEC  0099(VD9)                  DECREMENT LEFT DIGIT - NO PRE-SIGN FORCE
fbbf 5d                           TSTB * CHECK LENGTH             COUNTER AND BRANCH
fbc0 27 13                        BEQ  L8F96                      * IF END OF FORMAT STRING
fbc2 a6 84                        LDA  ,X                         GET NEXT FORMAT STRING CHARACTER
fbc4 80 2d                        SUBA #'-'                       CHECK FOR MINUS SIGN
fbc6 27 06                        BEQ  L8F8F                      BRANCH IF MINUS SIGN
fbc8 81 fe                        CMPA #$FE                       * WAS CMPA #('+')-('-')
fbca 26 09                        BNE  L8F96                      BRANCH IF NO PLUS SIGN
fbcc 86 08                        LDA  #$08                       GET THE PRE-SIGN FORCE FLAG
fbce 8a 04              L8F8F     ORA  #$04                       'OR' IN POST-SIGN FORCE FLAG
fbd0 9a 9a                        ORA  009a(VDA)                  'OR' IN THE STATUS BYTE
fbd2 97 9a                        STA  009a(VDA)                  SAVE THE STATUS BYTE
fbd4 5a                           DECB                            DECREMENT FORMAT STRING LENGTH

                        * EVALUATE NUMERIC ITEM-LIST
fbd5 9d 82              L8F96     JSR  0082(GETCCH)               GET CURRENT CHARACTER
fbd7 10 27 ff 3c                  LBEQ fb17(L8ED8)                BRANCH IF END OF LINE
fbdb d7 93                        STB  0093(VD3)                  SAVE FORMAT STRING LENGTH WHEN FORMAT EVALUATION ENDED
fbdd bd e3 ca                     JSR  e3ca(LB141)                EVALUATE EXPRESSION
fbe0 96 99                        LDA  0099(VD9)                  GET THE LEFT DIGIT COUNTER
fbe2 9b 98                        ADDA 0098(VD8)                  ADD IT TO THE RIGHT DIGIT COUNTER
fbe4 81 11                        CMPA #17                        *
fbe6 10 22 ea e4                  LBHI e6ce(LB44A)                *'FC' ERROR IF MORE THAN 16 DIGITS AND DECIMAL POiNT
fbea bd fc 24                     JSR  L8FE5                      CONVERT ITEM-LIST TO FORMATTED ASCII STRING
fbed 30 1f                        LEAX $-01,X                     MOVE BUFFER POINTER BACK ONE
fbef bd eb e5                     JSR  ebe5(LB99C)                DISPLAY THE FORMATTED STRING TO CONSOLE OUT
fbf2 0f 97              L8FB3     CLR  0097(VD7)                  RESET NEXT PRINT ITEM FLAG
fbf4 9d 82                        JSR  0082(GETCCH)               GET CURRENT INPUT CHARACTER
fbf6 27 0d                        BEQ  L8FC6                      BRANCH IF END OF LINE
fbf8 97 97                        STA  0097(VD7)                  SAVE CURRENT CHARACTER (<>0) IN NEXT PRINT ITEM FLAG
fbfa 81 3b                        CMPA #';'                       * CHECK FOR ; - ITEM-LIST SEPARATOR AND
fbfc 27 05                        BEQ  L8FC4                      * BRANCH IF SEMICOLON
fbfe bd e4 f6                     JSR  e4f6(LB26D)                SYNTAX CHECK FOR COMMA
fc01 20 02                        BRA  L8FC6                      PROCESS NEXT PRINT ITEM
fc03 9d 7c              L8FC4     JSR  007c(GETNCH)               GET NEXT INPUT CHARACTER
fc05 9e 95              L8FC6     LDX  0095(VD5)                  GET FORMAT STRING DESCRIPTOR ADDRESS
fc07 e6 84                        LDB  ,X                         GET LENGTH OF FORMAT STRING
fc09 d0 93                        SUBB 0093(VD3)                  SUBTRACT AMOUNT OF FORMAT STRING LEFT AFTER LAST PRINT ITEM
fc0b ae 02                        LDX  $02,X                      *GET FORMAT STRING START ADDRESS AND ADVANCE
fc0d 3a                           ABX  *POINTER TO STA            RT OF UNUSED FORMAT STRING
fc0e d6 93                        LDB  0093(VD3)                  * GET AMOUNT OF UNUSED FORMAT STRING
fc10 10 26 fe e4                  LBNE faf8(L8EB9)                * REINTERPRET FORMAT STRING FROM THAT POINT
fc14 7e fb 11                     JMP  fb11(L8ED2)                REINTERPRET FORMAT STRING FROM THE START IF ENTIRELY
                        *         USED ON LAST PRINT ITEM

                        * PRINT A '+' TO CONSOLE OUT IF THE STATUS BYTE <> 0
fc17 34 02              L8FD8     PSHS A                          RESTORE ACCA AND RETURN
fc19 86 2b                        LDA  #'+'                       GET ASCII PLUS SIGN
fc1b 0d 9a                        TST  009a(VDA)                  * CHECK THE STATUS BYTE AND
fc1d 27 03                        BEQ  L8FE3                      * RETURN IF = 0
fc1f bd db 14                     JSR  db14(PUTCHR)               SEND A CHARACTER TO CONSOLE OUT
fc22 35 82              L8FE3     PULS A,PC                       RETURN ACCA AND RETURN

                        * CONVERT ITEM-LIST TO DECIMAL ASCII STRING
fc24 ce 01 f2           L8FE5     LDU  #01ee(STRBUF)+4            POINT U TO STRING BUFFER
fc27 c6 20                        LDB  #0020(SPACE)               BLANK
fc29 96 9a                        LDA  009a(VDA)                  * GET THE STATUS FLAG AND
fc2b 85 08                        BITA #$08                       * CHECK FOR A PRE-SIGN FORCE
fc2d 27 02                        BEQ  L8FF2                      * BRANCH IF NO PRE-SIGN FORCE
fc2f c6 2b                        LDB  #'+'                       PLUS SIGN
fc31 0d 54              L8FF2     TST  0054(FP0SGN)               CHECK THE SIGN OF FPA0
fc33 2a 04                        BPL  L8FFA                      BRANCH IF POSITIVE
fc35 0f 54                        CLR  0054(FP0SGN)               FORCE FPA0 SIGN TO BE POSITIVE
fc37 c6 2d                        LDB  #'-'                       MINUS SIGN
fc39 e7 c0              L8FFA     STB  ,U+                        SAVE THE SIGN IN BUFFER
fc3b c6 30                        LDB  #'0'                       * PUT A ZERO INTO THE BUFFER
fc3d e7 c0                        STB  ,U+                        *
fc3f 84 01                        ANDA #$01                       * CHECK THE EXPONENTIAL FORCE FLAG IN
fc41 10 26 01 07                  LBNE L910D                      * THE STATUS BYTE - BRANCH IF ACTIVE
fc45 8e f0 09                     LDX  #f009(LBDC0)               POINT X TO FLOATING POINT 1E + 09
fc48 bd ee e9                     JSR  eee9(LBCA0)                COMPARE FPA0 TO (X)
fc4b 2b 15                        BMI  L9023                      BRANCH IF FPA0 < 1E+09
fc4d bd f0 22                     JSR  f022(LBDD9)                CONVERT FP NUMBER TO ASCII STRING
fc50 a6 80              L9011     LDA  ,X+                        * ADVANCE POINTER TO END OF
fc52 26 fc                        BNE  fc50(L9011)                * ASCII STRING (ZERO BYTE)
fc54 a6 82              L9015     LDA  ,-X                        MOVE THE
fc56 a7 01                        STA  $01,X                      ENTIRE STRING
fc58 8c 01 f1                     CMPX #01ee(STRBUF)+3            UP ONE
fc5b 26 f7                        BNE  fc54(L9015)                BYTE
fc5d 86 25                        LDA  #'%'                       * INSERT A % SIGN AT START OF
fc5f a7 84                        STA  ,X                         * STRING - OVERFLOW ERROR
fc61 39                           RTS

fc62 96 4f              L9023     LDA  004f(FP0EXP)               GET EXPONENT OF FPA0
fc64 97 47                        STA  0047(V47)                  AND SAVE IT IN V74
fc66 27 03                        BEQ  L902C                      BRANCH IF FPA0 = 0
fc68 bd fe 0c                     JSR  L91CD                      CONVERT FPA0 TO NUMBER WITH 9 SIGNIFICANT
                        *              PLACES TO LEFT OF DECIMAL POINT
fc6b 96 47              L902C     LDA  0047(V47)                  GET BASE 10 EXPONENT OFFSET
fc6d 10 2b 00 81                  LBMI L90B3                      BRANCH IF FPA0 < 100,000,000
fc71 40                           NEGA                            * CALCULATE THE NUMBER OF LEADING ZEROES TO INSERT -
fc72 9b 99                        ADDA 0099(VD9)                  * SUBTRACT BASE 10 EXPONENT OFFSET AND 9 (FPA0 HAS
fc74 80 09                        SUBA #$09                       * 9 PLACES TO LEFT OF EXPONENT) FROM LEFT DIGIT COUNTER
fc76 bd fd 29                     JSR  L90EA                      PUT ACCA ZEROES IN STRING BUFFER
fc79 bd fe a2                     JSR  L9263                      INITIALIZE DECIMAL POINT AND COMMA COUNTERS
fc7c bd fe 41                     JSR  L9202                      CONVERT FPA0 TO DECIMAL ASCII IN THE STRING BUFFER
fc7f 96 47                        LDA  0047(V47)                  * GET BASE 10 EXPONENT AND PUT THAT MANY
fc81 bd fe c0                     JSR  L9281                      * ZEROES IN STRING BUFFER - STOP AT DECIMAL POINT
fc84 96 47                        LDA  0047(V47)                  WASTED INSTRUCTION - SERVES NO PURPOSE
fc86 bd fe 88                     JSR  L9249                      CHECK FOR DECIMAL POINT
fc89 96 98                        LDA  0098(VD8)                  GET THE RIGHT DIGIT COUNTER
fc8b 26 02                        BNE  L9050                      BRANCH IF RIGHT DIGlT COUNTER <> 0
fc8d 33 5f                        LEAU $-01,U                     * MOVE BUFFER POINTER BACK ONE - DELETE
                        *              * DECIMAL POINT IF NO RIGHT DIGITS SPECiFIED
fc8f 4a                 L9050     DECA                            SUBTRACT ONE (DECIMAL POINT)
fc90 bd fd 29                     JSR  L90EA                      PUT ACCA ZEROES INTO BUFFER (TRAILING ZEROES)
fc93 bd fd c4           L9054     JSR  L9185                      INSERT ASTERISK PADDING, FLOATING $, AND POST-SIGN
fc96 4d                           TSTA                            WAS THERE A POST-SIGN?
fc97 27 06                        BEQ  L9060                      NO
fc99 c1 2a                        CMPB #'*'                       IS THE FIRST CHARACTER AN $?
fc9b 27 02                        BEQ  L9060                      YES
fc9d e7 c0                        STB  ,U+                        STORE THE POST-SIGN
fc9f 6f c4              L9060     CLR  ,U                         CLEAR THE LAST CHARACTER IN THE BUFFER
                        *
                        * REMOVE ANY EXTRA BLANKS OR ASTERISKS FROM THE
                        * STRING BUFFER TO THE LEFT OF THE DECIMAL POINT
fca1 8e 01 f1                     LDX  #01ee(STRBUF)+3 POINT       X TO THE START OF THE BUFFER
fca4 30 01              L9065     LEAX $01,X                      MOVE BUFFER POINTER UP ONE
fca6 9f 0f                        STX  000f(TEMPTR)               SAVE BUFFER POINTER IN TEMPTR
fca8 96 3a                        LDA  0039(VARPTR)+1             * GET ADDRESS OF DECIMAL POINT IN BUFFER, SUBTRACT
fcaa 90 10                        SUBA 000f(TEMPTR)+1             * CURRENT POSITION AND SUBTRACT LEFT DIGIT COUNTER -
fcac 90 99                        SUBA 0099(VD9)                  * THE RESULT WILL BE ZERO WHEN TEMPTR+1 IS POINTING
                        *              * TO THE FIRST DIGIT OF THE FORMAT STRING
fcae 27 38                        BEQ  L90A9                      RETURN IF NO DIGITS TO LEFT OF THE DECiMAL POINT
fcb0 a6 84                        LDA  ,X                         GET THE CURRENT BUFFER CHARACTER
fcb2 81 20                        CMPA #0020(SPACE)               SPACE?
fcb4 27 ee                        BEQ  fca4(L9065)                YES - ADVANCE POINTER
fcb6 81 2a                        CMPA #'*'                       ASTERISK?
fcb8 27 ea                        BEQ  fca4(L9065)                YES - ADVANCE POINTER
fcba 4f                           CLRA                            A ZERO ON THE STACK IS END OF DATA POINTER
fcbb 34 02              L907C     PSHS A                          PUSH A CHARACTER ONTO THE STACK
fcbd a6 80                        LDA  ,X+                        GET NEXT CHARACTER FROM BUFFER
fcbf 81 2d                        CMPA #'-'                       MINUS SIGN?
fcc1 27 f8                        BEQ  fcbb(L907C)                YES
fcc3 81 2b                        CMPA #'+'                       PLUS SIGN?
fcc5 27 f4                        BEQ  fcbb(L907C)                YES
fcc7 91 00                        CMPA $'$'                       DOLLAR SIGN?
fcc9 27 f0                        BEQ  fcbb(L907C)                YES
fccb 81 30                        CMPA #'0'                       ZERO?
fccd 26 0e                        BNE  L909E                      NO - ERROR
fccf a6 01                        LDA  $01,X                      GET CHARACTER FOLLOWING ZERO
fcd1 8d 16                        BSR  L90AA                      CLEAR CARRY IF NUMERIC
fcd3 25 08                        BLO  L909E                      BRANCH IF NOT A NUMERIC CHARACTER - ERROR
fcd5 35 02              L9096     PULS A                          * PULL A CHARACTER OFF OF THE STACK
fcd7 a7 82                        STA  ,-X                        * AND PUT IT BACK IN THE STRING BUFFER
fcd9 26 fa                        BNE  fcd5(L9096)                * KEEP GOING UNTIL ZERO FLAG
fcdb 20 c7                        BRA  fca4(L9065)                KEEP CLEANING UP THE INPUT BUFFER
fcdd 35 02              L909E     PULS A
fcdf 4d                           TSTA                            * THE STACK AND EXIT WHEN
fce0 26 fb                        BNE  fcdd(L909E)                * ZERO FLAG FOUND
fce2 9e 0f                        LDX  000f(TEMPTR)               GET THE STRING BUFFER START POINTER
fce4 86 25                        LDA  #'%'                       * PUT A % SIGN BEFORE THE ERROR POSITION TO
fce6 a7 82                        STA  ,-X                        * INDICATE AN ERROR
fce8 39                 L90A9     RTS
                        *
                        * CLEAR CARRY IF NUMERIC
fce9 81 30              L90AA     CMPA #'0'                       ASCII ZERO
fceb 25 04                        BLO  L90B2                      RETURN IF ACCA < ASCII 0
fced 80 3a                        SUBA #$3A                       *  #'9'+1
fcef 80 c6                        SUBA #$C6                       * #-('9'+1)  CARRY CLEAR IF NUMERIC
fcf1 39                 L90B2     RTS
                        *
                        * PROCESS AN ITEM-LIST WHICH IS < 100,000,000
fcf2 96 98              L90B3     LDA  0098(VD8)                  GET RIGHT DIGIT COUNTER
fcf4 27 01                        BEQ  L90B8                      BRANCH IF NO FORMATTED DIGITS TO THE RIGHT OF DECIMAL PT
fcf6 4a                           DECA                            SUBTRACT ONE FOR DECIMAL POINT
fcf7 9b 47              L90B8     ADDA 0047(V47)                  *ADD THE BASE 10 EXPONENT OFFSET - ACCA CONTAINS THE
                        *         *NUMBER OF SHIFTS REQUIRED TO ADJUST FPA0 TO THE SPECIFIED
                        *         *NUMBER OF DlGITS TO THE RIGHT OF THE DECIMAL POINT
fcf9 2b 01                        BMI  L90BD                      IF ACCA >= 0 THEN NO SHIFTS ARE REQUIRED
fcfb 4f                           CLRA                            FORCE SHIFT COUNTER = 0
fcfc 34 02              L90BD     PSHS A                          SAVE INITIAL SHIFT COUNTER ON THE STACK
fcfe 2a 0a              L90BF     BPL  L90CB                      EXIT ROUTINE IF POSITIVE
fd00 34 02                        PSHS A                          SAVE SHIFT COUNTER ON STACK
fd02 bd ed cb                     JSR  edcb(LBB82)                DIVIDE FPA0 BY 10 - SHIFT ONE DIGIT TO RIGHT
fd05 35 02                        PULS A                          GET SHIFT COUNTER FROM THE STACK
fd07 4c                           INCA                            BUMP SHIFT COUNTER UP BY ONE
fd08 20 f4                        BRA  fcfe(L90BF)                CHECK FOR FURTHER DIVISION
fd0a 96 47              L90CB     LDA  0047(V47)                  * GET BASE 10 EXPONENT OFFSET, ADD INITIAL SHIFT COUNTER
fd0c a0 e0                        SUBA ,S+                        * AND SAVE NEW BASE 10 EXPONENT OFFSET - BECAUSE
fd0e 97 47                        STA  0047(V47)                  * FPA0 WAS SHIFTED ABOVE
fd10 8b 09                        ADDA #$09                       * ADD NINE (SIGNIFICANT PLACES) AND BRANCH IF THERE ARE NO
fd12 2b 19                        BMI  L90EE                      * ZEROES TO THE LEFT OF THE DECIMAL POINT IN THIS PRINT ITEM
fd14 96 99                        LDA  0099(VD9)                  *DETERMINE HOW MANY FILLER ZEROES TO THE LEFT OF THE DECIMAL
fd16 80 09                        SUBA #$09                       *POINT. GET THE NUMBER OF FORMAT PLACES TO LEFT OF DECIMAL
fd18 90 47                        SUBA 0047(V47)                  *POINT, SUBTRACT THE BASE 10 EXPONENT OFFSET AND THE CONSTANT 9
fd1a 8d 0d                        BSR  L90EA                      *(UNNORMALIZATION)-THEN OUTPUT THAT MANY ZEROES TO THE BUFFER
fd1c bd fe a2                     JSR  L9263                      INITIALIZE DECIMAL POINT AND COMMA COUNTERS
fd1f 20 1d                        BRA  L90FF                      PROCESS THE REMAINDER OF THE PRINT ITEM
                        *
                        * PUT (ACCA+1) ASCII ZEROES IN BUFFER
fd21 34 02              L90E2     PSHS A                          SAVE ZERO COUNTER
fd23 86 30                        LDA  #'0'                       * INSERT A ZERO INTO
fd25 a7 c0                        STA  ,U+                        * THE BUFFER
fd27 35 02                        PULS A                          RESTORE ZERO COUNTER

                        * PUT ACCA ASCII ZEROES INTO THE BUFFER
fd29 4a                 L90EA     DECA                            DECREMENT ZERO COUNTER
fd2a 2a f5                        BPL  fd21(L90E2)                BRANCH IF NOT DONE
fd2c 39                           RTS

fd2d 96 99              L90EE     LDA  0099(VD9)                  * GET THE LEFT DIGIT COUNTER AND PUT
fd2f 8d f8                        BSR  fd29(L90EA)                * THAT MANY ZEROES IN THE STRiNG BUFFER
fd31 bd fe 8c                     JSR  L924D                      PUT THE DECIMAL POINT IN THE STRING BUFFER
fd34 86 f7                        LDA  #-9                        *DETERMINE HOW MANY FILLER ZEROES BETWEEN THE DECIMAL POINT
fd36 90 47                        SUBA 0047(V47)                  *AND SIGNIFICANT DATA. SUBTRACT BASE 10 EXPONENT FROM -9
fd38 8d ef                        BSR  fd29(L90EA)                *(UNNORMALIZATION) AND OUTPUT THAT MANY ZEROES TO BUFFER
fd3a 0f 45                        CLR  0045(V45)                  CLEAR THE DECIMAL POINT COUNTER - SUPPRESS THE DECIMAL POINT
fd3c 0f 97                        CLR  0097(VD7)                  CLEAR THE COMMA COUNTER - SUPPRESS COMMAS
fd3e bd fe 41           L90FF     JSR  L9202                      DECODE FPA0 INTO A DECIMAL ASCII STRING
fd41 96 98                        LDA  0098(VD8)                  GET THE RIGHT DIGIT COUNTER
fd43 26 02                        BNE  L9108                      BRANCH IF RIGHT DIGIT COUNTER <> 0
fd45 de 39                        LDU  0039(VARPTR)               RESET BUFFER PTR TO THE DECIMAL POINT IF NO DIGITS TO RIGHT
fd47 9b 47              L9108     ADDA 0047(V47)                  *ADD BASE 10 EXPONENT - A POSITIVE ACCA WILL CAUSE THAT MANY
                        * *FILLER ZEROES TO BE OUTPUT TO THE RIGHT OF LAST SIGNIFICANT DATA
                        *         *SIGNIFICANT DATA
fd49 16 ff 43                     LBRA fc8f(L9050)                INSERT LEADING ASTERISKS, FLOATING DOLLAR SIGN, ETC
                        *
                        * FORCE THE NUMERIC OUTPUT FORMAT TO BE EXPONENTIAL FORMAT
fd4c 96 4f              L910D     LDA  004f(FP0EXP)               * GET EXPONENT OF FPA0 AND
fd4e 34 02                        PSHS A                          * SAVE IT ON THE STACK
fd50 27 03                        BEQ  L9116                      BRANCH IF FPA0 = 0
fd52 bd fe 0c                     JSR  L91CD                      *CONVERT FPA0 INTO A NUMBER WITH 9 SIGNIFICANT
                        *         *DIGITS TO THE LEFT OF THE DECIMAL POINT
fd55 96 98              L9116     LDA  0098(VD8)                  GET THE RIGHT DIGIT COUNTER
fd57 27 01                        BEQ  L911B                      BRANCH IF NO FORMATTED DIGITS TO THE RIGHT
fd59 4a                           DECA                            SUBTRACT ONE FOR THE DECIMAL POINT
fd5a 9b 99              L911B     ADDA 0099(VD9)                  ADD TO THE LEFT DIGIT COUNTER
fd5c 7f 01 f1                     CLR  01ee(STRBUF)+3             CLEAR BUFFER BYTE AS TEMPORARY STORAGE LOCATION
fd5f d6 9a                        LDB  009a(VDA)                  * GET THE STATUS BYTE FOR A
fd61 c4 04                        ANDB #$04                       * POST-BYTE FORCE; BRANCH IF
fd63 26 03                        BNE  L9129                      * A POST-BYTE FORCE
fd65 73 01 f1                     COM  01ee(STRBUF)+3             TOGGLE BUFFER BYTE TO -1 IF NO POST-BYTE FORCE
fd68 bb 01 f1           L9129     ADDA 01ee(STRBUF)+3             SUBTRACT 1 IF NO POST BYTE FORCE
fd6b 80 09                        SUBA #$09                       *SUBTRACT 9 (DUE TO THE CONVERSION TO 9
                        *         *SIGNIFICANT DIGITS TO LEFT OF DECIMAL POINT)
fd6d 34 02                        PSHS A                          * SAVE SHIFT COUNTER ON THE STACK - ACCA CONTAINS THE NUMBER
                        *         OF   SHIFTS REQUIRED TO ADJUST FPA0 FOR THE NUMBER OF
                        *         FORMATTED PLACES TO THE RIGHT OF THE DECIMAL POINT.
fd6f 2a 0a              L9130     BPL  L913C                      NO MORE SHIFTS WHEN ACCA >= 0
fd71 34 02                        PSHS A                          SAVE SHIFT COUNTER
fd73 bd ed cb                     JSR  edcb(LBB82)                DIVIDE FPA0 BY 10 - SHIFT TO RIGHT ONE
fd76 35 02                        PULS A                          RESTORE THE SHIFT COUNTER
fd78 4c                           INCA                            ADD 1 TO SHIFT COUNTER
fd79 20 f4                        BRA  fd6f(L9130)                CHECK FOR FURTHER SHIFTING (DIVISION)
fd7b a6 e4              L913C     LDA  ,S                         *GET THE INITIAL VALUE OF THE SHIFT COUNTER
fd7d 2b 01                        BMI  L9141                      *AND BRANCH IF SHIFTING HAS TAKEN PLACE
fd7f 4f                           CLRA                            RESET ACCA IF NO SHIFTING HAS TAKEN PLACE
fd80 40                 L9141     NEGA                            *CALCULATE THE POSITION OF THE DECIMAL POINT BY
fd81 9b 99                        ADDA 0099(VD9)                  *NEGATING SHIFT COUNTER, ADDING THE LEFT DIGIT COUNTER
fd83 4c                           INCA                            *PLUS ONE AND THE POST-BYTE POSlTION, IF USED
fd84 bb 01 f1                     ADDA 01ee(STRBUF)+3             *
fd87 97 45                        STA  0045(V45)                  SAVE DECIMAL POINT COUNTER
fd89 0f 97                        CLR  0097(VD7)                  CLEAR COMMA COUNTER - NO COMMAS INSERTED
fd8b bd fe 41                     JSR  L9202                      CONVERT FPA0 INTO ASCII DECIMAL STRING
fd8e 35 02                        PULS A                          * GET THE INITIAL VALUE OF SHIFT COUNTER AND
fd90 bd fe c0                     JSR  L9281                      * INSERT THAT MANY ZEROES INTO THE BUFFER
fd93 96 98                        LDA  0098(VD8)                  *GET THE RIGHT DIGIT COUNTER AND BRANCH
fd95 26 02                        BNE  L915A                      *IF NOT ZERO
fd97 33 5f                        LEAU $-01,U                     MOVE BUFFER POINTER BACK ONE

                        * CALCULATE VALUE OF EXPONENT AND PUT IN STRING BUFFER
fd99 e6 e0              L915A     LDB  ,S+                        GET ORIGINAL EXPONENT OF FPA0
fd9b 27 09                        BEQ  L9167                      BRANCH IF EXPONENT = 0
fd9d d6 47                        LDB  0047(V47)                  GET BASE 10 EXPONENT
fd9f cb 09                        ADDB #$09                       ADD 9 FOR 9 SIGNIFICANT DIGIT CONVERSION
fda1 d0 99                        SUBB 0099(VD9)                  SUBTRACT LEFT DIGIT COUNTER
fda3 f0 01 f1                     SUBB 01ee(STRBUF)+3             ADD ONE TO EXPONENT IF POST-SIGN FORCE
fda6 86 2b              L9167     LDA  #'+'                       PLUS SIGN
fda8 5d                           TSTB TEST EXPONENT
fda9 2a 03                        BPL  L916F                      BRANCH IF POSITIVE EXPONENT
fdab 86 2d                        LDA  #'-'                       MINUS SIGN
fdad 50                           NEGB                            CONVERT EXPONENT TO POSITIVE NUMBER
fdae a7 41              L916F     STA  $01,U                      PUT SIGN OF EXPONENT IN STRING BUFFER
fdb0 86 45                        LDA  #'E'                       * PUT AN 'E' (EXPONENTIATION FLAG) IN
fdb2 a7 c1                        STA  ,U++                       * BUFFER AND SKIP OVER THE SIGN
fdb4 86 2f                        LDA  #$2F                       * WAS LDA #'0'-1
                        *CONVERT BINARY EXPONENT IN ACCB TO ASCII VALUE IN ACCA
fdb6 4c                 L9177     INCA                            ADD ONE TO TENS DIGIT COUNTER
fdb7 c0 0a                        SUBB #10                        *SUBTRACT 10 FROM EXPONENT AND ADD ONE TO TENS
fdb9 24 fb                        BCC  fdb6(L9177)                * DIGIT IF NO CARRY. TENS DIGIT DONE IF THERE IS A CARRY
fdbb cb 3a                        ADDB #$3A                       WAS ADDB #'9'+1
fdbd ed c1                        STD  ,U++                       SAVE EXPONENT IN BUFFER
fdbf 6f c4                        CLR  ,U                         CLEAR FINAL BYTE IN BUFFER - PRINT TERMINATOR
fdc1 7e fc 93                     JMP  fc93(L9054)                INSERT ASTERISK PADDING, FLOATING DOLLAR SIGN, ETC.

                        * INSERT ASTERISK PADDING, FLOATING $ AND PRE-SIGN
fdc4 8e 01 f2           L9185     LDX  #01ee(STRBUF)+4            POINT X TO START OF PRINT ITEM BUFFER
fdc7 e6 84                        LDB  ,X                         * GET SIGN BYTE OF ITEM-LIST BUFFER
fdc9 34 04                        PSHS B                          * AND SAVE IT ON THE STACK
fdcb 86 20                        LDA  #0020(SPACE)               DEFAULT PAD WITH BLANKS
fdcd d6 9a                        LDB  009a(VDA)                  * GET STATUS BYTE AND CHECK FOR
fdcf c5 20                        BITB #$20                       * ASTERISK LEFT PADDING
fdd1 35 04                        PULS B                          GET SIGN BYTE AGAIN
fdd3 27 08                        BEQ  L919E                      BRANCH IF NO PADDING
fdd5 86 2a                        LDA  #'*'                       PAD WITH ASTERISK
fdd7 c1 20                        CMPB #0020(SPACE)               WAS THE FIRST BYTE A BLANK (POSITIVE)?
fdd9 26 02                        BNE  L919E                      NO
fddb 1f 89                        TFR  A,B                        TRANSFER PAD CHARACTER TO ACCB
fddd 34 04              L919E     PSHS B                          SAVE FIRST CHARACTER ON STACK
fddf a7 80              L91A0     STA  ,X+                        STORE PAD CHARACTER IN BUFFER
fde1 e6 84                        LDB  ,X                         GET NEXT CHARACTER IN BUFFER
fde3 27 10                        BEQ  L91B6                      INSERT A ZERO IF END OF BUFFER
fde5 c1 45                        CMPB #'E'                       * CHECK FOR AN 'E' AND
fde7 27 0c                        BEQ  L91B6                      * PUT A ZERO BEFORE IT
fde9 c1 30                        CMPB #'0'                       * REPLACE LEADING ZEROES WITH
fdeb 27 f2                        BEQ  fddf(L91A0)                * PAD CHARACTERS
fded c1 2c                        CMPB #','                       * REPLACE LEADING COMMAS
fdef 27 ee                        BEQ  fddf(L91A0)                * WITH PAD CHARACTERS
fdf1 c1 2e                        CMPB #'.'                       * CHECK FOR DECIMAL POINT
fdf3 26 04                        BNE  L91BA                      * AND DON'T PUT A ZERO BEFORE IT
fdf5 86 30              L91B6     LDA  #'0'                       * REPLACE PREVIOUS CHARACTER
fdf7 a7 82                        STA  ,-X                        * WITH A ZERO
fdf9 96 9a              L91BA     LDA  009a(VDA)                  * GET STATUS BYTE, CHECK
fdfb 85 10                        BITA #$10                       * FOR FLOATING $
fdfd 27 04                        BEQ  L91C4                      * BRANCH IF NO FLOATING $
fdff c6 24                        LDB  #'$'                       * STORE A $ IN
fe01 e7 82                        STB  ,-X                        * BUFFER
fe03 84 04              L91C4     ANDA #$04                       CHECK PRE-SIGN FLAG
fe05 35 04                        PULS B                          GET SIGN CHARACTER
fe07 26 02                        BNE  L91CC                      RETURN IF POST-SIGN REQUIRED
fe09 e7 82                        STB  ,-X                        STORE FIRST CHARACTER
fe0b 39                 L91CC     RTS
                        *
                        * CONVERT FPA0 INTO A NUMBER OF THE FORM - NNN,NNN,NNN X 10**M.
                        * THE EXPONENT M WILL BE RETURNED IN V47 (BASE 10 EXPONENT).
fe0c 34 40              L91CD     PSHS U                          SAVE BUFFER POINTER
fe0e 4f                           CLRA                            INITIAL EXPONENT OFFSET = 0
fe0f 97 47              L91D0     STA  0047(V47)                  SAVE EXPONENT OFFSET
fe11 d6 4f                        LDB  004f(FP0EXP)               GET EXPONENT OF FPA0
fe13 c1 80                        CMPB #$80                       * COMPARE TO EXPONENT OF .5
fe15 22 11                        BHI  L91E9                      * AND BRANCH IF FPA0 > = 1.0

                        * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 UNTIL IT IS >= 1
fe17 8e f0 09                     LDX  #f009(LBDC0)               POINT X TO FP NUMBER (1E+09)
fe1a bd ed 13                     JSR  ed13(LBACA)                MULTIPLY FPA0 BY 1E+09
fe1d 96 47                        LDA  0047(V47)                  GET EXPONENT OFFSET
fe1f 80 09                        SUBA #$09                       SUBTRACT 9 (BECAUSE WE MULTIPLIED BY 1E+09 ABOVE)
fe21 20 ec                        BRA  fe0f(L91D0)                CHECK TO SEE IF > 1.0
fe23 bd ed cb           L91E4     JSR  edcb(LBB82)                DIVIDE FPA0 BY 10
fe26 0c 47                        INC  0047(V47)                  INCREMENT EXPONENT OFFSET
fe28 8e f0 04           L91E9     LDX  #f004(LBDBB)               POINT X TO FP NUMBER (999,999,999)
fe2b bd ee e9                     JSR  eee9(LBCA0)                COMPARE FPA0 TO X
fe2e 2e f3                        BGT  fe23(L91E4)                BRANCH IF FPA0 > 999,999,999
fe30 8e ef ff           L91F1     LDX  #efff(LBDB6)               POINT X TO FP NUMBER (99,999,999.9)
fe33 bd ee e9                     JSR  eee9(LBCA0)                COMPARE FPA0 TO X
fe36 2e 07                        BGT  L9200                      RETURN IF 999,999,999 > FPA0 > 99,999,999.9
fe38 bd ed b3                     JSR  edb3(LBB6A)                MULTIPLY FPA0 BY 10
fe3b 0a 47                        DEC  0047(V47)                  DECREMENT EXPONENT OFFSET
fe3d 20 f1                        BRA  fe30(L91F1)                KEEP UNNORMALIZING
fe3f 35 c0              L9200     PULS U,PC                       RESTORE BUFFER POINTER AND RETURN
                        *
                        * CONVERT FPA0 INTO AN INTEGER, THEN DECODE IT
                        * INTO A DECIMAL ASCII STRING IN THE BUFFER
fe41 34 40              L9202     PSHS U                          SAVE BUFFER POINTER
fe43 bd eb fd                     JSR  ebfd(LB9B4)                ADD .5 TO FPA0 (ROUND OFF)
fe46 bd ef 11                     JSR  ef11(LBCC8)                CONVERT FPA0 TO INTEGER FORMAT
fe49 35 40                        PULS U                          RESTORE BUFFER POINTER
                        *
                        * CONVERT FPA0 INTO A DECIMAL ASCII STRING
fe4b 8e f1 0e                     LDX  #f10e(LBEC5)               POINT X TO UNNORMALIZED POWERS OF 10
fe4e c6 80                        LDB  #$80                       INITIALIZE DIGIT COUNTER TO 0 + $80.
                        * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA
                        * IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSA, IT IS
                        * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB
                        * IS HOW THIS ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURRING.
fe50 8d 36              L9211     BSR  L9249                      CHECK FOR COMMA INSERTION
fe52 96 53              L9213     LDA  0050(FPA0)+3               * 'ADD' A POWER OF 10 MANTISSA TO FPA0.
fe54 ab 03                        ADDA $03,X                      * IF THE MANTISSA IS NEGATIVE, A SUBTRACTION
fe56 97 53                        STA  0050(FPA0)+3               * WILL BE WHAT REALLY TAKES PLACE.
fe58 96 52                        LDA  0050(FPA0)+2               *
fe5a a9 02                        ADCA $02,X                      *
fe5c 97 52                        STA  0050(FPA0)+2               *
fe5e 96 51                        LDA  0050(FPA0)+1               *
fe60 a9 01                        ADCA $01,X                      *
fe62 97 51                        STA  0050(FPA0)+1               *
fe64 96 50                        LDA  0050(FPA0)                 *
fe66 a9 84                        ADCA ,X                         *
fe68 97 50                        STA  0050(FPA0)                 *
fe6a 5c                           INCB                            ADD ONE TO DIGIT COUNTER
fe6b 56                           RORB ROTATE CARRY IN            TO BIT 7
fe6c 59                           ROLB                            * SET OVERFLOW FLAG - BRANCH IF CARRY SET AND
fe6d 28 e3                        BVC  fe52(L9213)                * ADDING MANTISSA OR CARRY CLEAR AND SUBTRACTING MANTISSA
fe6f 24 03                        BCC  L9235                      BRANCH IF SUBTRACTING MANTISSA
fe71 c0 0b                        SUBB #10+1                      WAS SUBB #10+1
fe73 50                           NEGB                            * IF ADDING MANTISSA
fe74 cb 2f              L9235     ADDB #$2F                       WAS ADDB #'0'-1
fe76 30 04                        LEAX $04,X                      MOVE TO NEXT POWER OF 10 MANTISSA
fe78 1f 98                        TFR  B,A                        SAVE DIGIT IN ACCA
fe7a 84 7f                        ANDA #$7F                       MASK OFF ADD/SUBTRACT FLAG (BIT 7)
fe7c a7 c0                        STA  ,U+                        STORE DIGIT IN BUFFER
fe7e 53                           COMB                            TOGGLE ADD/SUBTRACT FLAG
fe7f c4 80                        ANDB #$80                       MASK OFF EVERYTHING BUT ADD/SUB FLAG
fe81 8c f1 32                     CMPX #f132(LBEE9)               COMPARE TO END OF UNNORMALIZED POWERS OF 10
fe84 26 ca                        BNE  fe50(L9211)                BRANCH IF NOT DONE
fe86 6f c4                        CLR  ,U                         PUT A ZERO AT END OF INTEGER

                        * DECREMENT DECIMAL POINT COUNTER AND CHECK FOR COMMA INSERTION
fe88 0a 45              L9249     DEC  0045(V45)                  DECREMENT DECIMAL POINT COUNTER
fe8a 26 09                        BNE  L9256                      NOT TIME FOR DECIMAL POINT
fe8c df 39              L924D     STU  0039(VARPTR)               SAVE BUFFER POINTER-POSITION OF THE DECIMAL POINT
fe8e 86 2e                        LDA  #'.'                       * STORE A DECIMAL
fe90 a7 c0                        STA  ,U+                        * POINT IN THE OUTPUT BUFFER
fe92 0f 97                        CLR  0097(VD7)                  * CLEAR COMMA COUNTER - NOW IT WILL TAKE 255
                        *                             * DECREMENTS BEFORE ANOTHER COMMA WILL BE INSERTED
fe94 39                           RTS
fe95 0a 97              L9256     DEC  0097(VD7)                  DECREMENT COMMA COUNTER
fe97 26 08                        BNE  L9262                      RETURN IF NOT TIME FOR COMMA
fe99 86 03                        LDA  #$03                       * RESET COMMA COUNTER TO 3; THREE
fe9b 97 97                        STA  0097(VD7)                  * DIGITS BETWEEN COMMAS
fe9d 86 2c                        LDA  #','                       * PUT A COMMA INTO
fe9f a7 c0                        STA  ,U+                        * THE BUFFER
fea1 39                 L9262     RTS

                        * INITIALIZE DECIMAL POINT AND COMMA COUNTERS
fea2 96 47              L9263     LDA  0047(V47)                  GET THE BASE 10 EXPONENT OFFSET
fea4 8b 0a                        ADDA #10                        * ADD 10 (FPA0 WAS 'NORMALIZED' TO 9 PLACES LEFT
fea6 97 45                        STA  0045(V45)                  * OF DECIMAL POINT) - SAVE IN DECIMAL POINT COUNTER
fea8 4c                           INCA                            ADD ONE FOR THE DECIMAL POINT
fea9 80 03              L926A     SUBA #$03                       * DIVIDE DECIMAL POINT COUNTER BY 3; LEAVE
feab 24 fc                        BCC  fea9(L926A)                * THE REMAINDER IN ACCA
fead 8b 05                        ADDA #$05                       CONVERT REMAINDER INTO A NUMBER FROM 1-3
feaf 97 97                        STA  0097(VD7)                  SAVE COMMA COUNTER
feb1 96 9a                        LDA  009a(VDA)                  GET STATUS BYTE
feb3 84 40                        ANDA #$40                       CHECK FOR COMMA FLAG
feb5 26 02                        BNE  L927A                      BRANCH IF COMMA FLAG ACTIVE
feb7 97 97                        STA  0097(VD7)                  CLEAR COMMA COUNTER - 255 DIGITS OUTPUT BEFORE A COMMA
feb9 39                 L927A     RTS
                        *
                        * INSERT ACCA ZEROES INTO THE BUFFER
feba 34 02              L927B     PSHS A                          SAVE ZEROES COUNTER
febc 8d ca                        BSR  fe88(L9249)                CHECK FOR DECIMAL POINT
febe 35 02                        PULS A                          RESTORE ZEROES COUNTER
fec0 4a                 L9281     DECA                            * DECREMENT ZEROES COUNTER AND
fec1 2b 0a                        BMI  L928E                      * RETURN IF < 0
fec3 34 02                        PSHS A                          SAVE ZEROES COUNTER
fec5 86 30                        LDA  #'0'                       * PUT A ZERO INTO
fec7 a7 c0                        STA  ,U+                        * THE BUFFER
fec9 a6 e0                        LDA  ,S+                        RESTORE THE ZEROES COUNTER
fecb 26 ed                        BNE  feba(L927B)                BRANCH IF NOT DONE
fecd 39                 L928E     RTS


                        * LINE
fece 81 89              LINE      CMPA #0089(TOK_INPUT)           'INPUT' TOKEN
fed0 10 27 f9 5c                  LBEQ f830(L89C0)                GO DO 'LINE INPUT' COMMAND
fed4 7e e5 00                     JMP  e500(LB277)                'SYNTAX ERROR' IF NOT "LINE INPUT"


                        * END OF EXTENDED BASIC
                        * INTERRUPT VECTORS
fff0                              ORG  $FFF0
fff0 00 00              LBFF0     FDB  $0000                      RESERVED
fff2 00 9b              LBFF2     FDB  009b(SW3VEC)               SWI3
fff4 00 9e              LBFF4     FDB  009e(SW2VEC)               SWI2
fff6 00 aa              LBFF6     FDB  00aa(FRQVEC)               FIRQ
fff8 00 a7              LBFF8     FDB  00a7(IRQVEC)               IRQ
fffa 00 a1              LBFFA     FDB  00a1(SWIVEC)               SWI
fffc 00 a4              LBFFC     FDB  00a4(NMIVEC)               NMI
fffe db 46              LBFFE     FDB  RESVEC                     RESET
